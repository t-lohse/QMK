   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 2
  13              		.file	"action.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.pre_process_record_quantum,"ax",%progbits
  18              		.align	1
  19              		.weak	pre_process_record_quantum
  20              		.arch armv7e-m
  21              		.syntax unified
  22              		.thumb
  23              		.thumb_func
  24              		.fpu fpv4-sp-d16
  26              	pre_process_record_quantum:
  27              	.LFB367:
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 0120     		movs	r0, #1
  33 0002 7047     		bx	lr
  34              		.cfi_endproc
  35              	.LFE367:
  37              		.section	.text.action_exec,"ax",%progbits
  38              		.align	1
  39              		.global	action_exec
  40              		.syntax unified
  41              		.thumb
  42              		.thumb_func
  43              		.fpu fpv4-sp-d16
  45              	action_exec:
  46              	.LFB338:
  47              		.file 1 "quantum/action.c"
   1:quantum/action.c **** /*
   2:quantum/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:quantum/action.c **** 
   4:quantum/action.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/action.c **** it under the terms of the GNU General Public License as published by
   6:quantum/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/action.c **** (at your option) any later version.
   8:quantum/action.c **** 
   9:quantum/action.c **** This program is distributed in the hope that it will be useful,
  10:quantum/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/action.c **** GNU General Public License for more details.
  13:quantum/action.c **** 
  14:quantum/action.c **** You should have received a copy of the GNU General Public License
  15:quantum/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/action.c **** */
  17:quantum/action.c **** #include "host.h"
  18:quantum/action.c **** #include "keycode.h"
  19:quantum/action.c **** #include "keyboard.h"
  20:quantum/action.c **** #include "mousekey.h"
  21:quantum/action.c **** #include "command.h"
  22:quantum/action.c **** #include "led.h"
  23:quantum/action.c **** #include "action_layer.h"
  24:quantum/action.c **** #include "action_tapping.h"
  25:quantum/action.c **** #include "action_macro.h"
  26:quantum/action.c **** #include "action_util.h"
  27:quantum/action.c **** #include "action.h"
  28:quantum/action.c **** #include "wait.h"
  29:quantum/action.c **** 
  30:quantum/action.c **** #ifdef BACKLIGHT_ENABLE
  31:quantum/action.c **** #    include "backlight.h"
  32:quantum/action.c **** #endif
  33:quantum/action.c **** 
  34:quantum/action.c **** #ifdef DEBUG_ACTION
  35:quantum/action.c **** #    include "debug.h"
  36:quantum/action.c **** #else
  37:quantum/action.c **** #    include "nodebug.h"
  38:quantum/action.c **** #endif
  39:quantum/action.c **** 
  40:quantum/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:quantum/action.c **** #    include "pointing_device.h"
  42:quantum/action.c **** #endif
  43:quantum/action.c **** 
  44:quantum/action.c **** int tp_buttons;
  45:quantum/action.c **** 
  46:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:quantum/action.c **** int retro_tapping_counter = 0;
  48:quantum/action.c **** #endif
  49:quantum/action.c **** 
  50:quantum/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:quantum/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:quantum/action.c **** #endif
  53:quantum/action.c **** 
  54:quantum/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  55:quantum/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  56:quantum/action.c **** #endif
  57:quantum/action.c **** 
  58:quantum/action.c **** __attribute__((weak)) bool pre_process_record_quantum(keyrecord_t *record) { return true; }
  59:quantum/action.c **** 
  60:quantum/action.c **** /** \brief Called to execute an action.
  61:quantum/action.c ****  *
  62:quantum/action.c ****  * FIXME: Needs documentation.
  63:quantum/action.c ****  */
  64:quantum/action.c **** void action_exec(keyevent_t event) {
  48              		.loc 1 64 36 view -0
  49              		.cfi_startproc
  50              		@ args = 0, pretend = 0, frame = 24
  51              		@ frame_needed = 0, uses_anonymous_args = 0
  52 0000 30B5     		push	{r4, r5, lr}
  53              		.cfi_def_cfa_offset 12
  54              		.cfi_offset 4, -12
  55              		.cfi_offset 5, -8
  56              		.cfi_offset 14, -4
  57 0002 87B0     		sub	sp, sp, #28
  58              		.cfi_def_cfa_offset 40
  59              	.LVL0:
  65:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  60              		.loc 1 65 5 view .LVU1
  64:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  61              		.loc 1 64 36 is_stmt 0 view .LVU2
  62 0004 6C46     		mov	r4, sp
  63 0006 84E80300 		stm	r4, {r0, r1}
  64              	.LVL1:
  66:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:quantum/action.c ****         dprint("EVENT: ");
  68:quantum/action.c ****         debug_event(event);
  69:quantum/action.c ****         dprintln();
  70:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  71:quantum/action.c ****         retro_tapping_counter++;
  72:quantum/action.c **** #endif
  73:quantum/action.c ****     }
  74:quantum/action.c **** 
  75:quantum/action.c ****     if (event.pressed) {
  65              		.loc 1 75 8 view .LVU3
  66 000a 9DF80230 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
  67 000e BDF80450 		ldrh	r5, [sp, #4]
  68              	.LVL2:
  69              	.LBB16:
  70              	.LBI16:
  71              		.file 2 "quantum/keyboard.h"
   1:quantum/keyboard.h **** /*
   2:quantum/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:quantum/keyboard.h **** 
   4:quantum/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:quantum/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:quantum/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/keyboard.h **** (at your option) any later version.
   8:quantum/keyboard.h **** 
   9:quantum/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:quantum/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/keyboard.h **** GNU General Public License for more details.
  13:quantum/keyboard.h **** 
  14:quantum/keyboard.h **** You should have received a copy of the GNU General Public License
  15:quantum/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/keyboard.h **** */
  17:quantum/keyboard.h **** 
  18:quantum/keyboard.h **** #pragma once
  19:quantum/keyboard.h **** 
  20:quantum/keyboard.h **** #include <stdbool.h>
  21:quantum/keyboard.h **** #include <stdint.h>
  22:quantum/keyboard.h **** 
  23:quantum/keyboard.h **** #ifdef __cplusplus
  24:quantum/keyboard.h **** extern "C" {
  25:quantum/keyboard.h **** #endif
  26:quantum/keyboard.h **** 
  27:quantum/keyboard.h **** /* key matrix position */
  28:quantum/keyboard.h **** typedef struct {
  29:quantum/keyboard.h ****     uint8_t col;
  30:quantum/keyboard.h ****     uint8_t row;
  31:quantum/keyboard.h **** } keypos_t;
  32:quantum/keyboard.h **** 
  33:quantum/keyboard.h **** /* key event */
  34:quantum/keyboard.h **** typedef struct {
  35:quantum/keyboard.h ****     keypos_t key;
  36:quantum/keyboard.h ****     bool     pressed;
  37:quantum/keyboard.h ****     uint16_t time;
  38:quantum/keyboard.h **** } keyevent_t;
  39:quantum/keyboard.h **** 
  40:quantum/keyboard.h **** /* equivalent test of keypos_t */
  41:quantum/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  42:quantum/keyboard.h **** 
  43:quantum/keyboard.h **** /* Rules for No Event:
  44:quantum/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  45:quantum/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  46:quantum/keyboard.h ****  */
  47:quantum/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
  72              		.loc 2 47 20 is_stmt 1 view .LVU4
  73              		.loc 2 47 51 view .LVU5
  74              		.loc 2 47 51 is_stmt 0 view .LVU6
  75              	.LBE16:
  69:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  76              		.loc 1 69 19 is_stmt 1 view .LVU7
  77              		.loc 1 75 5 view .LVU8
  78              		.loc 1 75 8 is_stmt 0 view .LVU9
  79 0012 0BB1     		cbz	r3, .L3
  76:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
  77:quantum/action.c ****         clear_weak_mods();
  80              		.loc 1 77 9 is_stmt 1 view .LVU10
  81 0014 FFF7FEFF 		bl	clear_weak_mods
  82              	.LVL3:
  83              	.L3:
  78:quantum/action.c ****     }
  79:quantum/action.c **** 
  80:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
  81:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  82:quantum/action.c ****         process_hand_swap(&event);
  83:quantum/action.c ****     }
  84:quantum/action.c **** #endif
  85:quantum/action.c **** 
  86:quantum/action.c ****     keyrecord_t record = {.event = event};
  84              		.loc 1 86 5 view .LVU11
  85              		.loc 1 86 17 is_stmt 0 view .LVU12
  86 0018 0023     		movs	r3, #0
  87 001a ADF81630 		strh	r3, [sp, #22]	@ movhi
  88 001e 94E80300 		ldm	r4, {r0, r1}
  89 0022 04AC     		add	r4, sp, #16
  90 0024 0490     		str	r0, [sp, #16]
  91 0026 ADF81410 		strh	r1, [sp, #20]	@ movhi
  87:quantum/action.c **** 
  88:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
  89:quantum/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  90:quantum/action.c ****     if (has_oneshot_layer_timed_out()) {
  91:quantum/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  92:quantum/action.c ****     }
  93:quantum/action.c ****     if (has_oneshot_mods_timed_out()) {
  94:quantum/action.c ****         clear_oneshot_mods();
  95:quantum/action.c ****     }
  96:quantum/action.c **** #        ifdef SWAP_HANDS_ENABLE
  97:quantum/action.c ****     if (has_oneshot_swaphands_timed_out()) {
  98:quantum/action.c ****         clear_oneshot_swaphands();
  99:quantum/action.c ****     }
 100:quantum/action.c **** #        endif
 101:quantum/action.c **** #    endif
 102:quantum/action.c **** #endif
 103:quantum/action.c **** 
 104:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 105:quantum/action.c ****     if (IS_NOEVENT(record.event) || pre_process_record_quantum(&record)) {
  92              		.loc 1 105 5 is_stmt 1 view .LVU13
  93 002a 94E80300 		ldm	r4, {r0, r1}
  94 002e 0290     		str	r0, [sp, #8]
  95              	.LVL4:
  96              	.LBB17:
  97              	.LBI17:
  98              		.loc 2 47 20 view .LVU14
  99              	.LBB18:
 100              		.loc 2 47 51 view .LVU15
 101              		.loc 2 47 74 is_stmt 0 view .LVU16
 102 0030 4DB1     		cbz	r5, .L5
 103              		.loc 2 47 99 view .LVU17
 104 0032 BDF80820 		ldrh	r2, [sp, #8]
 105              	.LVL5:
 106              		.loc 2 47 99 view .LVU18
 107              	.LBE18:
 108              	.LBE17:
 109              		.loc 1 105 8 view .LVU19
 110 0036 4FF6FF73 		movw	r3, #65535
 111 003a 9A42     		cmp	r2, r3
 112 003c 03D0     		beq	.L5
 113              		.loc 1 105 37 discriminator 1 view .LVU20
 114 003e 2046     		mov	r0, r4
 115 0040 FFF7FEFF 		bl	pre_process_record_quantum
 116              	.LVL6:
 117              		.loc 1 105 34 discriminator 1 view .LVU21
 118 0044 18B1     		cbz	r0, .L2
 119              	.L5:
 106:quantum/action.c ****         action_tapping_process(record);
 120              		.loc 1 106 9 is_stmt 1 view .LVU22
 121 0046 94E80300 		ldm	r4, {r0, r1}
 122 004a FFF7FEFF 		bl	action_tapping_process
 123              	.LVL7:
 124              	.L2:
 107:quantum/action.c ****     }
 108:quantum/action.c **** #else
 109:quantum/action.c ****     if (IS_NOEVENT(record.event) || pre_process_record_quantum(&record)) {
 110:quantum/action.c ****         process_record(&record);
 111:quantum/action.c ****     }
 112:quantum/action.c ****     if (!IS_NOEVENT(record.event)) {
 113:quantum/action.c ****         dprint("processed: ");
 114:quantum/action.c ****         debug_record(record);
 115:quantum/action.c ****         dprintln();
 116:quantum/action.c ****     }
 117:quantum/action.c **** #endif
 118:quantum/action.c **** }
 125              		.loc 1 118 1 is_stmt 0 view .LVU23
 126 004e 07B0     		add	sp, sp, #28
 127              		.cfi_def_cfa_offset 12
 128              		@ sp needed
 129 0050 30BD     		pop	{r4, r5, pc}
 130              		.cfi_endproc
 131              	.LFE338:
 133              		.section	.text.process_record_quantum,"ax",%progbits
 134              		.align	1
 135              		.weak	process_record_quantum
 136              		.syntax unified
 137              		.thumb
 138              		.thumb_func
 139              		.fpu fpv4-sp-d16
 141              	process_record_quantum:
 142              	.LVL8:
 143              	.LFB340:
 119:quantum/action.c **** 
 120:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 121:quantum/action.c **** bool swap_hands = false;
 122:quantum/action.c **** bool swap_held  = false;
 123:quantum/action.c **** 
 124:quantum/action.c **** /** \brief Process Hand Swap
 125:quantum/action.c ****  *
 126:quantum/action.c ****  * FIXME: Needs documentation.
 127:quantum/action.c ****  */
 128:quantum/action.c **** void process_hand_swap(keyevent_t *event) {
 129:quantum/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 130:quantum/action.c **** 
 131:quantum/action.c ****     keypos_t         pos     = event->key;
 132:quantum/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 133:quantum/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 134:quantum/action.c **** 
 135:quantum/action.c ****     if (do_swap) {
 136:quantum/action.c ****         event->key.row = pgm_read_byte(&hand_swap_config[pos.row][pos.col].row);
 137:quantum/action.c ****         event->key.col = pgm_read_byte(&hand_swap_config[pos.row][pos.col].col);
 138:quantum/action.c ****         swap_state[pos.row] |= col_bit;
 139:quantum/action.c ****     } else {
 140:quantum/action.c ****         swap_state[pos.row] &= ~(col_bit);
 141:quantum/action.c ****     }
 142:quantum/action.c **** }
 143:quantum/action.c **** #endif
 144:quantum/action.c **** 
 145:quantum/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:quantum/action.c **** bool disable_action_cache = false;
 147:quantum/action.c **** 
 148:quantum/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:quantum/action.c ****     disable_action_cache = true;
 150:quantum/action.c ****     process_record(record);
 151:quantum/action.c ****     disable_action_cache = false;
 152:quantum/action.c **** }
 153:quantum/action.c **** #else
 154:quantum/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:quantum/action.c **** #endif
 156:quantum/action.c **** 
 157:quantum/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
 144              		.loc 1 157 72 is_stmt 1 view -0
 145              		.cfi_startproc
 146              		@ args = 0, pretend = 0, frame = 0
 147              		@ frame_needed = 0, uses_anonymous_args = 0
 148              		@ link register save eliminated.
 149              		.loc 1 157 74 view .LVU25
 150              		.loc 1 157 87 is_stmt 0 view .LVU26
 151 0000 0120     		movs	r0, #1
 152              	.LVL9:
 153              		.loc 1 157 87 view .LVU27
 154 0002 7047     		bx	lr
 155              		.cfi_endproc
 156              	.LFE340:
 158              		.section	.text.post_process_record_quantum,"ax",%progbits
 159              		.align	1
 160              		.weak	post_process_record_quantum
 161              		.syntax unified
 162              		.thumb
 163              		.thumb_func
 164              		.fpu fpv4-sp-d16
 166              	post_process_record_quantum:
 167              	.LVL10:
 168              	.LFB341:
 158:quantum/action.c **** 
 159:quantum/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 169              		.loc 1 159 77 is_stmt 1 view -0
 170              		.cfi_startproc
 171              		@ args = 0, pretend = 0, frame = 0
 172              		@ frame_needed = 0, uses_anonymous_args = 0
 173              		@ link register save eliminated.
 174              		.loc 1 159 78 view .LVU29
 175 0000 7047     		bx	lr
 176              		.cfi_endproc
 177              	.LFE341:
 179              		.section	.text.process_record_tap_hint,"ax",%progbits
 180              		.align	1
 181              		.global	process_record_tap_hint
 182              		.syntax unified
 183              		.thumb
 184              		.thumb_func
 185              		.fpu fpv4-sp-d16
 187              	process_record_tap_hint:
 188              	.LVL11:
 189              	.LFB342:
 160:quantum/action.c **** 
 161:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 162:quantum/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:quantum/action.c ****  *
 164:quantum/action.c ****  * FIXME: Needs documentation.
 165:quantum/action.c ****  */
 166:quantum/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 190              		.loc 1 166 51 view -0
 191              		.cfi_startproc
 192              		@ args = 0, pretend = 0, frame = 0
 193              		@ frame_needed = 0, uses_anonymous_args = 0
 194              		@ link register save eliminated.
 167:quantum/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 195              		.loc 1 167 5 view .LVU31
 196              		.loc 1 167 23 is_stmt 0 view .LVU32
 197 0000 0088     		ldrh	r0, [r0]
 198              	.LVL12:
 199              		.loc 1 167 23 view .LVU33
 200 0002 FFF7FEBF 		b	layer_switch_get_action
 201              	.LVL13:
 202              		.cfi_endproc
 203              	.LFE342:
 205              		.section	.text.register_code,"ax",%progbits
 206              		.align	1
 207              		.global	register_code
 208              		.syntax unified
 209              		.thumb
 210              		.thumb_func
 211              		.fpu fpv4-sp-d16
 213              	register_code:
 214              	.LVL14:
 215              	.LFB346:
 168:quantum/action.c **** 
 169:quantum/action.c ****     switch (action.kind.id) {
 170:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:quantum/action.c ****         case ACT_SWAP_HANDS:
 172:quantum/action.c ****             switch (action.swap.code) {
 173:quantum/action.c ****                 case OP_SH_ONESHOT:
 174:quantum/action.c ****                     break;
 175:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:quantum/action.c ****                 default:
 177:quantum/action.c ****                     swap_hands = !swap_hands;
 178:quantum/action.c ****                     swap_held  = true;
 179:quantum/action.c ****             }
 180:quantum/action.c ****             break;
 181:quantum/action.c **** #    endif
 182:quantum/action.c ****     }
 183:quantum/action.c **** }
 184:quantum/action.c **** #endif
 185:quantum/action.c **** 
 186:quantum/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:quantum/action.c ****  *
 188:quantum/action.c ****  * FIXME: Needs documentation.
 189:quantum/action.c ****  */
 190:quantum/action.c **** void process_record(keyrecord_t *record) {
 191:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 192:quantum/action.c ****         return;
 193:quantum/action.c ****     }
 194:quantum/action.c **** 
 195:quantum/action.c ****     if (!process_record_quantum(record)) {
 196:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 197:quantum/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:quantum/action.c ****         }
 200:quantum/action.c **** #endif
 201:quantum/action.c ****         return;
 202:quantum/action.c ****     }
 203:quantum/action.c **** 
 204:quantum/action.c ****     process_record_handler(record);
 205:quantum/action.c ****     post_process_record_quantum(record);
 206:quantum/action.c **** }
 207:quantum/action.c **** 
 208:quantum/action.c **** void process_record_handler(keyrecord_t *record) {
 209:quantum/action.c **** #ifdef COMBO_ENABLE
 210:quantum/action.c ****     action_t action;
 211:quantum/action.c ****     if (record->keycode) {
 212:quantum/action.c ****         action = action_for_keycode(record->keycode);
 213:quantum/action.c ****     } else {
 214:quantum/action.c ****         action = store_or_get_action(record->event.pressed, record->event.key);
 215:quantum/action.c ****     }
 216:quantum/action.c **** #else
 217:quantum/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 218:quantum/action.c **** #endif
 219:quantum/action.c ****     dprint("ACTION: ");
 220:quantum/action.c ****     debug_action(action);
 221:quantum/action.c **** #ifndef NO_ACTION_LAYER
 222:quantum/action.c ****     dprint(" layer_state: ");
 223:quantum/action.c ****     layer_debug();
 224:quantum/action.c ****     dprint(" default_layer_state: ");
 225:quantum/action.c ****     default_layer_debug();
 226:quantum/action.c **** #endif
 227:quantum/action.c ****     dprintln();
 228:quantum/action.c **** 
 229:quantum/action.c ****     process_action(record, action);
 230:quantum/action.c **** }
 231:quantum/action.c **** 
 232:quantum/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 233:quantum/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 234:quantum/action.c **** #    ifdef PS2_MOUSE_ENABLE
 235:quantum/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 236:quantum/action.c **** #    endif
 237:quantum/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 238:quantum/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 239:quantum/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 240:quantum/action.c ****     pointing_device_set_report(currentReport);
 241:quantum/action.c **** #    endif
 242:quantum/action.c **** }
 243:quantum/action.c **** #endif
 244:quantum/action.c **** 
 245:quantum/action.c **** /** \brief Take an action and processes it.
 246:quantum/action.c ****  *
 247:quantum/action.c ****  * FIXME: Needs documentation.
 248:quantum/action.c ****  */
 249:quantum/action.c **** void process_action(keyrecord_t *record, action_t action) {
 250:quantum/action.c ****     keyevent_t event = record->event;
 251:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 252:quantum/action.c ****     uint8_t tap_count = record->tap.count;
 253:quantum/action.c **** #endif
 254:quantum/action.c **** 
 255:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 256:quantum/action.c ****     bool do_release_oneshot = false;
 257:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 258:quantum/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 259:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 260:quantum/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 261:quantum/action.c **** #    endif
 262:quantum/action.c ****     ) {
 263:quantum/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 264:quantum/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 265:quantum/action.c ****     }
 266:quantum/action.c **** #endif
 267:quantum/action.c **** 
 268:quantum/action.c ****     switch (action.kind.id) {
 269:quantum/action.c ****         /* Key and Mods */
 270:quantum/action.c ****         case ACT_LMODS:
 271:quantum/action.c ****         case ACT_RMODS: {
 272:quantum/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 273:quantum/action.c ****             if (event.pressed) {
 274:quantum/action.c ****                 if (mods) {
 275:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 276:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 277:quantum/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 278:quantum/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 279:quantum/action.c ****                         add_mods(mods);
 280:quantum/action.c ****                     } else {
 281:quantum/action.c ****                         add_weak_mods(mods);
 282:quantum/action.c ****                     }
 283:quantum/action.c ****                     send_keyboard_report();
 284:quantum/action.c ****                 }
 285:quantum/action.c ****                 register_code(action.key.code);
 286:quantum/action.c ****             } else {
 287:quantum/action.c ****                 unregister_code(action.key.code);
 288:quantum/action.c ****                 if (mods) {
 289:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 290:quantum/action.c ****                         del_mods(mods);
 291:quantum/action.c ****                     } else {
 292:quantum/action.c ****                         del_weak_mods(mods);
 293:quantum/action.c ****                     }
 294:quantum/action.c ****                     send_keyboard_report();
 295:quantum/action.c ****                 }
 296:quantum/action.c ****             }
 297:quantum/action.c ****         } break;
 298:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 299:quantum/action.c ****         case ACT_LMODS_TAP:
 300:quantum/action.c ****         case ACT_RMODS_TAP: {
 301:quantum/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 302:quantum/action.c ****             switch (action.layer_tap.code) {
 303:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 304:quantum/action.c ****                 case MODS_ONESHOT:
 305:quantum/action.c ****                     // Oneshot modifier
 306:quantum/action.c ****                     if (event.pressed) {
 307:quantum/action.c ****                         if (tap_count == 0) {
 308:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 309:quantum/action.c ****                             register_mods(mods | get_oneshot_mods());
 310:quantum/action.c ****                         } else if (tap_count == 1) {
 311:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 312:quantum/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 313:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 314:quantum/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 315:quantum/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 316:quantum/action.c ****                             clear_oneshot_mods();
 317:quantum/action.c ****                             set_oneshot_locked_mods(mods);
 318:quantum/action.c ****                             register_mods(mods);
 319:quantum/action.c **** #        endif
 320:quantum/action.c ****                         } else {
 321:quantum/action.c ****                             register_mods(mods | get_oneshot_mods());
 322:quantum/action.c ****                         }
 323:quantum/action.c ****                     } else {
 324:quantum/action.c ****                         if (tap_count == 0) {
 325:quantum/action.c ****                             clear_oneshot_mods();
 326:quantum/action.c ****                             unregister_mods(mods);
 327:quantum/action.c ****                         } else if (tap_count == 1) {
 328:quantum/action.c ****                             // Retain Oneshot mods
 329:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 330:quantum/action.c ****                             if (mods & get_mods()) {
 331:quantum/action.c ****                                 clear_oneshot_locked_mods();
 332:quantum/action.c ****                                 clear_oneshot_mods();
 333:quantum/action.c ****                                 unregister_mods(mods);
 334:quantum/action.c ****                             }
 335:quantum/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 336:quantum/action.c ****                             // Toggle Oneshot Layer
 337:quantum/action.c **** #        endif
 338:quantum/action.c ****                         } else {
 339:quantum/action.c ****                             clear_oneshot_mods();
 340:quantum/action.c ****                             unregister_mods(mods);
 341:quantum/action.c ****                         }
 342:quantum/action.c ****                     }
 343:quantum/action.c ****                     break;
 344:quantum/action.c **** #    endif
 345:quantum/action.c ****                 case MODS_TAP_TOGGLE:
 346:quantum/action.c ****                     if (event.pressed) {
 347:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 348:quantum/action.c ****                             register_mods(mods);
 349:quantum/action.c ****                         }
 350:quantum/action.c ****                     } else {
 351:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 352:quantum/action.c ****                             unregister_mods(mods);
 353:quantum/action.c ****                         }
 354:quantum/action.c ****                     }
 355:quantum/action.c ****                     break;
 356:quantum/action.c ****                 default:
 357:quantum/action.c ****                     if (event.pressed) {
 358:quantum/action.c ****                         if (tap_count > 0) {
 359:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 360:quantum/action.c ****                             if (
 361:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 362:quantum/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 363:quantum/action.c **** #        endif
 364:quantum/action.c ****                                 record->tap.interrupted) {
 365:quantum/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 366:quantum/action.c ****                                 // ad hoc: set 0 to cancel tap
 367:quantum/action.c ****                                 record->tap.count = 0;
 368:quantum/action.c ****                                 register_mods(mods);
 369:quantum/action.c ****                             } else
 370:quantum/action.c **** #    endif
 371:quantum/action.c ****                             {
 372:quantum/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 373:quantum/action.c ****                                 register_code(action.key.code);
 374:quantum/action.c ****                             }
 375:quantum/action.c ****                         } else {
 376:quantum/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 377:quantum/action.c ****                             register_mods(mods);
 378:quantum/action.c ****                         }
 379:quantum/action.c ****                     } else {
 380:quantum/action.c ****                         if (tap_count > 0) {
 381:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 382:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 383:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 384:quantum/action.c ****                             } else {
 385:quantum/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 386:quantum/action.c ****                             }
 387:quantum/action.c ****                             unregister_code(action.key.code);
 388:quantum/action.c ****                         } else {
 389:quantum/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 390:quantum/action.c ****                             unregister_mods(mods);
 391:quantum/action.c ****                         }
 392:quantum/action.c ****                     }
 393:quantum/action.c ****                     break;
 394:quantum/action.c ****             }
 395:quantum/action.c ****         } break;
 396:quantum/action.c **** #endif
 397:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 398:quantum/action.c ****         /* other HID usage */
 399:quantum/action.c ****         case ACT_USAGE:
 400:quantum/action.c ****             switch (action.usage.page) {
 401:quantum/action.c ****                 case PAGE_SYSTEM:
 402:quantum/action.c ****                     if (event.pressed) {
 403:quantum/action.c ****                         host_system_send(action.usage.code);
 404:quantum/action.c ****                     } else {
 405:quantum/action.c ****                         host_system_send(0);
 406:quantum/action.c ****                     }
 407:quantum/action.c ****                     break;
 408:quantum/action.c ****                 case PAGE_CONSUMER:
 409:quantum/action.c ****                     if (event.pressed) {
 410:quantum/action.c ****                         host_consumer_send(action.usage.code);
 411:quantum/action.c ****                     } else {
 412:quantum/action.c ****                         host_consumer_send(0);
 413:quantum/action.c ****                     }
 414:quantum/action.c ****                     break;
 415:quantum/action.c ****             }
 416:quantum/action.c ****             break;
 417:quantum/action.c **** #endif
 418:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 419:quantum/action.c ****         /* Mouse key */
 420:quantum/action.c ****         case ACT_MOUSEKEY:
 421:quantum/action.c ****             if (event.pressed) {
 422:quantum/action.c ****                 mousekey_on(action.key.code);
 423:quantum/action.c ****             } else {
 424:quantum/action.c ****                 mousekey_off(action.key.code);
 425:quantum/action.c ****             }
 426:quantum/action.c ****             switch (action.key.code) {
 427:quantum/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 428:quantum/action.c **** #        ifdef POINTING_DEVICE_ENABLE
 429:quantum/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN8:
 430:quantum/action.c **** #        else
 431:quantum/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN3:
 432:quantum/action.c **** #        endif
 433:quantum/action.c ****                     register_button(event.pressed, MOUSE_BTN_MASK(action.key.code - KC_MS_BTN1));
 434:quantum/action.c ****                     break;
 435:quantum/action.c **** #    endif
 436:quantum/action.c ****                 default:
 437:quantum/action.c ****                     mousekey_send();
 438:quantum/action.c ****                     break;
 439:quantum/action.c ****             }
 440:quantum/action.c ****             break;
 441:quantum/action.c **** #endif
 442:quantum/action.c **** #ifndef NO_ACTION_LAYER
 443:quantum/action.c ****         case ACT_LAYER:
 444:quantum/action.c ****             if (action.layer_bitop.on == 0) {
 445:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 446:quantum/action.c ****                 if (!event.pressed) {
 447:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 448:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 449:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 450:quantum/action.c ****                     switch (action.layer_bitop.op) {
 451:quantum/action.c ****                         case OP_BIT_AND:
 452:quantum/action.c ****                             default_layer_and(bits | mask);
 453:quantum/action.c ****                             break;
 454:quantum/action.c ****                         case OP_BIT_OR:
 455:quantum/action.c ****                             default_layer_or(bits | mask);
 456:quantum/action.c ****                             break;
 457:quantum/action.c ****                         case OP_BIT_XOR:
 458:quantum/action.c ****                             default_layer_xor(bits | mask);
 459:quantum/action.c ****                             break;
 460:quantum/action.c ****                         case OP_BIT_SET:
 461:quantum/action.c ****                             default_layer_set(bits | mask);
 462:quantum/action.c ****                             break;
 463:quantum/action.c ****                     }
 464:quantum/action.c ****                 }
 465:quantum/action.c ****             } else {
 466:quantum/action.c ****                 /* Layer Bitwise Operation */
 467:quantum/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 468:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 469:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 470:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 471:quantum/action.c ****                     switch (action.layer_bitop.op) {
 472:quantum/action.c ****                         case OP_BIT_AND:
 473:quantum/action.c ****                             layer_and(bits | mask);
 474:quantum/action.c ****                             break;
 475:quantum/action.c ****                         case OP_BIT_OR:
 476:quantum/action.c ****                             layer_or(bits | mask);
 477:quantum/action.c ****                             break;
 478:quantum/action.c ****                         case OP_BIT_XOR:
 479:quantum/action.c ****                             layer_xor(bits | mask);
 480:quantum/action.c ****                             break;
 481:quantum/action.c ****                         case OP_BIT_SET:
 482:quantum/action.c ****                             layer_state_set(bits | mask);
 483:quantum/action.c ****                             break;
 484:quantum/action.c ****                     }
 485:quantum/action.c ****                 }
 486:quantum/action.c ****             }
 487:quantum/action.c ****             break;
 488:quantum/action.c ****         case ACT_LAYER_MODS:
 489:quantum/action.c ****             if (event.pressed) {
 490:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 491:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 492:quantum/action.c ****             } else {
 493:quantum/action.c ****                 unregister_mods(action.layer_mods.mods);
 494:quantum/action.c ****                 layer_off(action.layer_mods.layer);
 495:quantum/action.c ****             }
 496:quantum/action.c ****             break;
 497:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 498:quantum/action.c ****         case ACT_LAYER_TAP:
 499:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
 500:quantum/action.c ****             switch (action.layer_tap.code) {
 501:quantum/action.c ****                 case OP_TAP_TOGGLE:
 502:quantum/action.c ****                     /* tap toggle */
 503:quantum/action.c ****                     if (event.pressed) {
 504:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 505:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 506:quantum/action.c ****                         }
 507:quantum/action.c ****                     } else {
 508:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 509:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 510:quantum/action.c ****                         }
 511:quantum/action.c ****                     }
 512:quantum/action.c ****                     break;
 513:quantum/action.c ****                 case OP_ON_OFF:
 514:quantum/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 515:quantum/action.c ****                     break;
 516:quantum/action.c ****                 case OP_OFF_ON:
 517:quantum/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 518:quantum/action.c ****                     break;
 519:quantum/action.c ****                 case OP_SET_CLEAR:
 520:quantum/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 521:quantum/action.c ****                     break;
 522:quantum/action.c **** #        ifndef NO_ACTION_ONESHOT
 523:quantum/action.c ****                 case OP_ONESHOT:
 524:quantum/action.c ****                     // Oneshot modifier
 525:quantum/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 526:quantum/action.c ****                     do_release_oneshot = false;
 527:quantum/action.c ****                     if (event.pressed) {
 528:quantum/action.c ****                         del_mods(get_oneshot_locked_mods());
 529:quantum/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 530:quantum/action.c ****                             reset_oneshot_layer();
 531:quantum/action.c ****                             layer_off(action.layer_tap.val);
 532:quantum/action.c ****                             break;
 533:quantum/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 534:quantum/action.c ****                             layer_on(action.layer_tap.val);
 535:quantum/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 536:quantum/action.c ****                         }
 537:quantum/action.c ****                     } else {
 538:quantum/action.c ****                         add_mods(get_oneshot_locked_mods());
 539:quantum/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 540:quantum/action.c ****                             reset_oneshot_layer();
 541:quantum/action.c ****                             clear_oneshot_locked_mods();
 542:quantum/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 543:quantum/action.c ****                         } else {
 544:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 545:quantum/action.c ****                         }
 546:quantum/action.c ****                     }
 547:quantum/action.c **** #            else
 548:quantum/action.c ****                     if (event.pressed) {
 549:quantum/action.c ****                         layer_on(action.layer_tap.val);
 550:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 551:quantum/action.c ****                     } else {
 552:quantum/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 553:quantum/action.c ****                         if (tap_count > 1) {
 554:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 555:quantum/action.c ****                         }
 556:quantum/action.c ****                     }
 557:quantum/action.c **** #            endif
 558:quantum/action.c ****                     break;
 559:quantum/action.c **** #        endif
 560:quantum/action.c ****                 default:
 561:quantum/action.c ****                     /* tap key */
 562:quantum/action.c ****                     if (event.pressed) {
 563:quantum/action.c ****                         if (tap_count > 0) {
 564:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 565:quantum/action.c ****                             register_code(action.layer_tap.code);
 566:quantum/action.c ****                         } else {
 567:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 568:quantum/action.c ****                             layer_on(action.layer_tap.val);
 569:quantum/action.c ****                         }
 570:quantum/action.c ****                     } else {
 571:quantum/action.c ****                         if (tap_count > 0) {
 572:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 573:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 574:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 575:quantum/action.c ****                             } else {
 576:quantum/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 577:quantum/action.c ****                             }
 578:quantum/action.c ****                             unregister_code(action.layer_tap.code);
 579:quantum/action.c ****                         } else {
 580:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 581:quantum/action.c ****                             layer_off(action.layer_tap.val);
 582:quantum/action.c ****                         }
 583:quantum/action.c ****                     }
 584:quantum/action.c ****                     break;
 585:quantum/action.c ****             }
 586:quantum/action.c ****             break;
 587:quantum/action.c **** #    endif
 588:quantum/action.c **** #endif
 589:quantum/action.c ****             /* Extentions */
 590:quantum/action.c **** #ifndef NO_ACTION_MACRO
 591:quantum/action.c ****         case ACT_MACRO:
 592:quantum/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 593:quantum/action.c ****             break;
 594:quantum/action.c **** #endif
 595:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 596:quantum/action.c ****         case ACT_SWAP_HANDS:
 597:quantum/action.c ****             switch (action.swap.code) {
 598:quantum/action.c ****                 case OP_SH_TOGGLE:
 599:quantum/action.c ****                     if (event.pressed) {
 600:quantum/action.c ****                         swap_hands = !swap_hands;
 601:quantum/action.c ****                     }
 602:quantum/action.c ****                     break;
 603:quantum/action.c ****                 case OP_SH_ON_OFF:
 604:quantum/action.c ****                     swap_hands = event.pressed;
 605:quantum/action.c ****                     break;
 606:quantum/action.c ****                 case OP_SH_OFF_ON:
 607:quantum/action.c ****                     swap_hands = !event.pressed;
 608:quantum/action.c ****                     break;
 609:quantum/action.c ****                 case OP_SH_ON:
 610:quantum/action.c ****                     if (!event.pressed) {
 611:quantum/action.c ****                         swap_hands = true;
 612:quantum/action.c ****                     }
 613:quantum/action.c ****                     break;
 614:quantum/action.c ****                 case OP_SH_OFF:
 615:quantum/action.c ****                     if (!event.pressed) {
 616:quantum/action.c ****                         swap_hands = false;
 617:quantum/action.c ****                     }
 618:quantum/action.c ****                     break;
 619:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 620:quantum/action.c ****                 case OP_SH_ONESHOT:
 621:quantum/action.c ****                     if (event.pressed) {
 622:quantum/action.c ****                         set_oneshot_swaphands();
 623:quantum/action.c ****                     } else {
 624:quantum/action.c ****                         release_oneshot_swaphands();
 625:quantum/action.c ****                     }
 626:quantum/action.c ****                     break;
 627:quantum/action.c **** #    endif
 628:quantum/action.c **** 
 629:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 630:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
 631:quantum/action.c ****                     /* tap toggle */
 632:quantum/action.c **** 
 633:quantum/action.c ****                     if (event.pressed) {
 634:quantum/action.c ****                         if (swap_held) {
 635:quantum/action.c ****                             swap_held = false;
 636:quantum/action.c ****                         } else {
 637:quantum/action.c ****                             swap_hands = !swap_hands;
 638:quantum/action.c ****                         }
 639:quantum/action.c ****                     } else {
 640:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 641:quantum/action.c ****                             swap_hands = !swap_hands;
 642:quantum/action.c ****                         }
 643:quantum/action.c ****                     }
 644:quantum/action.c ****                     break;
 645:quantum/action.c ****                 default:
 646:quantum/action.c ****                     /* tap key */
 647:quantum/action.c ****                     if (tap_count > 0) {
 648:quantum/action.c ****                         if (swap_held) {
 649:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 650:quantum/action.c ****                             swap_held  = false;
 651:quantum/action.c ****                         }
 652:quantum/action.c ****                         if (event.pressed) {
 653:quantum/action.c ****                             register_code(action.swap.code);
 654:quantum/action.c ****                         } else {
 655:quantum/action.c ****                             wait_ms(TAP_CODE_DELAY);
 656:quantum/action.c ****                             unregister_code(action.swap.code);
 657:quantum/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 658:quantum/action.c ****                         }
 659:quantum/action.c ****                     } else {
 660:quantum/action.c ****                         if (swap_held && !event.pressed) {
 661:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 662:quantum/action.c ****                             swap_held  = false;
 663:quantum/action.c ****                         }
 664:quantum/action.c ****                     }
 665:quantum/action.c **** #    endif
 666:quantum/action.c ****             }
 667:quantum/action.c **** #endif
 668:quantum/action.c **** #ifndef NO_ACTION_FUNCTION
 669:quantum/action.c ****         case ACT_FUNCTION:
 670:quantum/action.c ****             action_function(record, action.func.id, action.func.opt);
 671:quantum/action.c ****             break;
 672:quantum/action.c **** #endif
 673:quantum/action.c ****         default:
 674:quantum/action.c ****             break;
 675:quantum/action.c ****     }
 676:quantum/action.c **** 
 677:quantum/action.c **** #ifndef NO_ACTION_LAYER
 678:quantum/action.c ****     // if this event is a layer action, update the leds
 679:quantum/action.c ****     switch (action.kind.id) {
 680:quantum/action.c ****         case ACT_LAYER:
 681:quantum/action.c ****         case ACT_LAYER_MODS:
 682:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 683:quantum/action.c ****         case ACT_LAYER_TAP:
 684:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
 685:quantum/action.c **** #    endif
 686:quantum/action.c ****             led_set(host_keyboard_leds());
 687:quantum/action.c ****             break;
 688:quantum/action.c ****         default:
 689:quantum/action.c ****             break;
 690:quantum/action.c ****     }
 691:quantum/action.c **** #endif
 692:quantum/action.c **** 
 693:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 694:quantum/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 695:quantum/action.c ****     if (!is_tap_action(action)) {
 696:quantum/action.c ****         retro_tapping_counter = 0;
 697:quantum/action.c ****     } else {
 698:quantum/action.c ****         if (event.pressed) {
 699:quantum/action.c ****             if (tap_count > 0) {
 700:quantum/action.c ****                 retro_tapping_counter = 0;
 701:quantum/action.c ****             }
 702:quantum/action.c ****         } else {
 703:quantum/action.c ****             if (tap_count > 0) {
 704:quantum/action.c ****                 retro_tapping_counter = 0;
 705:quantum/action.c ****             } else {
 706:quantum/action.c ****                 if (
 707:quantum/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 708:quantum/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 709:quantum/action.c **** #        endif
 710:quantum/action.c ****                     retro_tapping_counter == 2) {
 711:quantum/action.c ****                     tap_code(action.layer_tap.code);
 712:quantum/action.c ****                 }
 713:quantum/action.c ****                 retro_tapping_counter = 0;
 714:quantum/action.c ****             }
 715:quantum/action.c ****         }
 716:quantum/action.c ****     }
 717:quantum/action.c **** #    endif
 718:quantum/action.c **** #endif
 719:quantum/action.c **** 
 720:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 721:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 722:quantum/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 723:quantum/action.c ****         use_oneshot_swaphands();
 724:quantum/action.c ****     }
 725:quantum/action.c **** #    endif
 726:quantum/action.c **** #endif
 727:quantum/action.c **** 
 728:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 729:quantum/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 730:quantum/action.c ****      * key before we leave the layer or no key up event will be generated.
 731:quantum/action.c ****      */
 732:quantum/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 733:quantum/action.c ****         record->event.pressed = false;
 734:quantum/action.c ****         layer_on(get_oneshot_layer());
 735:quantum/action.c ****         process_record(record);
 736:quantum/action.c ****         layer_off(get_oneshot_layer());
 737:quantum/action.c ****     }
 738:quantum/action.c **** #endif
 739:quantum/action.c **** }
 740:quantum/action.c **** 
 741:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 742:quantum/action.c ****  *
 743:quantum/action.c ****  * FIXME: Needs documentation.
 744:quantum/action.c ****  */
 745:quantum/action.c **** void register_code(uint8_t code) {
 216              		.loc 1 745 34 is_stmt 1 view -0
 217              		.cfi_startproc
 218              		@ args = 0, pretend = 0, frame = 0
 219              		@ frame_needed = 0, uses_anonymous_args = 0
 746:quantum/action.c ****     if (code == KC_NO) {
 220              		.loc 1 746 5 view .LVU35
 745:quantum/action.c ****     if (code == KC_NO) {
 221              		.loc 1 745 34 is_stmt 0 view .LVU36
 222 0000 10B5     		push	{r4, lr}
 223              		.cfi_def_cfa_offset 8
 224              		.cfi_offset 4, -8
 225              		.cfi_offset 14, -4
 226              		.loc 1 746 8 view .LVU37
 227 0002 0446     		mov	r4, r0
 228 0004 0028     		cmp	r0, #0
 229 0006 7AD0     		beq	.L15
 747:quantum/action.c ****         return;
 748:quantum/action.c ****     }
 749:quantum/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 750:quantum/action.c ****     else if (KC_LOCKING_CAPS == code) {
 230              		.loc 1 750 10 is_stmt 1 view .LVU38
 231              		.loc 1 750 13 is_stmt 0 view .LVU39
 232 0008 8228     		cmp	r0, #130
 233 000a 13D1     		bne	.L18
 751:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 752:quantum/action.c ****         // Resync: ignore if caps lock already is on
 753:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 234              		.loc 1 753 9 is_stmt 1 view .LVU40
 235              		.loc 1 753 13 is_stmt 0 view .LVU41
 236 000c FFF7FEFF 		bl	host_keyboard_leds
 237              	.LVL15:
 238              		.loc 1 753 12 view .LVU42
 239 0010 8107     		lsls	r1, r0, #30
 240 0012 74D4     		bmi	.L15
 754:quantum/action.c **** #    endif
 755:quantum/action.c ****         add_key(KC_CAPSLOCK);
 241              		.loc 1 755 9 is_stmt 1 view .LVU43
 242 0014 3920     		movs	r0, #57
 243 0016 FFF7FEFF 		bl	add_key
 244              	.LVL16:
 756:quantum/action.c ****         send_keyboard_report();
 245              		.loc 1 756 9 view .LVU44
 246 001a FFF7FEFF 		bl	send_keyboard_report
 247              	.LVL17:
 757:quantum/action.c ****         wait_ms(100);
 248              		.loc 1 757 9 view .LVU45
 249              		.loc 1 757 9 view .LVU46
 250              		.loc 1 757 9 view .LVU47
 251 001e 4FF47A70 		mov	r0, #1000
 252 0022 FFF7FEFF 		bl	chThdSleep
 253              	.LVL18:
 254              		.loc 1 757 9 view .LVU48
 758:quantum/action.c ****         del_key(KC_CAPSLOCK);
 255              		.loc 1 758 9 view .LVU49
 256 0026 3920     		movs	r0, #57
 257              	.L30:
 258              	.LBB25:
 259              	.LBB26:
 759:quantum/action.c ****         send_keyboard_report();
 760:quantum/action.c ****     }
 761:quantum/action.c **** 
 762:quantum/action.c ****     else if (KC_LOCKING_NUM == code) {
 763:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 764:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 765:quantum/action.c **** #    endif
 766:quantum/action.c ****         add_key(KC_NUMLOCK);
 767:quantum/action.c ****         send_keyboard_report();
 768:quantum/action.c ****         wait_ms(100);
 769:quantum/action.c ****         del_key(KC_NUMLOCK);
 260              		.loc 1 769 9 is_stmt 0 view .LVU50
 261 0028 FFF7FEFF 		bl	del_key
 262              	.LVL19:
 263              	.L31:
 770:quantum/action.c ****         send_keyboard_report();
 264              		.loc 1 770 9 is_stmt 1 view .LVU51
 265              	.LBE26:
 266              	.LBE25:
 771:quantum/action.c ****     }
 772:quantum/action.c **** 
 773:quantum/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 774:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 775:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 776:quantum/action.c **** #    endif
 777:quantum/action.c ****         add_key(KC_SCROLLLOCK);
 778:quantum/action.c ****         send_keyboard_report();
 779:quantum/action.c ****         wait_ms(100);
 780:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 781:quantum/action.c ****         send_keyboard_report();
 782:quantum/action.c ****     }
 783:quantum/action.c **** #endif
 784:quantum/action.c **** 
 785:quantum/action.c ****     else if IS_KEY (code) {
 786:quantum/action.c ****         // TODO: should push command_proc out of this block?
 787:quantum/action.c ****         if (command_proc(code)) return;
 788:quantum/action.c **** 
 789:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 790:quantum/action.c **** /* TODO: remove
 791:quantum/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 792:quantum/action.c ****             uint8_t tmp_mods = get_mods();
 793:quantum/action.c ****             add_mods(oneshot_state.mods);
 794:quantum/action.c **** 
 795:quantum/action.c ****             add_key(code);
 796:quantum/action.c ****             send_keyboard_report();
 797:quantum/action.c **** 
 798:quantum/action.c ****             set_mods(tmp_mods);
 799:quantum/action.c ****             send_keyboard_report();
 800:quantum/action.c ****             oneshot_cancel();
 801:quantum/action.c ****         } else
 802:quantum/action.c **** */
 803:quantum/action.c **** #endif
 804:quantum/action.c ****         {
 805:quantum/action.c ****             // Force a new key press if the key is already pressed
 806:quantum/action.c ****             // without this, keys with the same keycode, but different
 807:quantum/action.c ****             // modifiers will be reported incorrectly, see issue #1708
 808:quantum/action.c ****             if (is_key_pressed(keyboard_report, code)) {
 809:quantum/action.c ****                 del_key(code);
 810:quantum/action.c ****                 send_keyboard_report();
 811:quantum/action.c ****             }
 812:quantum/action.c ****             add_key(code);
 813:quantum/action.c ****             send_keyboard_report();
 814:quantum/action.c ****         }
 815:quantum/action.c ****     } else if IS_MOD (code) {
 816:quantum/action.c ****         add_mods(MOD_BIT(code));
 817:quantum/action.c ****         send_keyboard_report();
 818:quantum/action.c ****     }
 819:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 820:quantum/action.c ****     else if IS_SYSTEM (code) {
 821:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 822:quantum/action.c ****     } else if IS_CONSUMER (code) {
 823:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 824:quantum/action.c ****     }
 825:quantum/action.c **** #endif
 826:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 827:quantum/action.c ****     else if IS_MOUSEKEY (code) {
 828:quantum/action.c ****         mousekey_on(code);
 829:quantum/action.c ****         mousekey_send();
 830:quantum/action.c ****     }
 831:quantum/action.c **** #endif
 832:quantum/action.c **** }
 267              		.loc 1 832 1 is_stmt 0 view .LVU52
 268 002c BDE81040 		pop	{r4, lr}
 269              		.cfi_remember_state
 270              		.cfi_restore 14
 271              		.cfi_restore 4
 272              		.cfi_def_cfa_offset 0
 273              	.LBB33:
 274              	.LBB28:
 770:quantum/action.c ****         send_keyboard_report();
 275              		.loc 1 770 9 view .LVU53
 276 0030 FFF7FEBF 		b	send_keyboard_report
 277              	.LVL20:
 278              	.L18:
 279              		.cfi_restore_state
 770:quantum/action.c ****         send_keyboard_report();
 280              		.loc 1 770 9 view .LVU54
 281              	.LBE28:
 282              	.LBI25:
 745:quantum/action.c ****     if (code == KC_NO) {
 283              		.loc 1 745 6 is_stmt 1 view .LVU55
 284              	.LBB29:
 762:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 285              		.loc 1 762 10 view .LVU56
 762:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 286              		.loc 1 762 13 is_stmt 0 view .LVU57
 287 0034 8328     		cmp	r0, #131
 288 0036 0ED1     		bne	.L20
 764:quantum/action.c **** #    endif
 289              		.loc 1 764 9 is_stmt 1 view .LVU58
 764:quantum/action.c **** #    endif
 290              		.loc 1 764 13 is_stmt 0 view .LVU59
 291 0038 FFF7FEFF 		bl	host_keyboard_leds
 292              	.LVL21:
 764:quantum/action.c **** #    endif
 293              		.loc 1 764 12 view .LVU60
 294 003c C207     		lsls	r2, r0, #31
 295 003e 5ED4     		bmi	.L15
 766:quantum/action.c ****         send_keyboard_report();
 296              		.loc 1 766 9 is_stmt 1 view .LVU61
 297 0040 5320     		movs	r0, #83
 298 0042 FFF7FEFF 		bl	add_key
 299              	.LVL22:
 767:quantum/action.c ****         wait_ms(100);
 300              		.loc 1 767 9 view .LVU62
 301 0046 FFF7FEFF 		bl	send_keyboard_report
 302              	.LVL23:
 768:quantum/action.c ****         del_key(KC_NUMLOCK);
 303              		.loc 1 768 9 view .LVU63
 768:quantum/action.c ****         del_key(KC_NUMLOCK);
 304              		.loc 1 768 9 view .LVU64
 768:quantum/action.c ****         del_key(KC_NUMLOCK);
 305              		.loc 1 768 9 view .LVU65
 306 004a 4FF47A70 		mov	r0, #1000
 307 004e FFF7FEFF 		bl	chThdSleep
 308              	.LVL24:
 768:quantum/action.c ****         del_key(KC_NUMLOCK);
 309              		.loc 1 768 9 view .LVU66
 769:quantum/action.c ****         send_keyboard_report();
 310              		.loc 1 769 9 view .LVU67
 311 0052 5320     		movs	r0, #83
 312 0054 E8E7     		b	.L30
 313              	.LVL25:
 314              	.L20:
 773:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 315              		.loc 1 773 10 view .LVU68
 773:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 316              		.loc 1 773 13 is_stmt 0 view .LVU69
 317 0056 8428     		cmp	r0, #132
 318 0058 0ED1     		bne	.L21
 775:quantum/action.c **** #    endif
 319              		.loc 1 775 9 is_stmt 1 view .LVU70
 775:quantum/action.c **** #    endif
 320              		.loc 1 775 13 is_stmt 0 view .LVU71
 321 005a FFF7FEFF 		bl	host_keyboard_leds
 322              	.LVL26:
 775:quantum/action.c **** #    endif
 323              		.loc 1 775 12 view .LVU72
 324 005e 4307     		lsls	r3, r0, #29
 325 0060 4DD4     		bmi	.L15
 777:quantum/action.c ****         send_keyboard_report();
 326              		.loc 1 777 9 is_stmt 1 view .LVU73
 327 0062 4720     		movs	r0, #71
 328 0064 FFF7FEFF 		bl	add_key
 329              	.LVL27:
 778:quantum/action.c ****         wait_ms(100);
 330              		.loc 1 778 9 view .LVU74
 331 0068 FFF7FEFF 		bl	send_keyboard_report
 332              	.LVL28:
 779:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 333              		.loc 1 779 9 view .LVU75
 779:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 334              		.loc 1 779 9 view .LVU76
 779:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 335              		.loc 1 779 9 view .LVU77
 336 006c 4FF47A70 		mov	r0, #1000
 337 0070 FFF7FEFF 		bl	chThdSleep
 338              	.LVL29:
 779:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 339              		.loc 1 779 9 view .LVU78
 780:quantum/action.c ****         send_keyboard_report();
 340              		.loc 1 780 9 view .LVU79
 341 0074 4720     		movs	r0, #71
 342 0076 D7E7     		b	.L30
 343              	.LVL30:
 344              	.L21:
 785:quantum/action.c ****         // TODO: should push command_proc out of this block?
 345              		.loc 1 785 10 view .LVU80
 785:quantum/action.c ****         // TODO: should push command_proc out of this block?
 346              		.loc 1 785 13 is_stmt 0 view .LVU81
 347 0078 031F     		subs	r3, r0, #4
 348 007a DBB2     		uxtb	r3, r3
 349 007c A02B     		cmp	r3, #160
 350 007e 12D8     		bhi	.L22
 787:quantum/action.c **** 
 351              		.loc 1 787 9 is_stmt 1 view .LVU82
 787:quantum/action.c **** 
 352              		.loc 1 787 13 is_stmt 0 view .LVU83
 353 0080 FFF7FEFF 		bl	command_proc
 354              	.LVL31:
 787:quantum/action.c **** 
 355              		.loc 1 787 12 view .LVU84
 356 0084 0028     		cmp	r0, #0
 357 0086 3AD1     		bne	.L15
 808:quantum/action.c ****                 del_key(code);
 358              		.loc 1 808 13 is_stmt 1 view .LVU85
 808:quantum/action.c ****                 del_key(code);
 359              		.loc 1 808 17 is_stmt 0 view .LVU86
 360 0088 1D4B     		ldr	r3, .L32
 361 008a 2146     		mov	r1, r4
 362 008c 1868     		ldr	r0, [r3]
 363 008e FFF7FEFF 		bl	is_key_pressed
 364              	.LVL32:
 808:quantum/action.c ****                 del_key(code);
 365              		.loc 1 808 16 view .LVU87
 366 0092 20B1     		cbz	r0, .L23
 809:quantum/action.c ****                 send_keyboard_report();
 367              		.loc 1 809 17 is_stmt 1 view .LVU88
 368 0094 2046     		mov	r0, r4
 369 0096 FFF7FEFF 		bl	del_key
 370              	.LVL33:
 810:quantum/action.c ****             }
 371              		.loc 1 810 17 view .LVU89
 372 009a FFF7FEFF 		bl	send_keyboard_report
 373              	.LVL34:
 374              	.L23:
 812:quantum/action.c ****             send_keyboard_report();
 375              		.loc 1 812 13 view .LVU90
 376 009e 2046     		mov	r0, r4
 377 00a0 FFF7FEFF 		bl	add_key
 378              	.LVL35:
 813:quantum/action.c ****         }
 379              		.loc 1 813 13 view .LVU91
 380 00a4 C2E7     		b	.L31
 381              	.LVL36:
 382              	.L22:
 815:quantum/action.c ****         add_mods(MOD_BIT(code));
 383              		.loc 1 815 12 view .LVU92
 815:quantum/action.c ****         add_mods(MOD_BIT(code));
 384              		.loc 1 815 15 is_stmt 0 view .LVU93
 385 00a6 00F12003 		add	r3, r0, #32
 386 00aa DBB2     		uxtb	r3, r3
 387 00ac 072B     		cmp	r3, #7
 388 00ae 07D8     		bhi	.L24
 816:quantum/action.c ****         send_keyboard_report();
 389              		.loc 1 816 9 is_stmt 1 view .LVU94
 816:quantum/action.c ****         send_keyboard_report();
 390              		.loc 1 816 18 is_stmt 0 view .LVU95
 391 00b0 00F00704 		and	r4, r0, #7
 392 00b4 0120     		movs	r0, #1
 393              	.LVL37:
 816:quantum/action.c ****         send_keyboard_report();
 394              		.loc 1 816 18 view .LVU96
 395 00b6 A040     		lsls	r0, r0, r4
 816:quantum/action.c ****         send_keyboard_report();
 396              		.loc 1 816 9 view .LVU97
 397 00b8 C0B2     		uxtb	r0, r0
 398 00ba FFF7FEFF 		bl	add_mods
 399              	.LVL38:
 817:quantum/action.c ****     }
 400              		.loc 1 817 9 is_stmt 1 view .LVU98
 401 00be B5E7     		b	.L31
 402              	.LVL39:
 403              	.L24:
 820:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 404              		.loc 1 820 10 view .LVU99
 820:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 405              		.loc 1 820 13 is_stmt 0 view .LVU100
 406 00c0 00F15B03 		add	r3, r0, #91
 407 00c4 DBB2     		uxtb	r3, r3
 408 00c6 022B     		cmp	r3, #2
 409 00c8 05D8     		bhi	.L25
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 410              		.loc 1 821 9 is_stmt 1 view .LVU101
 411 00ca 2438     		subs	r0, r0, #36
 412              	.LVL40:
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 413              		.loc 1 821 9 is_stmt 0 view .LVU102
 414              	.LBE29:
 415              	.LBE33:
 416              		.loc 1 832 1 view .LVU103
 417 00cc BDE81040 		pop	{r4, lr}
 418              		.cfi_remember_state
 419              		.cfi_restore 14
 420              		.cfi_restore 4
 421              		.cfi_def_cfa_offset 0
 422              	.LVL41:
 423              	.LBB34:
 424              	.LBB30:
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 425              		.loc 1 821 9 view .LVU104
 426 00d0 80B2     		uxth	r0, r0
 427              	.LVL42:
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 428              		.loc 1 821 9 view .LVU105
 429 00d2 FFF7FEBF 		b	host_system_send
 430              	.LVL43:
 431              	.L25:
 432              		.cfi_restore_state
 822:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 433              		.loc 1 822 12 is_stmt 1 view .LVU106
 822:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 434              		.loc 1 822 15 is_stmt 0 view .LVU107
 435 00d6 00F15803 		add	r3, r0, #88
 436 00da DBB2     		uxtb	r3, r3
 437 00dc 162B     		cmp	r3, #22
 438 00de 06D8     		bhi	.L26
 823:quantum/action.c ****     }
 439              		.loc 1 823 9 is_stmt 1 view .LVU108
 440              	.LVL44:
 441              	.LBB27:
 442              	.LBI27:
 443              		.file 3 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK,
  34:tmk_core/common/report.h ****     REPORT_ID_DIGITIZER
  35:tmk_core/common/report.h **** };
  36:tmk_core/common/report.h **** 
  37:tmk_core/common/report.h **** /* Mouse buttons */
  38:tmk_core/common/report.h **** #define MOUSE_BTN_MASK(n) (1 << (n))
  39:tmk_core/common/report.h **** enum mouse_buttons {
  40:tmk_core/common/report.h ****     MOUSE_BTN1 = MOUSE_BTN_MASK(0),
  41:tmk_core/common/report.h ****     MOUSE_BTN2 = MOUSE_BTN_MASK(1),
  42:tmk_core/common/report.h ****     MOUSE_BTN3 = MOUSE_BTN_MASK(2),
  43:tmk_core/common/report.h ****     MOUSE_BTN4 = MOUSE_BTN_MASK(3),
  44:tmk_core/common/report.h ****     MOUSE_BTN5 = MOUSE_BTN_MASK(4),
  45:tmk_core/common/report.h ****     MOUSE_BTN6 = MOUSE_BTN_MASK(5),
  46:tmk_core/common/report.h ****     MOUSE_BTN7 = MOUSE_BTN_MASK(6),
  47:tmk_core/common/report.h ****     MOUSE_BTN8 = MOUSE_BTN_MASK(7)
  48:tmk_core/common/report.h **** };
  49:tmk_core/common/report.h **** 
  50:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  51:tmk_core/common/report.h ****  *
  52:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  53:tmk_core/common/report.h ****  */
  54:tmk_core/common/report.h **** enum consumer_usages {
  55:tmk_core/common/report.h ****     // 15.5 Display Controls
  56:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  57:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  58:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  59:tmk_core/common/report.h ****     // 15.7 Transport Controls
  60:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  61:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  62:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  63:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  64:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  65:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  66:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  67:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  68:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  69:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  70:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  71:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  72:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  73:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  74:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  75:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  76:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  77:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  78:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  79:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  80:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  81:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  82:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  83:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  84:tmk_core/common/report.h ****     AC_NEW                 = 0x201,
  85:tmk_core/common/report.h ****     AC_OPEN                = 0x202,
  86:tmk_core/common/report.h ****     AC_CLOSE               = 0x203,
  87:tmk_core/common/report.h ****     AC_EXIT                = 0x204,
  88:tmk_core/common/report.h ****     AC_MAXIMIZE            = 0x205,
  89:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  90:tmk_core/common/report.h ****     AC_SAVE                = 0x207,
  91:tmk_core/common/report.h ****     AC_PRINT               = 0x208,
  92:tmk_core/common/report.h ****     AC_PROPERTIES          = 0x209,
  93:tmk_core/common/report.h ****     AC_UNDO                = 0x21A,
  94:tmk_core/common/report.h ****     AC_COPY                = 0x21B,
  95:tmk_core/common/report.h ****     AC_CUT                 = 0x21C,
  96:tmk_core/common/report.h ****     AC_PASTE               = 0x21D,
  97:tmk_core/common/report.h ****     AC_SELECT_ALL          = 0x21E,
  98:tmk_core/common/report.h ****     AC_FIND                = 0x21F,
  99:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
 100:tmk_core/common/report.h ****     AC_HOME                = 0x223,
 101:tmk_core/common/report.h ****     AC_BACK                = 0x224,
 102:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
 103:tmk_core/common/report.h ****     AC_STOP                = 0x226,
 104:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
 105:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
 106:tmk_core/common/report.h **** };
 107:tmk_core/common/report.h **** 
 108:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
 109:tmk_core/common/report.h ****  *
 110:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
 111:tmk_core/common/report.h ****  */
 112:tmk_core/common/report.h **** enum desktop_usages {
 113:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
 114:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN             = 0x81,
 115:tmk_core/common/report.h ****     SYSTEM_SLEEP                  = 0x82,
 116:tmk_core/common/report.h ****     SYSTEM_WAKE_UP                = 0x83,
 117:tmk_core/common/report.h ****     SYSTEM_RESTART                = 0x8F,
 118:tmk_core/common/report.h ****     // 4.10 System Display Controls
 119:tmk_core/common/report.h ****     SYSTEM_DISPLAY_TOGGLE_INT_EXT = 0xB5
 120:tmk_core/common/report.h **** };
 121:tmk_core/common/report.h **** 
 122:tmk_core/common/report.h **** // clang-format on
 123:tmk_core/common/report.h **** 
 124:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 125:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 126:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 127:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 128:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 129:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 130:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 131:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 132:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 133:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 134:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 135:tmk_core/common/report.h **** #    else
 136:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 137:tmk_core/common/report.h **** #    endif
 138:tmk_core/common/report.h **** #endif
 139:tmk_core/common/report.h **** 
 140:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 141:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 142:tmk_core/common/report.h **** #else
 143:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 144:tmk_core/common/report.h **** #endif
 145:tmk_core/common/report.h **** 
 146:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 147:tmk_core/common/report.h **** 
 148:tmk_core/common/report.h **** #ifdef __cplusplus
 149:tmk_core/common/report.h **** extern "C" {
 150:tmk_core/common/report.h **** #endif
 151:tmk_core/common/report.h **** 
 152:tmk_core/common/report.h **** /*
 153:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 154:tmk_core/common/report.h ****  *
 155:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 156:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 157:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 158:tmk_core/common/report.h ****  *
 159:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 160:tmk_core/common/report.h ****  *
 161:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 162:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 163:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 164:tmk_core/common/report.h ****  *
 165:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 166:tmk_core/common/report.h ****  *
 167:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 168:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 169:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 170:tmk_core/common/report.h ****  *
 171:tmk_core/common/report.h ****  */
 172:tmk_core/common/report.h **** typedef union {
 173:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 174:tmk_core/common/report.h ****     struct {
 175:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 176:tmk_core/common/report.h ****         uint8_t report_id;
 177:tmk_core/common/report.h **** #endif
 178:tmk_core/common/report.h ****         uint8_t mods;
 179:tmk_core/common/report.h ****         uint8_t reserved;
 180:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 181:tmk_core/common/report.h ****     };
 182:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 183:tmk_core/common/report.h ****     struct nkro_report {
 184:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 185:tmk_core/common/report.h ****         uint8_t report_id;
 186:tmk_core/common/report.h **** #    endif
 187:tmk_core/common/report.h ****         uint8_t mods;
 188:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 189:tmk_core/common/report.h ****     } nkro;
 190:tmk_core/common/report.h **** #endif
 191:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 192:tmk_core/common/report.h **** 
 193:tmk_core/common/report.h **** typedef struct {
 194:tmk_core/common/report.h ****     uint8_t  report_id;
 195:tmk_core/common/report.h ****     uint16_t usage;
 196:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 197:tmk_core/common/report.h **** 
 198:tmk_core/common/report.h **** typedef struct {
 199:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 200:tmk_core/common/report.h ****     uint8_t report_id;
 201:tmk_core/common/report.h **** #endif
 202:tmk_core/common/report.h ****     uint8_t buttons;
 203:tmk_core/common/report.h ****     int8_t  x;
 204:tmk_core/common/report.h ****     int8_t  y;
 205:tmk_core/common/report.h ****     int8_t  v;
 206:tmk_core/common/report.h ****     int8_t  h;
 207:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 208:tmk_core/common/report.h **** 
 209:tmk_core/common/report.h **** typedef struct {
 210:tmk_core/common/report.h **** #ifdef DIGITIZER_SHARED_EP
 211:tmk_core/common/report.h ****     uint8_t report_id;
 212:tmk_core/common/report.h **** #endif
 213:tmk_core/common/report.h ****     uint8_t  tip : 1;
 214:tmk_core/common/report.h ****     uint8_t  inrange : 1;
 215:tmk_core/common/report.h ****     uint8_t  pad2 : 6;
 216:tmk_core/common/report.h ****     uint16_t x;
 217:tmk_core/common/report.h ****     uint16_t y;
 218:tmk_core/common/report.h **** } __attribute__((packed)) report_digitizer_t;
 219:tmk_core/common/report.h **** 
 220:tmk_core/common/report.h **** typedef struct {
 221:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 222:tmk_core/common/report.h **** #    if JOYSTICK_AXES_RESOLUTION > 8
 223:tmk_core/common/report.h ****     int16_t axes[JOYSTICK_AXES_COUNT];
 224:tmk_core/common/report.h **** #    else
 225:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 226:tmk_core/common/report.h **** #    endif
 227:tmk_core/common/report.h **** #endif
 228:tmk_core/common/report.h **** 
 229:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 230:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 231:tmk_core/common/report.h **** #endif
 232:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 233:tmk_core/common/report.h **** 
 234:tmk_core/common/report.h **** /* keycode to system usage */
 235:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 236:tmk_core/common/report.h ****     switch (key) {
 237:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 238:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 239:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 240:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 241:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 242:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 243:tmk_core/common/report.h ****         default:
 244:tmk_core/common/report.h ****             return 0;
 245:tmk_core/common/report.h ****     }
 246:tmk_core/common/report.h **** }
 247:tmk_core/common/report.h **** 
 248:tmk_core/common/report.h **** /* keycode to consumer usage */
 249:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 444              		.loc 3 249 24 view .LVU109
 250:tmk_core/common/report.h ****     switch (key) {
 445              		.loc 3 250 5 view .LVU110
 446              		.loc 3 250 5 is_stmt 0 view .LVU111
 447              	.LBE27:
 823:quantum/action.c ****     }
 448              		.loc 1 823 9 view .LVU112
 449 00e0 084A     		ldr	r2, .L32+4
 450              	.LBE30:
 451              	.LBE34:
 452              		.loc 1 832 1 view .LVU113
 453 00e2 BDE81040 		pop	{r4, lr}
 454              		.cfi_remember_state
 455              		.cfi_restore 14
 456              		.cfi_restore 4
 457              		.cfi_def_cfa_offset 0
 458              	.LBB35:
 459              	.LBB31:
 823:quantum/action.c ****     }
 460              		.loc 1 823 9 view .LVU114
 461 00e6 32F81300 		ldrh	r0, [r2, r3, lsl #1]
 462              	.LVL45:
 823:quantum/action.c ****     }
 463              		.loc 1 823 9 view .LVU115
 464 00ea FFF7FEBF 		b	host_consumer_send
 465              	.LVL46:
 466              	.L26:
 467              		.cfi_restore_state
 827:quantum/action.c ****         mousekey_on(code);
 468              		.loc 1 827 10 is_stmt 1 view .LVU116
 827:quantum/action.c ****         mousekey_on(code);
 469              		.loc 1 827 13 is_stmt 0 view .LVU117
 470 00ee EC28     		cmp	r0, #236
 471 00f0 05D9     		bls	.L15
 828:quantum/action.c ****         mousekey_send();
 472              		.loc 1 828 9 is_stmt 1 view .LVU118
 473 00f2 FFF7FEFF 		bl	mousekey_on
 474              	.LVL47:
 829:quantum/action.c ****     }
 475              		.loc 1 829 9 view .LVU119
 476              	.LBE31:
 477              	.LBE35:
 478              		.loc 1 832 1 is_stmt 0 view .LVU120
 479 00f6 BDE81040 		pop	{r4, lr}
 480              		.cfi_remember_state
 481              		.cfi_restore 14
 482              		.cfi_restore 4
 483              		.cfi_def_cfa_offset 0
 484              	.LVL48:
 485              	.LBB36:
 486              	.LBB32:
 829:quantum/action.c ****     }
 487              		.loc 1 829 9 view .LVU121
 488 00fa FFF7FEBF 		b	mousekey_send
 489              	.LVL49:
 490              	.L15:
 491              		.cfi_restore_state
 829:quantum/action.c ****     }
 492              		.loc 1 829 9 view .LVU122
 493              	.LBE32:
 494              	.LBE36:
 495              		.loc 1 832 1 view .LVU123
 496 00fe 10BD     		pop	{r4, pc}
 497              	.L33:
 498              		.align	2
 499              	.L32:
 500 0100 00000000 		.word	keyboard_report
 501 0104 00000000 		.word	.LANCHOR0
 502              		.cfi_endproc
 503              	.LFE346:
 505              		.section	.text.unregister_code,"ax",%progbits
 506              		.align	1
 507              		.global	unregister_code
 508              		.syntax unified
 509              		.thumb
 510              		.thumb_func
 511              		.fpu fpv4-sp-d16
 513              	unregister_code:
 514              	.LVL50:
 515              	.LFB347:
 833:quantum/action.c **** 
 834:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 835:quantum/action.c ****  *
 836:quantum/action.c ****  * FIXME: Needs documentation.
 837:quantum/action.c ****  */
 838:quantum/action.c **** void unregister_code(uint8_t code) {
 516              		.loc 1 838 36 is_stmt 1 view -0
 517              		.cfi_startproc
 518              		@ args = 0, pretend = 0, frame = 0
 519              		@ frame_needed = 0, uses_anonymous_args = 0
 839:quantum/action.c ****     if (code == KC_NO) {
 520              		.loc 1 839 5 view .LVU125
 838:quantum/action.c ****     if (code == KC_NO) {
 521              		.loc 1 838 36 is_stmt 0 view .LVU126
 522 0000 08B5     		push	{r3, lr}
 523              		.cfi_def_cfa_offset 8
 524              		.cfi_offset 3, -8
 525              		.cfi_offset 14, -4
 526              		.loc 1 839 8 view .LVU127
 527 0002 0028     		cmp	r0, #0
 528 0004 58D0     		beq	.L34
 840:quantum/action.c ****         return;
 841:quantum/action.c ****     }
 842:quantum/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 843:quantum/action.c ****     else if (KC_LOCKING_CAPS == code) {
 529              		.loc 1 843 10 is_stmt 1 view .LVU128
 530              		.loc 1 843 13 is_stmt 0 view .LVU129
 531 0006 8228     		cmp	r0, #130
 532 0008 0FD1     		bne	.L37
 844:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 845:quantum/action.c ****         // Resync: ignore if caps lock already is off
 846:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 533              		.loc 1 846 9 is_stmt 1 view .LVU130
 534              		.loc 1 846 15 is_stmt 0 view .LVU131
 535 000a FFF7FEFF 		bl	host_keyboard_leds
 536              	.LVL51:
 537              		.loc 1 846 12 view .LVU132
 538 000e 8107     		lsls	r1, r0, #30
 539 0010 52D5     		bpl	.L34
 847:quantum/action.c **** #    endif
 848:quantum/action.c ****         add_key(KC_CAPSLOCK);
 540              		.loc 1 848 9 is_stmt 1 view .LVU133
 541 0012 3920     		movs	r0, #57
 542 0014 FFF7FEFF 		bl	add_key
 543              	.LVL52:
 849:quantum/action.c ****         send_keyboard_report();
 544              		.loc 1 849 9 view .LVU134
 545 0018 FFF7FEFF 		bl	send_keyboard_report
 546              	.LVL53:
 850:quantum/action.c ****         del_key(KC_CAPSLOCK);
 547              		.loc 1 850 9 view .LVU135
 548 001c 3920     		movs	r0, #57
 549              	.L54:
 550              	.LBB39:
 551              	.LBB40:
 851:quantum/action.c ****         send_keyboard_report();
 852:quantum/action.c ****     }
 853:quantum/action.c **** 
 854:quantum/action.c ****     else if (KC_LOCKING_NUM == code) {
 855:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 856:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 857:quantum/action.c **** #    endif
 858:quantum/action.c ****         add_key(KC_NUMLOCK);
 859:quantum/action.c ****         send_keyboard_report();
 860:quantum/action.c ****         del_key(KC_NUMLOCK);
 552              		.loc 1 860 9 is_stmt 0 view .LVU136
 553 001e FFF7FEFF 		bl	del_key
 554              	.LVL54:
 555              	.L55:
 861:quantum/action.c ****         send_keyboard_report();
 556              		.loc 1 861 9 is_stmt 1 view .LVU137
 557              	.LBE40:
 558              	.LBE39:
 862:quantum/action.c ****     }
 863:quantum/action.c **** 
 864:quantum/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 865:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 866:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 867:quantum/action.c **** #    endif
 868:quantum/action.c ****         add_key(KC_SCROLLLOCK);
 869:quantum/action.c ****         send_keyboard_report();
 870:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 871:quantum/action.c ****         send_keyboard_report();
 872:quantum/action.c ****     }
 873:quantum/action.c **** #endif
 874:quantum/action.c **** 
 875:quantum/action.c ****     else if IS_KEY (code) {
 876:quantum/action.c ****         del_key(code);
 877:quantum/action.c ****         send_keyboard_report();
 878:quantum/action.c ****     } else if IS_MOD (code) {
 879:quantum/action.c ****         del_mods(MOD_BIT(code));
 880:quantum/action.c ****         send_keyboard_report();
 881:quantum/action.c ****     } else if IS_SYSTEM (code) {
 882:quantum/action.c ****         host_system_send(0);
 883:quantum/action.c ****     } else if IS_CONSUMER (code) {
 884:quantum/action.c ****         host_consumer_send(0);
 885:quantum/action.c ****     }
 886:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 887:quantum/action.c ****     else if IS_MOUSEKEY (code) {
 888:quantum/action.c ****         mousekey_off(code);
 889:quantum/action.c ****         mousekey_send();
 890:quantum/action.c ****     }
 891:quantum/action.c **** #endif
 892:quantum/action.c **** }
 559              		.loc 1 892 1 is_stmt 0 view .LVU138
 560 0022 BDE80840 		pop	{r3, lr}
 561              		.cfi_remember_state
 562              		.cfi_restore 14
 563              		.cfi_restore 3
 564              		.cfi_def_cfa_offset 0
 565              	.LBB46:
 566              	.LBB41:
 861:quantum/action.c ****         send_keyboard_report();
 567              		.loc 1 861 9 view .LVU139
 568 0026 FFF7FEBF 		b	send_keyboard_report
 569              	.LVL55:
 570              	.L37:
 571              		.cfi_restore_state
 861:quantum/action.c ****         send_keyboard_report();
 572              		.loc 1 861 9 view .LVU140
 573              	.LBE41:
 574              	.LBI39:
 838:quantum/action.c ****     if (code == KC_NO) {
 575              		.loc 1 838 6 is_stmt 1 view .LVU141
 576              	.LBB42:
 854:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 577              		.loc 1 854 10 view .LVU142
 854:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 578              		.loc 1 854 13 is_stmt 0 view .LVU143
 579 002a 8328     		cmp	r0, #131
 580 002c 0AD1     		bne	.L39
 856:quantum/action.c **** #    endif
 581              		.loc 1 856 9 is_stmt 1 view .LVU144
 856:quantum/action.c **** #    endif
 582              		.loc 1 856 15 is_stmt 0 view .LVU145
 583 002e FFF7FEFF 		bl	host_keyboard_leds
 584              	.LVL56:
 856:quantum/action.c **** #    endif
 585              		.loc 1 856 12 view .LVU146
 586 0032 C207     		lsls	r2, r0, #31
 587 0034 40D5     		bpl	.L34
 858:quantum/action.c ****         send_keyboard_report();
 588              		.loc 1 858 9 is_stmt 1 view .LVU147
 589 0036 5320     		movs	r0, #83
 590 0038 FFF7FEFF 		bl	add_key
 591              	.LVL57:
 859:quantum/action.c ****         del_key(KC_NUMLOCK);
 592              		.loc 1 859 9 view .LVU148
 593 003c FFF7FEFF 		bl	send_keyboard_report
 594              	.LVL58:
 860:quantum/action.c ****         send_keyboard_report();
 595              		.loc 1 860 9 view .LVU149
 596 0040 5320     		movs	r0, #83
 597 0042 ECE7     		b	.L54
 598              	.LVL59:
 599              	.L39:
 864:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 600              		.loc 1 864 10 view .LVU150
 864:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 601              		.loc 1 864 13 is_stmt 0 view .LVU151
 602 0044 8428     		cmp	r0, #132
 603 0046 0AD1     		bne	.L40
 866:quantum/action.c **** #    endif
 604              		.loc 1 866 9 is_stmt 1 view .LVU152
 866:quantum/action.c **** #    endif
 605              		.loc 1 866 15 is_stmt 0 view .LVU153
 606 0048 FFF7FEFF 		bl	host_keyboard_leds
 607              	.LVL60:
 866:quantum/action.c **** #    endif
 608              		.loc 1 866 12 view .LVU154
 609 004c 4307     		lsls	r3, r0, #29
 610 004e 33D5     		bpl	.L34
 868:quantum/action.c ****         send_keyboard_report();
 611              		.loc 1 868 9 is_stmt 1 view .LVU155
 612 0050 4720     		movs	r0, #71
 613 0052 FFF7FEFF 		bl	add_key
 614              	.LVL61:
 869:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 615              		.loc 1 869 9 view .LVU156
 616 0056 FFF7FEFF 		bl	send_keyboard_report
 617              	.LVL62:
 870:quantum/action.c ****         send_keyboard_report();
 618              		.loc 1 870 9 view .LVU157
 619 005a 4720     		movs	r0, #71
 620 005c DFE7     		b	.L54
 621              	.LVL63:
 622              	.L40:
 875:quantum/action.c ****         del_key(code);
 623              		.loc 1 875 10 view .LVU158
 875:quantum/action.c ****         del_key(code);
 624              		.loc 1 875 13 is_stmt 0 view .LVU159
 625 005e 021F     		subs	r2, r0, #4
 626 0060 D2B2     		uxtb	r2, r2
 627 0062 A02A     		cmp	r2, #160
 628 0064 DBD9     		bls	.L54
 878:quantum/action.c ****         del_mods(MOD_BIT(code));
 629              		.loc 1 878 12 is_stmt 1 view .LVU160
 878:quantum/action.c ****         del_mods(MOD_BIT(code));
 630              		.loc 1 878 15 is_stmt 0 view .LVU161
 631 0066 00F12002 		add	r2, r0, #32
 632 006a D2B2     		uxtb	r2, r2
 633 006c 072A     		cmp	r2, #7
 634 006e 07D8     		bhi	.L42
 879:quantum/action.c ****         send_keyboard_report();
 635              		.loc 1 879 9 is_stmt 1 view .LVU162
 879:quantum/action.c ****         send_keyboard_report();
 636              		.loc 1 879 18 is_stmt 0 view .LVU163
 637 0070 00F00703 		and	r3, r0, #7
 638 0074 0120     		movs	r0, #1
 639              	.LVL64:
 879:quantum/action.c ****         send_keyboard_report();
 640              		.loc 1 879 18 view .LVU164
 641 0076 9840     		lsls	r0, r0, r3
 879:quantum/action.c ****         send_keyboard_report();
 642              		.loc 1 879 9 view .LVU165
 643 0078 C0B2     		uxtb	r0, r0
 644 007a FFF7FEFF 		bl	del_mods
 645              	.LVL65:
 880:quantum/action.c ****     } else if IS_SYSTEM (code) {
 646              		.loc 1 880 9 is_stmt 1 view .LVU166
 647 007e D0E7     		b	.L55
 648              	.LVL66:
 649              	.L42:
 881:quantum/action.c ****         host_system_send(0);
 650              		.loc 1 881 12 view .LVU167
 881:quantum/action.c ****         host_system_send(0);
 651              		.loc 1 881 15 is_stmt 0 view .LVU168
 652 0080 00F15B02 		add	r2, r0, #91
 653 0084 D2B2     		uxtb	r2, r2
 654 0086 022A     		cmp	r2, #2
 655 0088 04D8     		bhi	.L43
 882:quantum/action.c ****     } else if IS_CONSUMER (code) {
 656              		.loc 1 882 9 is_stmt 1 view .LVU169
 657              	.LBE42:
 658              	.LBE46:
 659              		.loc 1 892 1 is_stmt 0 view .LVU170
 660 008a BDE80840 		pop	{r3, lr}
 661              		.cfi_remember_state
 662              		.cfi_restore 14
 663              		.cfi_restore 3
 664              		.cfi_def_cfa_offset 0
 665              	.LBB47:
 666              	.LBB43:
 882:quantum/action.c ****     } else if IS_CONSUMER (code) {
 667              		.loc 1 882 9 view .LVU171
 668 008e 0020     		movs	r0, #0
 669              	.LVL67:
 882:quantum/action.c ****     } else if IS_CONSUMER (code) {
 670              		.loc 1 882 9 view .LVU172
 671 0090 FFF7FEBF 		b	host_system_send
 672              	.LVL68:
 673              	.L43:
 674              		.cfi_restore_state
 883:quantum/action.c ****         host_consumer_send(0);
 675              		.loc 1 883 12 is_stmt 1 view .LVU173
 883:quantum/action.c ****         host_consumer_send(0);
 676              		.loc 1 883 15 is_stmt 0 view .LVU174
 677 0094 00F15802 		add	r2, r0, #88
 678 0098 D2B2     		uxtb	r2, r2
 679 009a 162A     		cmp	r2, #22
 680 009c 04D8     		bhi	.L44
 884:quantum/action.c ****     }
 681              		.loc 1 884 9 is_stmt 1 view .LVU175
 682              	.LBE43:
 683              	.LBE47:
 684              		.loc 1 892 1 is_stmt 0 view .LVU176
 685 009e BDE80840 		pop	{r3, lr}
 686              		.cfi_remember_state
 687              		.cfi_restore 14
 688              		.cfi_restore 3
 689              		.cfi_def_cfa_offset 0
 690              	.LBB48:
 691              	.LBB44:
 884:quantum/action.c ****     }
 692              		.loc 1 884 9 view .LVU177
 693 00a2 0020     		movs	r0, #0
 694              	.LVL69:
 884:quantum/action.c ****     }
 695              		.loc 1 884 9 view .LVU178
 696 00a4 FFF7FEBF 		b	host_consumer_send
 697              	.LVL70:
 698              	.L44:
 699              		.cfi_restore_state
 887:quantum/action.c ****         mousekey_off(code);
 700              		.loc 1 887 10 is_stmt 1 view .LVU179
 887:quantum/action.c ****         mousekey_off(code);
 701              		.loc 1 887 13 is_stmt 0 view .LVU180
 702 00a8 EC28     		cmp	r0, #236
 703 00aa 05D9     		bls	.L34
 888:quantum/action.c ****         mousekey_send();
 704              		.loc 1 888 9 is_stmt 1 view .LVU181
 705 00ac FFF7FEFF 		bl	mousekey_off
 706              	.LVL71:
 889:quantum/action.c ****     }
 707              		.loc 1 889 9 view .LVU182
 708              	.LBE44:
 709              	.LBE48:
 710              		.loc 1 892 1 is_stmt 0 view .LVU183
 711 00b0 BDE80840 		pop	{r3, lr}
 712              		.cfi_remember_state
 713              		.cfi_restore 14
 714              		.cfi_restore 3
 715              		.cfi_def_cfa_offset 0
 716              	.LBB49:
 717              	.LBB45:
 889:quantum/action.c ****     }
 718              		.loc 1 889 9 view .LVU184
 719 00b4 FFF7FEBF 		b	mousekey_send
 720              	.LVL72:
 721              	.L34:
 722              		.cfi_restore_state
 889:quantum/action.c ****     }
 723              		.loc 1 889 9 view .LVU185
 724              	.LBE45:
 725              	.LBE49:
 726              		.loc 1 892 1 view .LVU186
 727 00b8 08BD     		pop	{r3, pc}
 728              		.cfi_endproc
 729              	.LFE347:
 731              		.section	.text.tap_code_delay,"ax",%progbits
 732              		.align	1
 733              		.global	tap_code_delay
 734              		.syntax unified
 735              		.thumb
 736              		.thumb_func
 737              		.fpu fpv4-sp-d16
 739              	tap_code_delay:
 740              	.LVL73:
 741              	.LFB348:
 893:quantum/action.c **** 
 894:quantum/action.c **** /** \brief Tap a keycode with a delay.
 895:quantum/action.c ****  *
 896:quantum/action.c ****  * \param code The basic keycode to tap.
 897:quantum/action.c ****  * \param delay The amount of time in milliseconds to leave the keycode registered, before unregist
 898:quantum/action.c ****  */
 899:quantum/action.c **** void tap_code_delay(uint8_t code, uint16_t delay) {
 742              		.loc 1 899 51 is_stmt 1 view -0
 743              		.cfi_startproc
 744              		@ args = 0, pretend = 0, frame = 0
 745              		@ frame_needed = 0, uses_anonymous_args = 0
 900:quantum/action.c ****     register_code(code);
 746              		.loc 1 900 5 view .LVU188
 899:quantum/action.c ****     register_code(code);
 747              		.loc 1 899 51 is_stmt 0 view .LVU189
 748 0000 38B5     		push	{r3, r4, r5, lr}
 749              		.cfi_def_cfa_offset 16
 750              		.cfi_offset 3, -16
 751              		.cfi_offset 4, -12
 752              		.cfi_offset 5, -8
 753              		.cfi_offset 14, -4
 899:quantum/action.c ****     register_code(code);
 754              		.loc 1 899 51 view .LVU190
 755 0002 0546     		mov	r5, r0
 756 0004 0C46     		mov	r4, r1
 757              		.loc 1 900 5 view .LVU191
 758 0006 FFF7FEFF 		bl	register_code
 759              	.LVL74:
 901:quantum/action.c ****     for (uint16_t i = delay; i > 0; i--) {
 760              		.loc 1 901 5 is_stmt 1 view .LVU192
 761              	.LBB50:
 762              		.loc 1 901 10 view .LVU193
 763              	.L57:
 764              		.loc 1 901 32 discriminator 2 view .LVU194
 765 000a 24B9     		cbnz	r4, .L58
 766              		.loc 1 901 32 is_stmt 0 discriminator 2 view .LVU195
 767              	.LBE50:
 902:quantum/action.c ****         wait_ms(1);
 903:quantum/action.c ****     }
 904:quantum/action.c ****     unregister_code(code);
 768              		.loc 1 904 5 is_stmt 1 view .LVU196
 769 000c 2846     		mov	r0, r5
 905:quantum/action.c **** }
 770              		.loc 1 905 1 is_stmt 0 view .LVU197
 771 000e BDE83840 		pop	{r3, r4, r5, lr}
 772              		.cfi_remember_state
 773              		.cfi_restore 14
 774              		.cfi_restore 5
 775              		.cfi_restore 4
 776              		.cfi_restore 3
 777              		.cfi_def_cfa_offset 0
 778              	.LVL75:
 904:quantum/action.c **** }
 779              		.loc 1 904 5 view .LVU198
 780 0012 FFF7FEBF 		b	unregister_code
 781              	.LVL76:
 782              	.L58:
 783              		.cfi_restore_state
 784              	.LBB51:
 902:quantum/action.c ****         wait_ms(1);
 785              		.loc 1 902 9 is_stmt 1 discriminator 1 view .LVU199
 902:quantum/action.c ****         wait_ms(1);
 786              		.loc 1 902 9 discriminator 1 view .LVU200
 902:quantum/action.c ****         wait_ms(1);
 787              		.loc 1 902 9 discriminator 1 view .LVU201
 788 0016 0A20     		movs	r0, #10
 901:quantum/action.c ****         wait_ms(1);
 789              		.loc 1 901 38 is_stmt 0 discriminator 1 view .LVU202
 790 0018 013C     		subs	r4, r4, #1
 791              	.LVL77:
 902:quantum/action.c ****     }
 792              		.loc 1 902 9 discriminator 1 view .LVU203
 793 001a FFF7FEFF 		bl	chThdSleep
 794              	.LVL78:
 902:quantum/action.c ****     }
 795              		.loc 1 902 9 is_stmt 1 discriminator 1 view .LVU204
 901:quantum/action.c ****         wait_ms(1);
 796              		.loc 1 901 38 discriminator 1 view .LVU205
 797 001e A4B2     		uxth	r4, r4
 798              	.LVL79:
 901:quantum/action.c ****         wait_ms(1);
 799              		.loc 1 901 38 is_stmt 0 discriminator 1 view .LVU206
 800 0020 F3E7     		b	.L57
 801              	.LBE51:
 802              		.cfi_endproc
 803              	.LFE348:
 805              		.section	.text.tap_code,"ax",%progbits
 806              		.align	1
 807              		.global	tap_code
 808              		.syntax unified
 809              		.thumb
 810              		.thumb_func
 811              		.fpu fpv4-sp-d16
 813              	tap_code:
 814              	.LVL80:
 815              	.LFB349:
 906:quantum/action.c **** 
 907:quantum/action.c **** /** \brief Tap a keycode with the default delay.
 908:quantum/action.c ****  *
 909:quantum/action.c ****  * \param code The basic keycode to tap. If `code` is `KC_CAPS`, the delay will be `TAP_HOLD_CAPS_D
 910:quantum/action.c ****  */
 911:quantum/action.c **** void tap_code(uint8_t code) { tap_code_delay(code, code == KC_CAPS ? TAP_HOLD_CAPS_DELAY : TAP_CODE
 816              		.loc 1 911 29 is_stmt 1 view -0
 817              		.cfi_startproc
 818              		@ args = 0, pretend = 0, frame = 0
 819              		@ frame_needed = 0, uses_anonymous_args = 0
 820              		@ link register save eliminated.
 821              		.loc 1 911 31 view .LVU208
 822 0000 3928     		cmp	r0, #57
 823 0002 0CBF     		ite	eq
 824 0004 5021     		moveq	r1, #80
 825 0006 0021     		movne	r1, #0
 826 0008 FFF7FEBF 		b	tap_code_delay
 827              	.LVL81:
 828              		.loc 1 911 31 is_stmt 0 view .LVU209
 829              		.cfi_endproc
 830              	.LFE349:
 832              		.section	.text.register_mods,"ax",%progbits
 833              		.align	1
 834              		.global	register_mods
 835              		.syntax unified
 836              		.thumb
 837              		.thumb_func
 838              		.fpu fpv4-sp-d16
 840              	register_mods:
 841              	.LVL82:
 842              	.LFB350:
 912:quantum/action.c **** 
 913:quantum/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 914:quantum/action.c ****  *
 915:quantum/action.c ****  * \param mods A bitfield of modifiers to register.
 916:quantum/action.c ****  */
 917:quantum/action.c **** void register_mods(uint8_t mods) {
 843              		.loc 1 917 34 is_stmt 1 view -0
 844              		.cfi_startproc
 845              		@ args = 0, pretend = 0, frame = 0
 846              		@ frame_needed = 0, uses_anonymous_args = 0
 918:quantum/action.c ****     if (mods) {
 847              		.loc 1 918 5 view .LVU211
 917:quantum/action.c ****     if (mods) {
 848              		.loc 1 917 34 is_stmt 0 view .LVU212
 849 0000 08B5     		push	{r3, lr}
 850              		.cfi_def_cfa_offset 8
 851              		.cfi_offset 3, -8
 852              		.cfi_offset 14, -4
 853              		.loc 1 918 8 view .LVU213
 854 0002 28B1     		cbz	r0, .L62
 919:quantum/action.c ****         add_mods(mods);
 855              		.loc 1 919 9 is_stmt 1 view .LVU214
 856 0004 FFF7FEFF 		bl	add_mods
 857              	.LVL83:
 920:quantum/action.c ****         send_keyboard_report();
 858              		.loc 1 920 9 view .LVU215
 921:quantum/action.c ****     }
 922:quantum/action.c **** }
 859              		.loc 1 922 1 is_stmt 0 view .LVU216
 860 0008 BDE80840 		pop	{r3, lr}
 861              		.cfi_remember_state
 862              		.cfi_restore 14
 863              		.cfi_restore 3
 864              		.cfi_def_cfa_offset 0
 920:quantum/action.c ****         send_keyboard_report();
 865              		.loc 1 920 9 view .LVU217
 866 000c FFF7FEBF 		b	send_keyboard_report
 867              	.LVL84:
 868              	.L62:
 869              		.cfi_restore_state
 870              		.loc 1 922 1 view .LVU218
 871 0010 08BD     		pop	{r3, pc}
 872              		.cfi_endproc
 873              	.LFE350:
 875              		.section	.text.unregister_mods,"ax",%progbits
 876              		.align	1
 877              		.global	unregister_mods
 878              		.syntax unified
 879              		.thumb
 880              		.thumb_func
 881              		.fpu fpv4-sp-d16
 883              	unregister_mods:
 884              	.LVL85:
 885              	.LFB351:
 923:quantum/action.c **** 
 924:quantum/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 925:quantum/action.c ****  *
 926:quantum/action.c ****  * \param mods A bitfield of modifiers to unregister.
 927:quantum/action.c ****  */
 928:quantum/action.c **** void unregister_mods(uint8_t mods) {
 886              		.loc 1 928 36 is_stmt 1 view -0
 887              		.cfi_startproc
 888              		@ args = 0, pretend = 0, frame = 0
 889              		@ frame_needed = 0, uses_anonymous_args = 0
 929:quantum/action.c ****     if (mods) {
 890              		.loc 1 929 5 view .LVU220
 928:quantum/action.c ****     if (mods) {
 891              		.loc 1 928 36 is_stmt 0 view .LVU221
 892 0000 08B5     		push	{r3, lr}
 893              		.cfi_def_cfa_offset 8
 894              		.cfi_offset 3, -8
 895              		.cfi_offset 14, -4
 896              		.loc 1 929 8 view .LVU222
 897 0002 28B1     		cbz	r0, .L64
 930:quantum/action.c ****         del_mods(mods);
 898              		.loc 1 930 9 is_stmt 1 view .LVU223
 899 0004 FFF7FEFF 		bl	del_mods
 900              	.LVL86:
 931:quantum/action.c ****         send_keyboard_report();
 901              		.loc 1 931 9 view .LVU224
 932:quantum/action.c ****     }
 933:quantum/action.c **** }
 902              		.loc 1 933 1 is_stmt 0 view .LVU225
 903 0008 BDE80840 		pop	{r3, lr}
 904              		.cfi_remember_state
 905              		.cfi_restore 14
 906              		.cfi_restore 3
 907              		.cfi_def_cfa_offset 0
 931:quantum/action.c ****         send_keyboard_report();
 908              		.loc 1 931 9 view .LVU226
 909 000c FFF7FEBF 		b	send_keyboard_report
 910              	.LVL87:
 911              	.L64:
 912              		.cfi_restore_state
 913              		.loc 1 933 1 view .LVU227
 914 0010 08BD     		pop	{r3, pc}
 915              		.cfi_endproc
 916              	.LFE351:
 918              		.section	.text.process_action,"ax",%progbits
 919              		.align	1
 920              		.global	process_action
 921              		.syntax unified
 922              		.thumb
 923              		.thumb_func
 924              		.fpu fpv4-sp-d16
 926              	process_action:
 927              	.LVL88:
 928              	.LFB345:
 249:quantum/action.c ****     keyevent_t event = record->event;
 929              		.loc 1 249 59 is_stmt 1 view -0
 930              		.cfi_startproc
 931              		@ args = 0, pretend = 0, frame = 8
 932              		@ frame_needed = 0, uses_anonymous_args = 0
 250:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 933              		.loc 1 250 5 view .LVU229
 249:quantum/action.c ****     keyevent_t event = record->event;
 934              		.loc 1 249 59 is_stmt 0 view .LVU230
 935 0000 2DE9F347 		push	{r0, r1, r4, r5, r6, r7, r8, r9, r10, lr}
 936              		.cfi_def_cfa_offset 40
 937              		.cfi_offset 4, -32
 938              		.cfi_offset 5, -28
 939              		.cfi_offset 6, -24
 940              		.cfi_offset 7, -20
 941              		.cfi_offset 8, -16
 942              		.cfi_offset 9, -12
 943              		.cfi_offset 10, -8
 944              		.cfi_offset 14, -4
 945              	.LVL89:
 252:quantum/action.c **** #endif
 946              		.loc 1 252 36 view .LVU231
 947 0004 8679     		ldrb	r6, [r0, #6]	@ zero_extendqisi2
 250:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 948              		.loc 1 250 16 view .LVU232
 949 0006 8578     		ldrb	r5, [r0, #2]	@ zero_extendqisi2
 950              	.LVL90:
 252:quantum/action.c **** #endif
 951              		.loc 1 252 5 is_stmt 1 view .LVU233
 249:quantum/action.c ****     keyevent_t event = record->event;
 952              		.loc 1 249 59 is_stmt 0 view .LVU234
 953 0008 8046     		mov	r8, r0
 954 000a 0C46     		mov	r4, r1	@ movhi
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 955              		.loc 1 258 9 view .LVU235
 956 000c FFF7FEFF 		bl	is_oneshot_layer_active
 957              	.LVL91:
 252:quantum/action.c **** #endif
 958              		.loc 1 252 13 view .LVU236
 959 0010 3609     		lsrs	r6, r6, #4
 960              	.LVL92:
 256:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 961              		.loc 1 256 5 is_stmt 1 view .LVU237
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 962              		.loc 1 258 5 view .LVU238
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 963              		.loc 1 258 8 is_stmt 0 view .LVU239
 964 0012 0746     		mov	r7, r0
 965 0014 A0B1     		cbz	r0, .L67
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 966              		.loc 1 258 43 discriminator 1 view .LVU240
 967 0016 2F46     		mov	r7, r5
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 968              		.loc 1 258 35 discriminator 1 view .LVU241
 969 0018 95B1     		cbz	r5, .L67
 970              	.LVL93:
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 971              		.loc 1 258 71 discriminator 2 view .LVU242
 972 001a C4F30723 		ubfx	r3, r4, #8, #8
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 973              		.loc 1 258 52 discriminator 2 view .LVU243
 974 001e 03F0F003 		and	r3, r3, #240
 975 0022 402B     		cmp	r3, #64
 976 0024 04D0     		beq	.L68
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 977              		.loc 1 258 87 discriminator 3 view .LVU244
 978 0026 04F12003 		add	r3, r4, #32
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 979              		.loc 1 258 84 discriminator 3 view .LVU245
 980 002a DBB2     		uxtb	r3, r3
 981 002c 072B     		cmp	r3, #7
 982 002e 1ED9     		bls	.L146
 983              	.L68:
 263:quantum/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 984              		.loc 1 263 9 is_stmt 1 view .LVU246
 985 0030 0220     		movs	r0, #2
 986 0032 FFF7FEFF 		bl	clear_oneshot_layer_state
 987              	.LVL94:
 264:quantum/action.c ****     }
 988              		.loc 1 264 9 view .LVU247
 264:quantum/action.c ****     }
 989              		.loc 1 264 31 is_stmt 0 view .LVU248
 990 0036 FFF7FEFF 		bl	is_oneshot_layer_active
 991              	.LVL95:
 264:quantum/action.c ****     }
 992              		.loc 1 264 9 view .LVU249
 993 003a 80F00100 		eor	r0, r0, #1
 994 003e C7B2     		uxtb	r7, r0
 995              	.LVL96:
 996              	.L67:
 268:quantum/action.c ****         /* Key and Mods */
 997              		.loc 1 268 5 is_stmt 1 view .LVU250
 268:quantum/action.c ****         /* Key and Mods */
 998              		.loc 1 268 24 is_stmt 0 view .LVU251
 999 0040 C4F30339 		ubfx	r9, r4, #12, #4
 268:quantum/action.c ****         /* Key and Mods */
 1000              		.loc 1 268 5 view .LVU252
 1001 0044 B9F10F0F 		cmp	r9, #15
 1002 0048 3FD8     		bhi	.L69
 1003 004a DFE819F0 		tbh	[pc, r9, lsl #1]
 1004              	.L71:
 1005 004e 1200     		.2byte	(.L79-.L71)/2
 1006 0050 1200     		.2byte	(.L79-.L71)/2
 1007 0052 6300     		.2byte	(.L78-.L71)/2
 1008 0054 6300     		.2byte	(.L78-.L71)/2
 1009 0056 AF00     		.2byte	(.L77-.L71)/2
 1010 0058 C600     		.2byte	(.L76-.L71)/2
 1011 005a 3E00     		.2byte	(.L69-.L71)/2
 1012 005c 3E00     		.2byte	(.L69-.L71)/2
 1013 005e D000     		.2byte	(.L75-.L71)/2
 1014 0060 2C01     		.2byte	(.L74-.L71)/2
 1015 0062 3C01     		.2byte	(.L73-.L71)/2
 1016 0064 3C01     		.2byte	(.L73-.L71)/2
 1017 0066 9101     		.2byte	(.L72-.L71)/2
 1018 0068 3E00     		.2byte	(.L69-.L71)/2
 1019 006a 3E00     		.2byte	(.L69-.L71)/2
 1020 006c 9A01     		.2byte	(.L70-.L71)/2
 1021              	.LVL97:
 1022              		.p2align 1
 1023              	.L146:
 256:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 1024              		.loc 1 256 10 view .LVU253
 1025 006e 0027     		movs	r7, #0
 1026 0070 E6E7     		b	.L67
 1027              	.LVL98:
 1028              	.L79:
 1029              	.LBB52:
 272:quantum/action.c ****             if (event.pressed) {
 1030              		.loc 1 272 13 is_stmt 1 view .LVU254
 272:quantum/action.c ****             if (event.pressed) {
 1031              		.loc 1 272 44 is_stmt 0 view .LVU255
 1032 0072 C4F30723 		ubfx	r3, r4, #8, #8
 272:quantum/action.c ****             if (event.pressed) {
 1033              		.loc 1 272 21 view .LVU256
 1034 0076 C4F30326 		ubfx	r6, r4, #8, #4
 1035 007a 13F0F00F 		tst	r3, #240
 1036 007e 18BF     		it	ne
 1037 0080 3601     		lslne	r6, r6, #4
 1038              	.LVL99:
 273:quantum/action.c ****                 if (mods) {
 1039              		.loc 1 273 13 is_stmt 1 view .LVU257
 1040              	.LBE52:
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1041              		.loc 1 258 88 is_stmt 0 view .LVU258
 1042 0082 E4B2     		uxtb	r4, r4
 1043              	.LVL100:
 1044              	.LBB53:
 273:quantum/action.c ****                 if (mods) {
 1045              		.loc 1 273 16 view .LVU259
 1046 0084 95B1     		cbz	r5, .L81
 274:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1047              		.loc 1 274 17 is_stmt 1 view .LVU260
 274:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1048              		.loc 1 274 20 is_stmt 0 view .LVU261
 1049 0086 56B1     		cbz	r6, .L102
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1050              		.loc 1 275 21 is_stmt 1 view .LVU262
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1051              		.loc 1 275 25 is_stmt 0 view .LVU263
 1052 0088 04F12003 		add	r3, r4, #32
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1053              		.loc 1 275 24 view .LVU264
 1054 008c DBB2     		uxtb	r3, r3
 1055 008e 072B     		cmp	r3, #7
 279:quantum/action.c ****                     } else {
 1056              		.loc 1 279 25 view .LVU265
 1057 0090 3046     		mov	r0, r6
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1058              		.loc 1 275 24 view .LVU266
 1059 0092 00D9     		bls	.L83
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1060              		.loc 1 275 49 discriminator 1 view .LVU267
 1061 0094 3CB9     		cbnz	r4, .L84
 1062              	.L83:
 279:quantum/action.c ****                     } else {
 1063              		.loc 1 279 25 is_stmt 1 view .LVU268
 1064 0096 FFF7FEFF 		bl	add_mods
 1065              	.LVL101:
 1066              	.L85:
 283:quantum/action.c ****                 }
 1067              		.loc 1 283 21 view .LVU269
 1068 009a FFF7FEFF 		bl	send_keyboard_report
 1069              	.LVL102:
 285:quantum/action.c ****             } else {
 1070              		.loc 1 285 17 view .LVU270
 1071              	.L102:
 285:quantum/action.c ****             } else {
 1072              		.loc 1 285 17 is_stmt 0 view .LVU271
 1073              	.LBE53:
 1074              	.LBB54:
 372:quantum/action.c ****                                 register_code(action.key.code);
 1075              		.loc 1 372 73 is_stmt 1 view .LVU272
 373:quantum/action.c ****                             }
 1076              		.loc 1 373 33 view .LVU273
 1077 009e 2046     		mov	r0, r4
 1078              	.LVL103:
 1079              	.L184:
 373:quantum/action.c ****                             }
 1080              		.loc 1 373 33 is_stmt 0 view .LVU274
 1081              	.LBE54:
 565:quantum/action.c ****                         } else {
 1082              		.loc 1 565 29 view .LVU275
 1083 00a0 FFF7FEFF 		bl	register_code
 1084              	.LVL104:
 1085 00a4 11E0     		b	.L69
 1086              	.LVL105:
 1087              	.L84:
 1088              	.LBB55:
 281:quantum/action.c ****                     }
 1089              		.loc 1 281 25 is_stmt 1 view .LVU276
 1090 00a6 FFF7FEFF 		bl	add_weak_mods
 1091              	.LVL106:
 1092 00aa F6E7     		b	.L85
 1093              	.L81:
 287:quantum/action.c ****                 if (mods) {
 1094              		.loc 1 287 17 view .LVU277
 1095 00ac 2046     		mov	r0, r4
 1096 00ae FFF7FEFF 		bl	unregister_code
 1097              	.LVL107:
 288:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1098              		.loc 1 288 17 view .LVU278
 288:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1099              		.loc 1 288 20 is_stmt 0 view .LVU279
 1100 00b2 56B1     		cbz	r6, .L69
 289:quantum/action.c ****                         del_mods(mods);
 1101              		.loc 1 289 21 is_stmt 1 view .LVU280
 289:quantum/action.c ****                         del_mods(mods);
 1102              		.loc 1 289 25 is_stmt 0 view .LVU281
 1103 00b4 04F12003 		add	r3, r4, #32
 289:quantum/action.c ****                         del_mods(mods);
 1104              		.loc 1 289 24 view .LVU282
 1105 00b8 DBB2     		uxtb	r3, r3
 1106 00ba 072B     		cmp	r3, #7
 290:quantum/action.c ****                     } else {
 1107              		.loc 1 290 25 view .LVU283
 1108 00bc 3046     		mov	r0, r6
 289:quantum/action.c ****                         del_mods(mods);
 1109              		.loc 1 289 24 view .LVU284
 1110 00be 00D9     		bls	.L87
 289:quantum/action.c ****                         del_mods(mods);
 1111              		.loc 1 289 49 discriminator 1 view .LVU285
 1112 00c0 2CBB     		cbnz	r4, .L88
 1113              	.L87:
 290:quantum/action.c ****                     } else {
 1114              		.loc 1 290 25 is_stmt 1 view .LVU286
 1115 00c2 FFF7FEFF 		bl	del_mods
 1116              	.LVL108:
 1117              	.L89:
 294:quantum/action.c ****                 }
 1118              		.loc 1 294 21 view .LVU287
 1119 00c6 FFF7FEFF 		bl	send_keyboard_report
 1120              	.LVL109:
 1121              	.L69:
 294:quantum/action.c ****                 }
 1122              		.loc 1 294 21 is_stmt 0 view .LVU288
 1123              	.LBE55:
 679:quantum/action.c ****         case ACT_LAYER:
 1124              		.loc 1 679 5 is_stmt 1 view .LVU289
 1125 00ca A9F10809 		sub	r9, r9, #8
 1126 00ce B9F1030F 		cmp	r9, #3
 1127 00d2 03D8     		bhi	.L142
 686:quantum/action.c ****             break;
 1128              		.loc 1 686 13 view .LVU290
 1129 00d4 FFF7FEFF 		bl	host_keyboard_leds
 1130              	.LVL110:
 1131 00d8 FFF7FEFF 		bl	led_set
 1132              	.LVL111:
 687:quantum/action.c ****         default:
 1133              		.loc 1 687 13 view .LVU291
 1134              	.L142:
 732:quantum/action.c ****         record->event.pressed = false;
 1135              		.loc 1 732 5 view .LVU292
 732:quantum/action.c ****         record->event.pressed = false;
 1136              		.loc 1 732 8 is_stmt 0 view .LVU293
 1137 00dc 002F     		cmp	r7, #0
 1138 00de 00F05781 		beq	.L66
 732:quantum/action.c ****         record->event.pressed = false;
 1139              		.loc 1 732 33 discriminator 1 view .LVU294
 1140 00e2 FFF7FEFF 		bl	get_oneshot_layer_state
 1141              	.LVL112:
 732:quantum/action.c ****         record->event.pressed = false;
 1142              		.loc 1 732 28 discriminator 1 view .LVU295
 1143 00e6 10F00100 		ands	r0, r0, #1
 1144 00ea 40F05181 		bne	.L66
 733:quantum/action.c ****         layer_on(get_oneshot_layer());
 1145              		.loc 1 733 9 is_stmt 1 view .LVU296
 733:quantum/action.c ****         layer_on(get_oneshot_layer());
 1146              		.loc 1 733 31 is_stmt 0 view .LVU297
 1147 00ee 88F80200 		strb	r0, [r8, #2]
 734:quantum/action.c ****         process_record(record);
 1148              		.loc 1 734 9 is_stmt 1 view .LVU298
 1149 00f2 FFF7FEFF 		bl	get_oneshot_layer
 1150              	.LVL113:
 1151 00f6 FFF7FEFF 		bl	layer_on
 1152              	.LVL114:
 735:quantum/action.c ****         layer_off(get_oneshot_layer());
 1153              		.loc 1 735 9 view .LVU299
 1154 00fa 4046     		mov	r0, r8
 1155 00fc FFF7FEFF 		bl	process_record
 1156              	.LVL115:
 736:quantum/action.c ****     }
 1157              		.loc 1 736 9 view .LVU300
 1158 0100 FFF7FEFF 		bl	get_oneshot_layer
 1159              	.LVL116:
 739:quantum/action.c **** 
 1160              		.loc 1 739 1 is_stmt 0 view .LVU301
 1161 0104 02B0     		add	sp, sp, #8
 1162              		.cfi_remember_state
 1163              		.cfi_def_cfa_offset 32
 1164              		@ sp needed
 1165 0106 BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 1166              		.cfi_restore 14
 1167              		.cfi_restore 10
 1168              		.cfi_restore 9
 1169              		.cfi_restore 8
 1170              		.cfi_restore 7
 1171              		.cfi_restore 6
 1172              		.cfi_restore 5
 1173              		.cfi_restore 4
 1174              		.cfi_def_cfa_offset 0
 1175              	.LVL117:
 736:quantum/action.c ****     }
 1176              		.loc 1 736 9 view .LVU302
 1177 010a FFF7FEBF 		b	layer_off
 1178              	.LVL118:
 1179              	.L88:
 1180              		.cfi_restore_state
 1181              	.LBB56:
 292:quantum/action.c ****                     }
 1182              		.loc 1 292 25 is_stmt 1 view .LVU303
 1183 010e FFF7FEFF 		bl	del_weak_mods
 1184              	.LVL119:
 1185 0112 D8E7     		b	.L89
 1186              	.LVL120:
 1187              	.L78:
 292:quantum/action.c ****                     }
 1188              		.loc 1 292 25 is_stmt 0 view .LVU304
 1189              	.LBE56:
 1190              	.LBB57:
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1191              		.loc 1 301 13 is_stmt 1 view .LVU305
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1192              		.loc 1 301 44 is_stmt 0 view .LVU306
 1193 0114 C4F30723 		ubfx	r3, r4, #8, #8
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1194              		.loc 1 301 21 view .LVU307
 1195 0118 03F0F003 		and	r3, r3, #240
 1196              	.LBE57:
 1197              	.LBB58:
 272:quantum/action.c ****             if (event.pressed) {
 1198              		.loc 1 272 21 view .LVU308
 1199 011c C4F3032A 		ubfx	r10, r4, #8, #4
 1200              	.LBE58:
 1201              	.LBB59:
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1202              		.loc 1 301 21 view .LVU309
 1203 0120 202B     		cmp	r3, #32
 302:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 1204              		.loc 1 302 37 view .LVU310
 1205 0122 E4B2     		uxtb	r4, r4
 1206              	.LVL121:
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1207              		.loc 1 301 21 view .LVU311
 1208 0124 18BF     		it	ne
 1209 0126 4FEA0A1A 		lslne	r10, r10, #4
 1210              	.LVL122:
 302:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 1211              		.loc 1 302 13 is_stmt 1 view .LVU312
 1212 012a 64B1     		cbz	r4, .L91
 1213 012c 012C     		cmp	r4, #1
 1214 012e 28D0     		beq	.L92
 357:quantum/action.c ****                         if (tap_count > 0) {
 1215              		.loc 1 357 21 view .LVU313
 357:quantum/action.c ****                         if (tap_count > 0) {
 1216              		.loc 1 357 24 is_stmt 0 view .LVU314
 1217 0130 7DB3     		cbz	r5, .L100
 358:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1218              		.loc 1 358 25 is_stmt 1 view .LVU315
 358:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1219              		.loc 1 358 28 is_stmt 0 view .LVU316
 1220 0132 4EB3     		cbz	r6, .L101
 360:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1221              		.loc 1 360 29 is_stmt 1 view .LVU317
 364:quantum/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1222              		.loc 1 364 33 is_stmt 0 view .LVU318
 1223 0134 98F80630 		ldrb	r3, [r8, #6]	@ zero_extendqisi2
 360:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1224              		.loc 1 360 32 view .LVU319
 1225 0138 D807     		lsls	r0, r3, #31
 1226 013a B0D5     		bpl	.L102
 365:quantum/action.c ****                                 // ad hoc: set 0 to cancel tap
 1227              		.loc 1 365 76 is_stmt 1 view .LVU320
 367:quantum/action.c ****                                 register_mods(mods);
 1228              		.loc 1 367 33 view .LVU321
 367:quantum/action.c ****                                 register_mods(mods);
 1229              		.loc 1 367 51 is_stmt 0 view .LVU322
 1230 013c 6FF30713 		bfc	r3, #4, #4
 1231 0140 88F80630 		strb	r3, [r8, #6]
 368:quantum/action.c ****                             } else
 1232              		.loc 1 368 33 is_stmt 1 view .LVU323
 1233 0144 20E0     		b	.L101
 1234              	.L91:
 306:quantum/action.c ****                         if (tap_count == 0) {
 1235              		.loc 1 306 21 view .LVU324
 306:quantum/action.c ****                         if (tap_count == 0) {
 1236              		.loc 1 306 24 is_stmt 0 view .LVU325
 1237 0146 95B1     		cbz	r5, .L94
 307:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1238              		.loc 1 307 25 is_stmt 1 view .LVU326
 307:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1239              		.loc 1 307 28 is_stmt 0 view .LVU327
 1240 0148 3EB9     		cbnz	r6, .L95
 1241              	.L96:
 321:quantum/action.c ****                         }
 1242              		.loc 1 321 29 is_stmt 1 view .LVU328
 321:quantum/action.c ****                         }
 1243              		.loc 1 321 50 is_stmt 0 view .LVU329
 1244 014a FFF7FEFF 		bl	get_oneshot_mods
 1245              	.LVL123:
 321:quantum/action.c ****                         }
 1246              		.loc 1 321 29 view .LVU330
 1247 014e 40EA0A00 		orr	r0, r0, r10
 1248 0152 C0B2     		uxtb	r0, r0
 1249              	.LVL124:
 1250              	.L182:
 321:quantum/action.c ****                         }
 1251              		.loc 1 321 29 view .LVU331
 1252              	.LBE59:
 491:quantum/action.c ****             } else {
 1253              		.loc 1 491 17 view .LVU332
 1254 0154 FFF7FEFF 		bl	register_mods
 1255              	.LVL125:
 1256 0158 B7E7     		b	.L69
 1257              	.LVL126:
 1258              	.L95:
 1259              	.LBB60:
 310:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1260              		.loc 1 310 32 is_stmt 1 view .LVU333
 310:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1261              		.loc 1 310 35 is_stmt 0 view .LVU334
 1262 015a 012E     		cmp	r6, #1
 1263 015c F5D1     		bne	.L96
 311:quantum/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1264              		.loc 1 311 65 is_stmt 1 view .LVU335
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1265              		.loc 1 312 29 view .LVU336
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1266              		.loc 1 312 53 is_stmt 0 view .LVU337
 1267 015e FFF7FEFF 		bl	get_oneshot_mods
 1268              	.LVL127:
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1269              		.loc 1 312 29 view .LVU338
 1270 0162 40EA0A00 		orr	r0, r0, r10
 1271 0166 C0B2     		uxtb	r0, r0
 1272 0168 FFF7FEFF 		bl	set_oneshot_mods
 1273              	.LVL128:
 1274 016c ADE7     		b	.L69
 1275              	.L94:
 324:quantum/action.c ****                             clear_oneshot_mods();
 1276              		.loc 1 324 25 is_stmt 1 view .LVU339
 324:quantum/action.c ****                             clear_oneshot_mods();
 1277              		.loc 1 324 28 is_stmt 0 view .LVU340
 1278 016e 2EB9     		cbnz	r6, .L97
 1279              	.L187:
 339:quantum/action.c ****                             unregister_mods(mods);
 1280              		.loc 1 339 29 is_stmt 1 view .LVU341
 1281 0170 FFF7FEFF 		bl	clear_oneshot_mods
 1282              	.LVL129:
 340:quantum/action.c ****                         }
 1283              		.loc 1 340 29 view .LVU342
 1284              	.L103:
 389:quantum/action.c ****                             unregister_mods(mods);
 1285              		.loc 1 389 67 view .LVU343
 390:quantum/action.c ****                         }
 1286              		.loc 1 390 29 view .LVU344
 1287 0174 5046     		mov	r0, r10
 1288 0176 FFF7FEFF 		bl	unregister_mods
 1289              	.LVL130:
 1290 017a A6E7     		b	.L69
 1291              	.L97:
 327:quantum/action.c ****                             // Retain Oneshot mods
 1292              		.loc 1 327 32 view .LVU345
 327:quantum/action.c ****                             // Retain Oneshot mods
 1293              		.loc 1 327 35 is_stmt 0 view .LVU346
 1294 017c 012E     		cmp	r6, #1
 1295 017e A4D0     		beq	.L69
 1296 0180 F6E7     		b	.L187
 1297              	.L92:
 346:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1298              		.loc 1 346 21 is_stmt 1 view .LVU347
 346:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1299              		.loc 1 346 24 is_stmt 0 view .LVU348
 1300 0182 1DB1     		cbz	r5, .L99
 347:quantum/action.c ****                             register_mods(mods);
 1301              		.loc 1 347 25 is_stmt 1 view .LVU349
 347:quantum/action.c ****                             register_mods(mods);
 1302              		.loc 1 347 28 is_stmt 0 view .LVU350
 1303 0184 052E     		cmp	r6, #5
 1304 0186 A0D8     		bhi	.L69
 1305              	.L101:
 376:quantum/action.c ****                             register_mods(mods);
 1306              		.loc 1 376 67 is_stmt 1 view .LVU351
 377:quantum/action.c ****                         }
 1307              		.loc 1 377 29 view .LVU352
 1308 0188 5046     		mov	r0, r10
 1309 018a E3E7     		b	.L182
 1310              	.L99:
 351:quantum/action.c ****                             unregister_mods(mods);
 1311              		.loc 1 351 25 view .LVU353
 351:quantum/action.c ****                             unregister_mods(mods);
 1312              		.loc 1 351 28 is_stmt 0 view .LVU354
 1313 018c 042E     		cmp	r6, #4
 1314 018e 9CD8     		bhi	.L69
 1315 0190 F0E7     		b	.L103
 1316              	.L100:
 380:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1317              		.loc 1 380 25 is_stmt 1 view .LVU355
 380:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1318              		.loc 1 380 28 is_stmt 0 view .LVU356
 1319 0192 002E     		cmp	r6, #0
 1320 0194 EED0     		beq	.L103
 381:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1321              		.loc 1 381 71 is_stmt 1 view .LVU357
 382:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1322              		.loc 1 382 29 view .LVU358
 382:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1323              		.loc 1 382 32 is_stmt 0 view .LVU359
 1324 0196 392C     		cmp	r4, #57
 383:quantum/action.c ****                             } else {
 1325              		.loc 1 383 33 is_stmt 1 view .LVU360
 383:quantum/action.c ****                             } else {
 1326              		.loc 1 383 33 view .LVU361
 383:quantum/action.c ****                             } else {
 1327              		.loc 1 383 33 view .LVU362
 1328 0198 0CBF     		ite	eq
 1329 019a 4FF44870 		moveq	r0, #800
 385:quantum/action.c ****                             }
 1330              		.loc 1 385 33 view .LVU363
 385:quantum/action.c ****                             }
 1331              		.loc 1 385 33 view .LVU364
 385:quantum/action.c ****                             }
 1332              		.loc 1 385 33 view .LVU365
 1333 019e 0120     		movne	r0, #1
 1334 01a0 FFF7FEFF 		bl	chThdSleep
 1335              	.LVL131:
 385:quantum/action.c ****                             }
 1336              		.loc 1 385 33 view .LVU366
 387:quantum/action.c ****                         } else {
 1337              		.loc 1 387 29 view .LVU367
 1338 01a4 2046     		mov	r0, r4
 1339              	.LVL132:
 1340              	.L183:
 387:quantum/action.c ****                         } else {
 1341              		.loc 1 387 29 is_stmt 0 view .LVU368
 1342              	.LBE60:
 578:quantum/action.c ****                         } else {
 1343              		.loc 1 578 29 discriminator 4 view .LVU369
 1344 01a6 FFF7FEFF 		bl	unregister_code
 1345              	.LVL133:
 1346 01aa 8EE7     		b	.L69
 1347              	.L77:
 400:quantum/action.c ****                 case PAGE_SYSTEM:
 1348              		.loc 1 400 13 is_stmt 1 view .LVU370
 1349 01ac 14F4406F 		tst	r4, #3072
 400:quantum/action.c ****                 case PAGE_SYSTEM:
 1350              		.loc 1 400 33 is_stmt 0 view .LVU371
 1351 01b0 C4F38123 		ubfx	r3, r4, #10, #2
 1352 01b4 07D0     		beq	.L106
 1353 01b6 012B     		cmp	r3, #1
 1354 01b8 87D1     		bne	.L69
 409:quantum/action.c ****                         host_consumer_send(action.usage.code);
 1355              		.loc 1 409 21 is_stmt 1 view .LVU372
 409:quantum/action.c ****                         host_consumer_send(action.usage.code);
 1356              		.loc 1 409 24 is_stmt 0 view .LVU373
 1357 01ba 65B1     		cbz	r5, .L109
 410:quantum/action.c ****                     } else {
 1358              		.loc 1 410 25 is_stmt 1 view .LVU374
 1359 01bc C4F30900 		ubfx	r0, r4, #0, #10
 1360              	.L186:
 412:quantum/action.c ****                     }
 1361              		.loc 1 412 25 is_stmt 0 view .LVU375
 1362 01c0 FFF7FEFF 		bl	host_consumer_send
 1363              	.LVL134:
 1364 01c4 81E7     		b	.L69
 1365              	.L106:
 402:quantum/action.c ****                         host_system_send(action.usage.code);
 1366              		.loc 1 402 21 is_stmt 1 view .LVU376
 402:quantum/action.c ****                         host_system_send(action.usage.code);
 1367              		.loc 1 402 24 is_stmt 0 view .LVU377
 1368 01c6 25B1     		cbz	r5, .L108
 403:quantum/action.c ****                     } else {
 1369              		.loc 1 403 25 is_stmt 1 view .LVU378
 1370 01c8 C4F30900 		ubfx	r0, r4, #0, #10
 1371              	.L180:
 405:quantum/action.c ****                     }
 1372              		.loc 1 405 25 is_stmt 0 view .LVU379
 1373 01cc FFF7FEFF 		bl	host_system_send
 1374              	.LVL135:
 1375 01d0 7BE7     		b	.L69
 1376              	.L108:
 405:quantum/action.c ****                     }
 1377              		.loc 1 405 25 is_stmt 1 view .LVU380
 1378 01d2 2846     		mov	r0, r5
 1379 01d4 FAE7     		b	.L180
 1380              	.L109:
 412:quantum/action.c ****                     }
 1381              		.loc 1 412 25 view .LVU381
 1382 01d6 2846     		mov	r0, r5
 1383 01d8 F2E7     		b	.L186
 1384              	.L76:
 421:quantum/action.c ****                 mousekey_on(action.key.code);
 1385              		.loc 1 421 13 view .LVU382
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1386              		.loc 1 258 88 is_stmt 0 view .LVU383
 1387 01da E0B2     		uxtb	r0, r4
 421:quantum/action.c ****                 mousekey_on(action.key.code);
 1388              		.loc 1 421 16 view .LVU384
 1389 01dc 25B1     		cbz	r5, .L110
 422:quantum/action.c ****             } else {
 1390              		.loc 1 422 17 is_stmt 1 view .LVU385
 1391 01de FFF7FEFF 		bl	mousekey_on
 1392              	.LVL136:
 1393              	.L111:
 426:quantum/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 1394              		.loc 1 426 13 view .LVU386
 437:quantum/action.c ****                     break;
 1395              		.loc 1 437 21 view .LVU387
 1396 01e2 FFF7FEFF 		bl	mousekey_send
 1397              	.LVL137:
 438:quantum/action.c ****             }
 1398              		.loc 1 438 21 view .LVU388
 1399 01e6 70E7     		b	.L69
 1400              	.L110:
 424:quantum/action.c ****             }
 1401              		.loc 1 424 17 view .LVU389
 1402 01e8 FFF7FEFF 		bl	mousekey_off
 1403              	.LVL138:
 1404 01ec F9E7     		b	.L111
 1405              	.L75:
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1406              		.loc 1 444 13 view .LVU390
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1407              		.loc 1 444 16 is_stmt 0 view .LVU391
 1408 01ee 14F4407F 		tst	r4, #768
 1409 01f2 27D1     		bne	.L112
 446:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1410              		.loc 1 446 17 is_stmt 1 view .LVU392
 446:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1411              		.loc 1 446 20 is_stmt 0 view .LVU393
 1412 01f4 002D     		cmp	r5, #0
 1413 01f6 7FF468AF 		bne	.L69
 1414              	.LBB61:
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1415              		.loc 1 447 21 is_stmt 1 view .LVU394
 1416              	.LVL139:
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1417              		.loc 1 448 21 view .LVU395
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1418              		.loc 1 447 61 is_stmt 0 view .LVU396
 1419 01fa C4F34213 		ubfx	r3, r4, #5, #3
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1420              		.loc 1 449 104 view .LVU397
 1421 01fe E106     		lsls	r1, r4, #27
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1422              		.loc 1 447 35 view .LVU398
 1423 0200 4FEA8303 		lsl	r3, r3, #2
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1424              		.loc 1 449 94 view .LVU399
 1425 0204 48BF     		it	mi
 1426 0206 0F25     		movmi	r5, #15
 1427              	.LVL140:
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1428              		.loc 1 448 84 view .LVU400
 1429 0208 DBB2     		uxtb	r3, r3
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1430              		.loc 1 449 94 view .LVU401
 1431 020a 48BF     		it	mi
 1432 020c 9D40     		lslmi	r5, r5, r3
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1433              		.loc 1 448 44 view .LVU402
 1434 020e 04F00F02 		and	r2, r4, #15
 450:quantum/action.c ****                         case OP_BIT_AND:
 1435              		.loc 1 450 47 view .LVU403
 1436 0212 C4F38124 		ubfx	r4, r4, #10, #2
 1437              	.LVL141:
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1438              		.loc 1 449 104 view .LVU404
 1439 0216 48BF     		it	mi
 1440 0218 ED43     		mvnmi	r5, r5
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1441              		.loc 1 448 35 view .LVU405
 1442 021a 9A40     		lsls	r2, r2, r3
 1443              	.LVL142:
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1444              		.loc 1 449 21 is_stmt 1 view .LVU406
 450:quantum/action.c ****                         case OP_BIT_AND:
 1445              		.loc 1 450 21 view .LVU407
 1446 021c 022C     		cmp	r4, #2
 452:quantum/action.c ****                             break;
 1447              		.loc 1 452 29 is_stmt 0 view .LVU408
 1448 021e 45EA0200 		orr	r0, r5, r2
 1449 0222 09D0     		beq	.L114
 1450 0224 032C     		cmp	r4, #3
 1451 0226 0AD0     		beq	.L115
 1452 0228 012C     		cmp	r4, #1
 1453 022a 02D0     		beq	.L116
 452:quantum/action.c ****                             break;
 1454              		.loc 1 452 29 is_stmt 1 view .LVU409
 1455 022c FFF7FEFF 		bl	default_layer_and
 1456              	.LVL143:
 453:quantum/action.c ****                         case OP_BIT_OR:
 1457              		.loc 1 453 29 view .LVU410
 1458 0230 4BE7     		b	.L69
 1459              	.LVL144:
 1460              	.L116:
 455:quantum/action.c ****                             break;
 1461              		.loc 1 455 29 view .LVU411
 1462 0232 FFF7FEFF 		bl	default_layer_or
 1463              	.LVL145:
 456:quantum/action.c ****                         case OP_BIT_XOR:
 1464              		.loc 1 456 29 view .LVU412
 1465 0236 48E7     		b	.L69
 1466              	.LVL146:
 1467              	.L114:
 458:quantum/action.c ****                             break;
 1468              		.loc 1 458 29 view .LVU413
 1469 0238 FFF7FEFF 		bl	default_layer_xor
 1470              	.LVL147:
 459:quantum/action.c ****                         case OP_BIT_SET:
 1471              		.loc 1 459 29 view .LVU414
 1472 023c 45E7     		b	.L69
 1473              	.LVL148:
 1474              	.L115:
 461:quantum/action.c ****                             break;
 1475              		.loc 1 461 29 view .LVU415
 1476 023e FFF7FEFF 		bl	default_layer_set
 1477              	.LVL149:
 462:quantum/action.c ****                     }
 1478              		.loc 1 462 29 view .LVU416
 1479 0242 42E7     		b	.L69
 1480              	.LVL150:
 1481              	.L112:
 462:quantum/action.c ****                     }
 1482              		.loc 1 462 29 is_stmt 0 view .LVU417
 1483              	.LBE61:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1484              		.loc 1 467 17 is_stmt 1 view .LVU418
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1485              		.loc 1 467 56 is_stmt 0 view .LVU419
 1486 0244 C4F30122 		ubfx	r2, r4, #8, #2
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1487              		.loc 1 467 21 view .LVU420
 1488 0248 0DB3     		cbz	r5, .L117
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1489              		.loc 1 467 20 discriminator 1 view .LVU421
 1490 024a 12F0010F 		tst	r2, #1
 1491              	.L176:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1492              		.loc 1 467 20 discriminator 2 view .LVU422
 1493 024e 3FF43CAF 		beq	.L69
 1494              	.LBB62:
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1495              		.loc 1 468 21 is_stmt 1 view .LVU423
 1496              	.LVL151:
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1497              		.loc 1 469 21 view .LVU424
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1498              		.loc 1 468 61 is_stmt 0 view .LVU425
 1499 0252 C4F34213 		ubfx	r3, r4, #5, #3
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1500              		.loc 1 470 104 view .LVU426
 1501 0256 14F01000 		ands	r0, r4, #16
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1502              		.loc 1 468 35 view .LVU427
 1503 025a 4FEA8303 		lsl	r3, r3, #2
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1504              		.loc 1 469 84 view .LVU428
 1505 025e DBB2     		uxtb	r3, r3
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1506              		.loc 1 470 94 view .LVU429
 1507 0260 1CBF     		itt	ne
 1508 0262 0F20     		movne	r0, #15
 1509 0264 9840     		lslne	r0, r0, r3
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1510              		.loc 1 469 44 view .LVU430
 1511 0266 04F00F02 		and	r2, r4, #15
 471:quantum/action.c ****                         case OP_BIT_AND:
 1512              		.loc 1 471 47 view .LVU431
 1513 026a C4F38124 		ubfx	r4, r4, #10, #2
 1514              	.LVL152:
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1515              		.loc 1 469 35 view .LVU432
 1516 026e 02FA03F2 		lsl	r2, r2, r3
 1517              	.LVL153:
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1518              		.loc 1 470 21 is_stmt 1 view .LVU433
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1519              		.loc 1 470 104 is_stmt 0 view .LVU434
 1520 0272 14BF     		ite	ne
 1521 0274 C343     		mvnne	r3, r0
 1522 0276 0346     		moveq	r3, r0
 1523              	.LVL154:
 471:quantum/action.c ****                         case OP_BIT_AND:
 1524              		.loc 1 471 21 is_stmt 1 view .LVU435
 1525 0278 022C     		cmp	r4, #2
 473:quantum/action.c ****                             break;
 1526              		.loc 1 473 29 is_stmt 0 view .LVU436
 1527 027a 43EA0200 		orr	r0, r3, r2
 1528 027e 0CD0     		beq	.L120
 1529 0280 032C     		cmp	r4, #3
 1530 0282 0DD0     		beq	.L121
 1531 0284 012C     		cmp	r4, #1
 1532 0286 05D0     		beq	.L122
 473:quantum/action.c ****                             break;
 1533              		.loc 1 473 29 is_stmt 1 view .LVU437
 1534 0288 FFF7FEFF 		bl	layer_and
 1535              	.LVL155:
 474:quantum/action.c ****                         case OP_BIT_OR:
 1536              		.loc 1 474 29 view .LVU438
 1537 028c 1DE7     		b	.L69
 1538              	.LVL156:
 1539              	.L117:
 474:quantum/action.c ****                         case OP_BIT_OR:
 1540              		.loc 1 474 29 is_stmt 0 view .LVU439
 1541              	.LBE62:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1542              		.loc 1 467 20 discriminator 2 view .LVU440
 1543 028e 12F0020F 		tst	r2, #2
 1544 0292 DCE7     		b	.L176
 1545              	.LVL157:
 1546              	.L122:
 1547              	.LBB63:
 476:quantum/action.c ****                             break;
 1548              		.loc 1 476 29 is_stmt 1 view .LVU441
 1549 0294 FFF7FEFF 		bl	layer_or
 1550              	.LVL158:
 477:quantum/action.c ****                         case OP_BIT_XOR:
 1551              		.loc 1 477 29 view .LVU442
 1552 0298 17E7     		b	.L69
 1553              	.LVL159:
 1554              	.L120:
 479:quantum/action.c ****                             break;
 1555              		.loc 1 479 29 view .LVU443
 1556 029a FFF7FEFF 		bl	layer_xor
 1557              	.LVL160:
 480:quantum/action.c ****                         case OP_BIT_SET:
 1558              		.loc 1 480 29 view .LVU444
 1559 029e 14E7     		b	.L69
 1560              	.LVL161:
 1561              	.L121:
 482:quantum/action.c ****                             break;
 1562              		.loc 1 482 29 view .LVU445
 1563 02a0 FFF7FEFF 		bl	layer_state_set
 1564              	.LVL162:
 483:quantum/action.c ****                     }
 1565              		.loc 1 483 29 view .LVU446
 1566 02a4 11E7     		b	.L69
 1567              	.LVL163:
 1568              	.L74:
 483:quantum/action.c ****                     }
 1569              		.loc 1 483 29 is_stmt 0 view .LVU447
 1570              	.LBE63:
 489:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1571              		.loc 1 489 13 is_stmt 1 view .LVU448
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1572              		.loc 1 258 88 is_stmt 0 view .LVU449
 1573 02a6 E6B2     		uxtb	r6, r4
 1574              	.LBB64:
 272:quantum/action.c ****             if (event.pressed) {
 1575              		.loc 1 272 21 view .LVU450
 1576 02a8 C4F30324 		ubfx	r4, r4, #8, #4
 1577              	.LVL164:
 272:quantum/action.c ****             if (event.pressed) {
 1578              		.loc 1 272 21 view .LVU451
 1579              	.LBE64:
 489:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1580              		.loc 1 489 16 view .LVU452
 1581 02ac 25B1     		cbz	r5, .L123
 490:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 1582              		.loc 1 490 17 is_stmt 1 view .LVU453
 1583 02ae 2046     		mov	r0, r4
 1584 02b0 FFF7FEFF 		bl	layer_on
 1585              	.LVL165:
 491:quantum/action.c ****             } else {
 1586              		.loc 1 491 17 view .LVU454
 1587 02b4 3046     		mov	r0, r6
 1588 02b6 4DE7     		b	.L182
 1589              	.L123:
 493:quantum/action.c ****                 layer_off(action.layer_mods.layer);
 1590              		.loc 1 493 17 view .LVU455
 1591 02b8 3046     		mov	r0, r6
 1592 02ba FFF7FEFF 		bl	unregister_mods
 1593              	.LVL166:
 494:quantum/action.c ****             }
 1594              		.loc 1 494 17 view .LVU456
 1595 02be 2046     		mov	r0, r4
 1596              	.LVL167:
 1597              	.L185:
 581:quantum/action.c ****                         }
 1598              		.loc 1 581 29 is_stmt 0 view .LVU457
 1599 02c0 FFF7FEFF 		bl	layer_off
 1600              	.LVL168:
 1601 02c4 01E7     		b	.L69
 1602              	.L73:
 500:quantum/action.c ****                 case OP_TAP_TOGGLE:
 1603              		.loc 1 500 13 is_stmt 1 view .LVU458
 500:quantum/action.c ****                 case OP_TAP_TOGGLE:
 1604              		.loc 1 500 37 is_stmt 0 view .LVU459
 1605 02c6 5FFA84FA 		uxtb	r10, r4
 1606 02ca AAF1F003 		sub	r3, r10, #240
 1607 02ce 042B     		cmp	r3, #4
 1608 02d0 39D8     		bhi	.L124
 1609 02d2 DFE803F0 		tbb	[pc, r3]
 1610              	.L126:
 1611 02d6 03       		.byte	(.L130-.L126)/2
 1612 02d7 0E       		.byte	(.L129-.L126)/2
 1613 02d8 15       		.byte	(.L128-.L126)/2
 1614 02d9 1A       		.byte	(.L127-.L126)/2
 1615 02da 23       		.byte	(.L125-.L126)/2
 1616 02db 00       		.p2align 1
 1617              	.L130:
 503:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1618              		.loc 1 503 21 is_stmt 1 view .LVU460
 503:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1619              		.loc 1 503 24 is_stmt 0 view .LVU461
 1620 02dc 3DB1     		cbz	r5, .L131
 504:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1621              		.loc 1 504 25 is_stmt 1 view .LVU462
 504:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1622              		.loc 1 504 28 is_stmt 0 view .LVU463
 1623 02de 042E     		cmp	r6, #4
 1624              	.L178:
 1625 02e0 3FF6F3AE 		bhi	.L69
 505:quantum/action.c ****                         }
 1626              		.loc 1 505 29 is_stmt 1 view .LVU464
 1627 02e4 C4F30420 		ubfx	r0, r4, #8, #5
 1628 02e8 FFF7FEFF 		bl	layer_invert
 1629              	.LVL169:
 1630 02ec EDE6     		b	.L69
 1631              	.L131:
 508:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1632              		.loc 1 508 25 view .LVU465
 508:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1633              		.loc 1 508 28 is_stmt 0 view .LVU466
 1634 02ee 052E     		cmp	r6, #5
 1635 02f0 F6E7     		b	.L178
 1636              	.L129:
 514:quantum/action.c ****                     break;
 1637              		.loc 1 514 21 is_stmt 1 view .LVU467
 505:quantum/action.c ****                         }
 1638              		.loc 1 505 29 is_stmt 0 view .LVU468
 1639 02f2 C4F30420 		ubfx	r0, r4, #8, #5
 514:quantum/action.c ****                     break;
 1640              		.loc 1 514 68 view .LVU469
 1641 02f6 002D     		cmp	r5, #0
 1642 02f8 E2D0     		beq	.L185
 1643              	.L181:
 568:quantum/action.c ****                         }
 1644              		.loc 1 568 29 view .LVU470
 1645 02fa FFF7FEFF 		bl	layer_on
 1646              	.LVL170:
 1647 02fe E4E6     		b	.L69
 1648              	.L128:
 517:quantum/action.c ****                     break;
 1649              		.loc 1 517 21 is_stmt 1 view .LVU471
 505:quantum/action.c ****                         }
 1650              		.loc 1 505 29 is_stmt 0 view .LVU472
 1651 0300 C4F30420 		ubfx	r0, r4, #8, #5
 517:quantum/action.c ****                     break;
 1652              		.loc 1 517 69 view .LVU473
 1653 0304 002D     		cmp	r5, #0
 1654 0306 F8D0     		beq	.L181
 1655 0308 DAE7     		b	.L185
 1656              	.L127:
 520:quantum/action.c ****                     break;
 1657              		.loc 1 520 21 is_stmt 1 view .LVU474
 520:quantum/action.c ****                     break;
 1658              		.loc 1 520 70 is_stmt 0 view .LVU475
 1659 030a 25B1     		cbz	r5, .L135
 520:quantum/action.c ****                     break;
 1660              		.loc 1 520 37 discriminator 1 view .LVU476
 1661 030c C4F30420 		ubfx	r0, r4, #8, #5
 1662 0310 FFF7FEFF 		bl	layer_move
 1663              	.LVL171:
 1664 0314 D9E6     		b	.L69
 1665              	.L135:
 520:quantum/action.c ****                     break;
 1666              		.loc 1 520 72 discriminator 2 view .LVU477
 1667 0316 FFF7FEFF 		bl	layer_clear
 1668              	.LVL172:
 1669 031a D6E6     		b	.L69
 1670              	.L125:
 548:quantum/action.c ****                         layer_on(action.layer_tap.val);
 1671              		.loc 1 548 21 is_stmt 1 view .LVU478
 548:quantum/action.c ****                         layer_on(action.layer_tap.val);
 1672              		.loc 1 548 24 is_stmt 0 view .LVU479
 1673 031c 4DB1     		cbz	r5, .L136
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1674              		.loc 1 549 25 is_stmt 1 view .LVU480
 1675 031e C4F30420 		ubfx	r0, r4, #8, #5
 1676 0322 0190     		str	r0, [sp, #4]
 1677 0324 FFF7FEFF 		bl	layer_on
 1678              	.LVL173:
 550:quantum/action.c ****                     } else {
 1679              		.loc 1 550 25 view .LVU481
 1680 0328 0198     		ldr	r0, [sp, #4]
 1681 032a 0321     		movs	r1, #3
 1682 032c FFF7FEFF 		bl	set_oneshot_layer
 1683              	.LVL174:
 1684 0330 CBE6     		b	.L69
 1685              	.L136:
 552:quantum/action.c ****                         if (tap_count > 1) {
 1686              		.loc 1 552 25 view .LVU482
 1687 0332 0120     		movs	r0, #1
 1688 0334 FFF7FEFF 		bl	clear_oneshot_layer_state
 1689              	.LVL175:
 553:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1690              		.loc 1 553 25 view .LVU483
 553:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1691              		.loc 1 553 28 is_stmt 0 view .LVU484
 1692 0338 012E     		cmp	r6, #1
 1693 033a 7FF6C6AE 		bls	.L69
 554:quantum/action.c ****                         }
 1694              		.loc 1 554 29 is_stmt 1 view .LVU485
 1695 033e 0220     		movs	r0, #2
 1696 0340 FFF7FEFF 		bl	clear_oneshot_layer_state
 1697              	.LVL176:
 1698 0344 C1E6     		b	.L69
 1699              	.L124:
 562:quantum/action.c ****                         if (tap_count > 0) {
 1700              		.loc 1 562 21 view .LVU486
 562:quantum/action.c ****                         if (tap_count > 0) {
 1701              		.loc 1 562 24 is_stmt 0 view .LVU487
 1702 0346 2DB1     		cbz	r5, .L137
 563:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1703              		.loc 1 563 25 is_stmt 1 view .LVU488
 563:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1704              		.loc 1 563 28 is_stmt 0 view .LVU489
 1705 0348 0EB1     		cbz	r6, .L138
 564:quantum/action.c ****                             register_code(action.layer_tap.code);
 1706              		.loc 1 564 75 is_stmt 1 view .LVU490
 565:quantum/action.c ****                         } else {
 1707              		.loc 1 565 29 view .LVU491
 1708 034a 5046     		mov	r0, r10
 1709 034c A8E6     		b	.L184
 1710              	.L138:
 567:quantum/action.c ****                             layer_on(action.layer_tap.val);
 1711              		.loc 1 567 76 view .LVU492
 568:quantum/action.c ****                         }
 1712              		.loc 1 568 29 view .LVU493
 1713 034e C4F30420 		ubfx	r0, r4, #8, #5
 1714 0352 D2E7     		b	.L181
 1715              	.L137:
 571:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1716              		.loc 1 571 25 view .LVU494
 571:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1717              		.loc 1 571 28 is_stmt 0 view .LVU495
 1718 0354 4EB1     		cbz	r6, .L139
 572:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1719              		.loc 1 572 77 is_stmt 1 view .LVU496
 573:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1720              		.loc 1 573 29 view .LVU497
 573:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1721              		.loc 1 573 32 is_stmt 0 view .LVU498
 1722 0356 BAF1390F 		cmp	r10, #57
 574:quantum/action.c ****                             } else {
 1723              		.loc 1 574 33 is_stmt 1 view .LVU499
 574:quantum/action.c ****                             } else {
 1724              		.loc 1 574 33 view .LVU500
 574:quantum/action.c ****                             } else {
 1725              		.loc 1 574 33 view .LVU501
 1726 035a 0CBF     		ite	eq
 1727 035c 4FF44870 		moveq	r0, #800
 576:quantum/action.c ****                             }
 1728              		.loc 1 576 33 view .LVU502
 576:quantum/action.c ****                             }
 1729              		.loc 1 576 33 view .LVU503
 576:quantum/action.c ****                             }
 1730              		.loc 1 576 33 view .LVU504
 1731 0360 0120     		movne	r0, #1
 1732 0362 FFF7FEFF 		bl	chThdSleep
 1733              	.LVL177:
 576:quantum/action.c ****                             }
 1734              		.loc 1 576 33 view .LVU505
 578:quantum/action.c ****                         } else {
 1735              		.loc 1 578 29 view .LVU506
 1736 0366 5046     		mov	r0, r10
 1737 0368 1DE7     		b	.L183
 1738              	.L139:
 580:quantum/action.c ****                             layer_off(action.layer_tap.val);
 1739              		.loc 1 580 79 view .LVU507
 581:quantum/action.c ****                         }
 1740              		.loc 1 581 29 view .LVU508
 1741 036a C4F30420 		ubfx	r0, r4, #8, #5
 1742 036e A7E7     		b	.L185
 1743              	.L72:
 592:quantum/action.c ****             break;
 1744              		.loc 1 592 13 view .LVU509
 1745 0370 C4F30322 		ubfx	r2, r4, #8, #4
 1746 0374 E1B2     		uxtb	r1, r4
 1747 0376 4046     		mov	r0, r8
 1748 0378 FFF7FEFF 		bl	action_get_macro
 1749              	.LVL178:
 1750 037c FFF7FEFF 		bl	action_macro_play
 1751              	.LVL179:
 593:quantum/action.c **** #endif
 1752              		.loc 1 593 13 view .LVU510
 1753 0380 A3E6     		b	.L69
 1754              	.L70:
 670:quantum/action.c ****             break;
 1755              		.loc 1 670 13 view .LVU511
 1756 0382 C4F30322 		ubfx	r2, r4, #8, #4
 1757 0386 E1B2     		uxtb	r1, r4
 1758 0388 4046     		mov	r0, r8
 1759 038a FFF7FEFF 		bl	action_function
 1760              	.LVL180:
 671:quantum/action.c **** #endif
 1761              		.loc 1 671 13 view .LVU512
 1762 038e 9CE6     		b	.L69
 1763              	.LVL181:
 1764              	.L66:
 739:quantum/action.c **** 
 1765              		.loc 1 739 1 is_stmt 0 view .LVU513
 1766 0390 02B0     		add	sp, sp, #8
 1767              		.cfi_def_cfa_offset 32
 1768              		@ sp needed
 1769 0392 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 739:quantum/action.c **** 
 1770              		.loc 1 739 1 view .LVU514
 1771              		.cfi_endproc
 1772              	.LFE345:
 1774              		.section	.text.process_record_handler,"ax",%progbits
 1775              		.align	1
 1776              		.global	process_record_handler
 1777              		.syntax unified
 1778              		.thumb
 1779              		.thumb_func
 1780              		.fpu fpv4-sp-d16
 1782              	process_record_handler:
 1783              	.LVL182:
 1784              	.LFB344:
 208:quantum/action.c **** #ifdef COMBO_ENABLE
 1785              		.loc 1 208 50 is_stmt 1 view -0
 1786              		.cfi_startproc
 1787              		@ args = 0, pretend = 0, frame = 8
 1788              		@ frame_needed = 0, uses_anonymous_args = 0
 217:quantum/action.c **** #endif
 1789              		.loc 1 217 5 view .LVU516
 208:quantum/action.c **** #ifdef COMBO_ENABLE
 1790              		.loc 1 208 50 is_stmt 0 view .LVU517
 1791 0000 13B5     		push	{r0, r1, r4, lr}
 1792              		.cfi_def_cfa_offset 16
 1793              		.cfi_offset 4, -8
 1794              		.cfi_offset 14, -4
 217:quantum/action.c **** #endif
 1795              		.loc 1 217 23 view .LVU518
 1796 0002 0188     		ldrh	r1, [r0]
 208:quantum/action.c **** #ifdef COMBO_ENABLE
 1797              		.loc 1 208 50 view .LVU519
 1798 0004 0446     		mov	r4, r0
 217:quantum/action.c **** #endif
 1799              		.loc 1 217 23 view .LVU520
 1800 0006 8078     		ldrb	r0, [r0, #2]	@ zero_extendqisi2
 1801              	.LVL183:
 217:quantum/action.c **** #endif
 1802              		.loc 1 217 23 view .LVU521
 1803 0008 FFF7FEFF 		bl	store_or_get_action
 1804              	.LVL184:
 1805 000c 0146     		mov	r1, r0	@ movhi
 1806              	.LVL185:
 217:quantum/action.c **** #endif
 1807              		.loc 1 217 23 view .LVU522
 1808 000e 0191     		str	r1, [sp, #4]
 219:quantum/action.c ****     debug_action(action);
 1809              		.loc 1 219 23 is_stmt 1 view .LVU523
 220:quantum/action.c **** #ifndef NO_ACTION_LAYER
 1810              		.loc 1 220 5 view .LVU524
 222:quantum/action.c ****     layer_debug();
 1811              		.loc 1 222 29 view .LVU525
 223:quantum/action.c ****     dprint(" default_layer_state: ");
 1812              		.loc 1 223 5 view .LVU526
 1813 0010 FFF7FEFF 		bl	layer_debug
 1814              	.LVL186:
 224:quantum/action.c ****     default_layer_debug();
 1815              		.loc 1 224 37 view .LVU527
 225:quantum/action.c **** #endif
 1816              		.loc 1 225 5 view .LVU528
 1817 0014 FFF7FEFF 		bl	default_layer_debug
 1818              	.LVL187:
 227:quantum/action.c **** 
 1819              		.loc 1 227 15 view .LVU529
 229:quantum/action.c **** }
 1820              		.loc 1 229 5 view .LVU530
 1821 0018 0199     		ldr	r1, [sp, #4]
 229:quantum/action.c **** }
 1822              		.loc 1 229 5 is_stmt 0 view .LVU531
 1823 001a 2046     		mov	r0, r4
 230:quantum/action.c **** 
 1824              		.loc 1 230 1 view .LVU532
 1825 001c 02B0     		add	sp, sp, #8
 1826              		.cfi_def_cfa_offset 8
 1827              		@ sp needed
 1828 001e BDE81040 		pop	{r4, lr}
 1829              		.cfi_restore 14
 1830              		.cfi_restore 4
 1831              		.cfi_def_cfa_offset 0
 1832              	.LVL188:
 229:quantum/action.c **** }
 1833              		.loc 1 229 5 view .LVU533
 1834 0022 FFF7FEBF 		b	process_action
 1835              	.LVL189:
 229:quantum/action.c **** }
 1836              		.loc 1 229 5 view .LVU534
 1837              		.cfi_endproc
 1838              	.LFE344:
 1840              		.section	.text.process_record,"ax",%progbits
 1841              		.align	1
 1842              		.global	process_record
 1843              		.syntax unified
 1844              		.thumb
 1845              		.thumb_func
 1846              		.fpu fpv4-sp-d16
 1848              	process_record:
 1849              	.LVL190:
 1850              	.LFB343:
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 1851              		.loc 1 190 42 is_stmt 1 view -0
 1852              		.cfi_startproc
 1853              		@ args = 0, pretend = 0, frame = 8
 1854              		@ frame_needed = 0, uses_anonymous_args = 0
 191:quantum/action.c ****         return;
 1855              		.loc 1 191 5 view .LVU536
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 1856              		.loc 1 190 42 is_stmt 0 view .LVU537
 1857 0000 13B5     		push	{r0, r1, r4, lr}
 1858              		.cfi_def_cfa_offset 16
 1859              		.cfi_offset 4, -8
 1860              		.cfi_offset 14, -4
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 1861              		.loc 1 190 42 view .LVU538
 1862 0002 0446     		mov	r4, r0
 1863 0004 0068     		ldr	r0, [r0]	@ unaligned
 1864              	.LVL191:
 1865              	.LBB71:
 1866              	.LBB72:
 1867              		.loc 2 47 74 view .LVU539
 1868 0006 A388     		ldrh	r3, [r4, #4]
 1869 0008 0090     		str	r0, [sp]
 1870              	.LVL192:
 1871              		.loc 2 47 74 view .LVU540
 1872              	.LBE72:
 1873              	.LBI71:
 1874              		.loc 2 47 20 is_stmt 1 view .LVU541
 1875              	.LBB73:
 1876              		.loc 2 47 51 view .LVU542
 1877              		.loc 2 47 74 is_stmt 0 view .LVU543
 1878 000a D3B1     		cbz	r3, .L189
 1879              		.loc 2 47 99 view .LVU544
 1880 000c BDF80020 		ldrh	r2, [sp]
 1881              	.LVL193:
 1882              		.loc 2 47 99 view .LVU545
 1883              	.LBE73:
 1884              	.LBE71:
 191:quantum/action.c ****         return;
 1885              		.loc 1 191 8 view .LVU546
 1886 0010 4FF6FF73 		movw	r3, #65535
 1887 0014 9A42     		cmp	r2, r3
 1888 0016 14D0     		beq	.L189
 1889              	.LVL194:
 1890              	.LBB74:
 1891              	.LBI74:
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 1892              		.loc 1 190 6 is_stmt 1 view .LVU547
 1893              	.LBB75:
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 1894              		.loc 1 195 5 view .LVU548
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 1895              		.loc 1 195 10 is_stmt 0 view .LVU549
 1896 0018 2046     		mov	r0, r4
 1897 001a FFF7FEFF 		bl	process_record_quantum
 1898              	.LVL195:
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 1899              		.loc 1 195 8 view .LVU550
 1900 001e 50B9     		cbnz	r0, .L193
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1901              		.loc 1 197 9 is_stmt 1 view .LVU551
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1902              		.loc 1 197 13 is_stmt 0 view .LVU552
 1903 0020 FFF7FEFF 		bl	is_oneshot_layer_active
 1904              	.LVL196:
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1905              		.loc 1 197 12 view .LVU553
 1906 0024 68B1     		cbz	r0, .L189
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1907              		.loc 1 197 39 view .LVU554
 1908 0026 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1909 0028 5BB1     		cbz	r3, .L189
 198:quantum/action.c ****         }
 1910              		.loc 1 198 13 is_stmt 1 view .LVU555
 1911 002a 0220     		movs	r0, #2
 1912              	.LBE75:
 1913              	.LBE74:
 206:quantum/action.c **** 
 1914              		.loc 1 206 1 is_stmt 0 view .LVU556
 1915 002c 02B0     		add	sp, sp, #8
 1916              		.cfi_remember_state
 1917              		.cfi_def_cfa_offset 8
 1918              		@ sp needed
 1919 002e BDE81040 		pop	{r4, lr}
 1920              		.cfi_restore 14
 1921              		.cfi_restore 4
 1922              		.cfi_def_cfa_offset 0
 1923              	.LVL197:
 1924              	.LBB77:
 1925              	.LBB76:
 198:quantum/action.c ****         }
 1926              		.loc 1 198 13 view .LVU557
 1927 0032 FFF7FEBF 		b	clear_oneshot_layer_state
 1928              	.LVL198:
 1929              	.L193:
 1930              		.cfi_restore_state
 204:quantum/action.c ****     post_process_record_quantum(record);
 1931              		.loc 1 204 5 is_stmt 1 view .LVU558
 1932 0036 2046     		mov	r0, r4
 1933 0038 FFF7FEFF 		bl	process_record_handler
 1934              	.LVL199:
 205:quantum/action.c **** }
 1935              		.loc 1 205 5 view .LVU559
 1936 003c 2046     		mov	r0, r4
 1937 003e FFF7FEFF 		bl	post_process_record_quantum
 1938              	.LVL200:
 1939              	.L189:
 205:quantum/action.c **** }
 1940              		.loc 1 205 5 is_stmt 0 view .LVU560
 1941              	.LBE76:
 1942              	.LBE77:
 206:quantum/action.c **** 
 1943              		.loc 1 206 1 view .LVU561
 1944 0042 02B0     		add	sp, sp, #8
 1945              		.cfi_def_cfa_offset 8
 1946              		@ sp needed
 1947 0044 10BD     		pop	{r4, pc}
 206:quantum/action.c **** 
 1948              		.loc 1 206 1 view .LVU562
 1949              		.cfi_endproc
 1950              	.LFE343:
 1952              		.section	.text.process_record_nocache,"ax",%progbits
 1953              		.align	1
 1954              		.global	process_record_nocache
 1955              		.syntax unified
 1956              		.thumb
 1957              		.thumb_func
 1958              		.fpu fpv4-sp-d16
 1960              	process_record_nocache:
 1961              	.LVL201:
 1962              	.LFB339:
 148:quantum/action.c ****     disable_action_cache = true;
 1963              		.loc 1 148 50 is_stmt 1 view -0
 1964              		.cfi_startproc
 1965              		@ args = 0, pretend = 0, frame = 0
 1966              		@ frame_needed = 0, uses_anonymous_args = 0
 149:quantum/action.c ****     process_record(record);
 1967              		.loc 1 149 5 view .LVU564
 148:quantum/action.c ****     disable_action_cache = true;
 1968              		.loc 1 148 50 is_stmt 0 view .LVU565
 1969 0000 10B5     		push	{r4, lr}
 1970              		.cfi_def_cfa_offset 8
 1971              		.cfi_offset 4, -8
 1972              		.cfi_offset 14, -4
 149:quantum/action.c ****     process_record(record);
 1973              		.loc 1 149 26 view .LVU566
 1974 0002 044C     		ldr	r4, .L202
 1975 0004 0123     		movs	r3, #1
 1976 0006 2370     		strb	r3, [r4]
 150:quantum/action.c ****     disable_action_cache = false;
 1977              		.loc 1 150 5 is_stmt 1 view .LVU567
 1978 0008 FFF7FEFF 		bl	process_record
 1979              	.LVL202:
 151:quantum/action.c **** }
 1980              		.loc 1 151 5 view .LVU568
 151:quantum/action.c **** }
 1981              		.loc 1 151 26 is_stmt 0 view .LVU569
 1982 000c 0023     		movs	r3, #0
 1983 000e 2370     		strb	r3, [r4]
 152:quantum/action.c **** #else
 1984              		.loc 1 152 1 view .LVU570
 1985 0010 10BD     		pop	{r4, pc}
 1986              	.L203:
 1987 0012 00BF     		.align	2
 1988              	.L202:
 1989 0014 00000000 		.word	.LANCHOR1
 1990              		.cfi_endproc
 1991              	.LFE339:
 1993              		.section	.text.register_weak_mods,"ax",%progbits
 1994              		.align	1
 1995              		.global	register_weak_mods
 1996              		.syntax unified
 1997              		.thumb
 1998              		.thumb_func
 1999              		.fpu fpv4-sp-d16
 2001              	register_weak_mods:
 2002              	.LVL203:
 2003              	.LFB352:
 934:quantum/action.c **** 
 935:quantum/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 936:quantum/action.c ****  *
 937:quantum/action.c ****  * \param mods A bitfield of modifiers to register.
 938:quantum/action.c ****  */
 939:quantum/action.c **** void register_weak_mods(uint8_t mods) {
 2004              		.loc 1 939 39 is_stmt 1 view -0
 2005              		.cfi_startproc
 2006              		@ args = 0, pretend = 0, frame = 0
 2007              		@ frame_needed = 0, uses_anonymous_args = 0
 940:quantum/action.c ****     if (mods) {
 2008              		.loc 1 940 5 view .LVU572
 939:quantum/action.c ****     if (mods) {
 2009              		.loc 1 939 39 is_stmt 0 view .LVU573
 2010 0000 08B5     		push	{r3, lr}
 2011              		.cfi_def_cfa_offset 8
 2012              		.cfi_offset 3, -8
 2013              		.cfi_offset 14, -4
 2014              		.loc 1 940 8 view .LVU574
 2015 0002 28B1     		cbz	r0, .L204
 941:quantum/action.c ****         add_weak_mods(mods);
 2016              		.loc 1 941 9 is_stmt 1 view .LVU575
 2017 0004 FFF7FEFF 		bl	add_weak_mods
 2018              	.LVL204:
 942:quantum/action.c ****         send_keyboard_report();
 2019              		.loc 1 942 9 view .LVU576
 943:quantum/action.c ****     }
 944:quantum/action.c **** }
 2020              		.loc 1 944 1 is_stmt 0 view .LVU577
 2021 0008 BDE80840 		pop	{r3, lr}
 2022              		.cfi_remember_state
 2023              		.cfi_restore 14
 2024              		.cfi_restore 3
 2025              		.cfi_def_cfa_offset 0
 942:quantum/action.c ****         send_keyboard_report();
 2026              		.loc 1 942 9 view .LVU578
 2027 000c FFF7FEBF 		b	send_keyboard_report
 2028              	.LVL205:
 2029              	.L204:
 2030              		.cfi_restore_state
 2031              		.loc 1 944 1 view .LVU579
 2032 0010 08BD     		pop	{r3, pc}
 2033              		.cfi_endproc
 2034              	.LFE352:
 2036              		.section	.text.unregister_weak_mods,"ax",%progbits
 2037              		.align	1
 2038              		.global	unregister_weak_mods
 2039              		.syntax unified
 2040              		.thumb
 2041              		.thumb_func
 2042              		.fpu fpv4-sp-d16
 2044              	unregister_weak_mods:
 2045              	.LVL206:
 2046              	.LFB353:
 945:quantum/action.c **** 
 946:quantum/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 947:quantum/action.c ****  *
 948:quantum/action.c ****  * \param mods A bitfield of modifiers to unregister.
 949:quantum/action.c ****  */
 950:quantum/action.c **** void unregister_weak_mods(uint8_t mods) {
 2047              		.loc 1 950 41 is_stmt 1 view -0
 2048              		.cfi_startproc
 2049              		@ args = 0, pretend = 0, frame = 0
 2050              		@ frame_needed = 0, uses_anonymous_args = 0
 951:quantum/action.c ****     if (mods) {
 2051              		.loc 1 951 5 view .LVU581
 950:quantum/action.c ****     if (mods) {
 2052              		.loc 1 950 41 is_stmt 0 view .LVU582
 2053 0000 08B5     		push	{r3, lr}
 2054              		.cfi_def_cfa_offset 8
 2055              		.cfi_offset 3, -8
 2056              		.cfi_offset 14, -4
 2057              		.loc 1 951 8 view .LVU583
 2058 0002 28B1     		cbz	r0, .L206
 952:quantum/action.c ****         del_weak_mods(mods);
 2059              		.loc 1 952 9 is_stmt 1 view .LVU584
 2060 0004 FFF7FEFF 		bl	del_weak_mods
 2061              	.LVL207:
 953:quantum/action.c ****         send_keyboard_report();
 2062              		.loc 1 953 9 view .LVU585
 954:quantum/action.c ****     }
 955:quantum/action.c **** }
 2063              		.loc 1 955 1 is_stmt 0 view .LVU586
 2064 0008 BDE80840 		pop	{r3, lr}
 2065              		.cfi_remember_state
 2066              		.cfi_restore 14
 2067              		.cfi_restore 3
 2068              		.cfi_def_cfa_offset 0
 953:quantum/action.c ****         send_keyboard_report();
 2069              		.loc 1 953 9 view .LVU587
 2070 000c FFF7FEBF 		b	send_keyboard_report
 2071              	.LVL208:
 2072              	.L206:
 2073              		.cfi_restore_state
 2074              		.loc 1 955 1 view .LVU588
 2075 0010 08BD     		pop	{r3, pc}
 2076              		.cfi_endproc
 2077              	.LFE353:
 2079              		.section	.text.clear_keyboard_but_mods_and_keys,"ax",%progbits
 2080              		.align	1
 2081              		.global	clear_keyboard_but_mods_and_keys
 2082              		.syntax unified
 2083              		.thumb
 2084              		.thumb_func
 2085              		.fpu fpv4-sp-d16
 2087              	clear_keyboard_but_mods_and_keys:
 2088              	.LFB356:
 956:quantum/action.c **** 
 957:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:quantum/action.c ****  *
 959:quantum/action.c ****  * FIXME: Needs documentation.
 960:quantum/action.c ****  */
 961:quantum/action.c **** void clear_keyboard(void) {
 962:quantum/action.c ****     clear_mods();
 963:quantum/action.c ****     clear_keyboard_but_mods();
 964:quantum/action.c **** }
 965:quantum/action.c **** 
 966:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:quantum/action.c ****  *
 968:quantum/action.c ****  * FIXME: Needs documentation.
 969:quantum/action.c ****  */
 970:quantum/action.c **** void clear_keyboard_but_mods(void) {
 971:quantum/action.c ****     clear_keys();
 972:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 973:quantum/action.c **** }
 974:quantum/action.c **** 
 975:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 976:quantum/action.c ****  *
 977:quantum/action.c ****  * FIXME: Needs documentation.
 978:quantum/action.c ****  */
 979:quantum/action.c **** void clear_keyboard_but_mods_and_keys() {
 2089              		.loc 1 979 41 is_stmt 1 view -0
 2090              		.cfi_startproc
 2091              		@ args = 0, pretend = 0, frame = 0
 2092              		@ frame_needed = 0, uses_anonymous_args = 0
 980:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 981:quantum/action.c ****     host_system_send(0);
 2093              		.loc 1 981 5 view .LVU590
 979:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 2094              		.loc 1 979 41 is_stmt 0 view .LVU591
 2095 0000 08B5     		push	{r3, lr}
 2096              		.cfi_def_cfa_offset 8
 2097              		.cfi_offset 3, -8
 2098              		.cfi_offset 14, -4
 2099              		.loc 1 981 5 view .LVU592
 2100 0002 0020     		movs	r0, #0
 2101 0004 FFF7FEFF 		bl	host_system_send
 2102              	.LVL209:
 982:quantum/action.c ****     host_consumer_send(0);
 2103              		.loc 1 982 5 is_stmt 1 view .LVU593
 2104 0008 0020     		movs	r0, #0
 2105 000a FFF7FEFF 		bl	host_consumer_send
 2106              	.LVL210:
 983:quantum/action.c **** #endif
 984:quantum/action.c ****     clear_weak_mods();
 2107              		.loc 1 984 5 view .LVU594
 2108 000e FFF7FEFF 		bl	clear_weak_mods
 2109              	.LVL211:
 985:quantum/action.c ****     clear_macro_mods();
 2110              		.loc 1 985 5 view .LVU595
 2111 0012 FFF7FEFF 		bl	clear_macro_mods
 2112              	.LVL212:
 986:quantum/action.c ****     send_keyboard_report();
 2113              		.loc 1 986 5 view .LVU596
 2114 0016 FFF7FEFF 		bl	send_keyboard_report
 2115              	.LVL213:
 987:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 988:quantum/action.c ****     mousekey_clear();
 2116              		.loc 1 988 5 view .LVU597
 2117 001a FFF7FEFF 		bl	mousekey_clear
 2118              	.LVL214:
 989:quantum/action.c ****     mousekey_send();
 2119              		.loc 1 989 5 view .LVU598
 990:quantum/action.c **** #endif
 991:quantum/action.c **** }
 2120              		.loc 1 991 1 is_stmt 0 view .LVU599
 2121 001e BDE80840 		pop	{r3, lr}
 2122              		.cfi_restore 14
 2123              		.cfi_restore 3
 2124              		.cfi_def_cfa_offset 0
 989:quantum/action.c ****     mousekey_send();
 2125              		.loc 1 989 5 view .LVU600
 2126 0022 FFF7FEBF 		b	mousekey_send
 2127              	.LVL215:
 2128              		.cfi_endproc
 2129              	.LFE356:
 2131              		.section	.text.clear_keyboard_but_mods,"ax",%progbits
 2132              		.align	1
 2133              		.global	clear_keyboard_but_mods
 2134              		.syntax unified
 2135              		.thumb
 2136              		.thumb_func
 2137              		.fpu fpv4-sp-d16
 2139              	clear_keyboard_but_mods:
 2140              	.LFB355:
 970:quantum/action.c ****     clear_keys();
 2141              		.loc 1 970 36 is_stmt 1 view -0
 2142              		.cfi_startproc
 2143              		@ args = 0, pretend = 0, frame = 0
 2144              		@ frame_needed = 0, uses_anonymous_args = 0
 971:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 2145              		.loc 1 971 5 view .LVU602
 970:quantum/action.c ****     clear_keys();
 2146              		.loc 1 970 36 is_stmt 0 view .LVU603
 2147 0000 08B5     		push	{r3, lr}
 2148              		.cfi_def_cfa_offset 8
 2149              		.cfi_offset 3, -8
 2150              		.cfi_offset 14, -4
 971:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 2151              		.loc 1 971 5 view .LVU604
 2152 0002 FFF7FEFF 		bl	clear_keys
 2153              	.LVL216:
 972:quantum/action.c **** }
 2154              		.loc 1 972 5 is_stmt 1 view .LVU605
 973:quantum/action.c **** 
 2155              		.loc 1 973 1 is_stmt 0 view .LVU606
 2156 0006 BDE80840 		pop	{r3, lr}
 2157              		.cfi_restore 14
 2158              		.cfi_restore 3
 2159              		.cfi_def_cfa_offset 0
 972:quantum/action.c **** }
 2160              		.loc 1 972 5 view .LVU607
 2161 000a FFF7FEBF 		b	clear_keyboard_but_mods_and_keys
 2162              	.LVL217:
 2163              		.cfi_endproc
 2164              	.LFE355:
 2166              		.section	.text.clear_keyboard,"ax",%progbits
 2167              		.align	1
 2168              		.global	clear_keyboard
 2169              		.syntax unified
 2170              		.thumb
 2171              		.thumb_func
 2172              		.fpu fpv4-sp-d16
 2174              	clear_keyboard:
 2175              	.LFB354:
 961:quantum/action.c ****     clear_mods();
 2176              		.loc 1 961 27 is_stmt 1 view -0
 2177              		.cfi_startproc
 2178              		@ args = 0, pretend = 0, frame = 0
 2179              		@ frame_needed = 0, uses_anonymous_args = 0
 962:quantum/action.c ****     clear_keyboard_but_mods();
 2180              		.loc 1 962 5 view .LVU609
 961:quantum/action.c ****     clear_mods();
 2181              		.loc 1 961 27 is_stmt 0 view .LVU610
 2182 0000 08B5     		push	{r3, lr}
 2183              		.cfi_def_cfa_offset 8
 2184              		.cfi_offset 3, -8
 2185              		.cfi_offset 14, -4
 962:quantum/action.c ****     clear_keyboard_but_mods();
 2186              		.loc 1 962 5 view .LVU611
 2187 0002 FFF7FEFF 		bl	clear_mods
 2188              	.LVL218:
 963:quantum/action.c **** }
 2189              		.loc 1 963 5 is_stmt 1 view .LVU612
 964:quantum/action.c **** 
 2190              		.loc 1 964 1 is_stmt 0 view .LVU613
 2191 0006 BDE80840 		pop	{r3, lr}
 2192              		.cfi_restore 14
 2193              		.cfi_restore 3
 2194              		.cfi_def_cfa_offset 0
 963:quantum/action.c **** }
 2195              		.loc 1 963 5 view .LVU614
 2196 000a FFF7FEBF 		b	clear_keyboard_but_mods
 2197              	.LVL219:
 2198              		.cfi_endproc
 2199              	.LFE354:
 2201              		.section	.text.is_tap_action,"ax",%progbits
 2202              		.align	1
 2203              		.global	is_tap_action
 2204              		.syntax unified
 2205              		.thumb
 2206              		.thumb_func
 2207              		.fpu fpv4-sp-d16
 2209              	is_tap_action:
 2210              	.LVL220:
 2211              	.LFB359:
 992:quantum/action.c **** 
 993:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:quantum/action.c ****  *
 995:quantum/action.c ****  * FIXME: Needs documentation.
 996:quantum/action.c ****  */
 997:quantum/action.c **** bool is_tap_key(keypos_t key) {
 998:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 999:quantum/action.c ****     return is_tap_action(action);
1000:quantum/action.c **** }
1001:quantum/action.c **** 
1002:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1003:quantum/action.c ****  *
1004:quantum/action.c ****  * FIXME: Needs documentation.
1005:quantum/action.c ****  */
1006:quantum/action.c **** bool is_tap_record(keyrecord_t *record) {
1007:quantum/action.c **** #ifdef COMBO_ENABLE
1008:quantum/action.c ****     action_t action;
1009:quantum/action.c ****     if (record->keycode) {
1010:quantum/action.c ****         action = action_for_keycode(record->keycode);
1011:quantum/action.c ****     } else {
1012:quantum/action.c ****         action = layer_switch_get_action(record->event.key);
1013:quantum/action.c ****     }
1014:quantum/action.c **** #else
1015:quantum/action.c ****     action_t action = layer_switch_get_action(record->event.key);
1016:quantum/action.c **** #endif
1017:quantum/action.c ****     return is_tap_action(action);
1018:quantum/action.c **** }
1019:quantum/action.c **** 
1020:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1021:quantum/action.c ****  *
1022:quantum/action.c ****  * FIXME: Needs documentation.
1023:quantum/action.c ****  */
1024:quantum/action.c **** bool is_tap_action(action_t action) {
 2212              		.loc 1 1024 37 is_stmt 1 view -0
 2213              		.cfi_startproc
 2214              		@ args = 0, pretend = 0, frame = 0
 2215              		@ frame_needed = 0, uses_anonymous_args = 0
 2216              		@ link register save eliminated.
1025:quantum/action.c ****     switch (action.kind.id) {
 2217              		.loc 1 1025 5 is_stmt 0 view .LVU616
 2218 0000 C0F30332 		ubfx	r2, r0, #12, #4
 2219 0004 023A     		subs	r2, r2, #2
 2220 0006 C3B2     		uxtb	r3, r0
 2221              	.LVL221:
 2222              		.loc 1 1025 5 is_stmt 1 view .LVU617
 2223 0008 0D2A     		cmp	r2, #13
 2224 000a 1CD8     		bhi	.L218
 2225 000c DFE802F0 		tbb	[pc, r2]
 2226              	.L214:
 2227 0010 07       		.byte	(.L215-.L214)/2
 2228 0011 07       		.byte	(.L215-.L214)/2
 2229 0012 1B       		.byte	(.L218-.L214)/2
 2230 0013 1B       		.byte	(.L218-.L214)/2
 2231 0014 14       		.byte	(.L216-.L214)/2
 2232 0015 1B       		.byte	(.L218-.L214)/2
 2233 0016 1B       		.byte	(.L218-.L214)/2
 2234 0017 1B       		.byte	(.L218-.L214)/2
 2235 0018 07       		.byte	(.L215-.L214)/2
 2236 0019 07       		.byte	(.L215-.L214)/2
 2237 001a 18       		.byte	(.L213-.L214)/2
 2238 001b 1B       		.byte	(.L218-.L214)/2
 2239 001c 1B       		.byte	(.L218-.L214)/2
 2240 001d 18       		.byte	(.L213-.L214)/2
 2241              		.p2align 1
 2242              	.L215:
1026:quantum/action.c ****         case ACT_LMODS_TAP:
1027:quantum/action.c ****         case ACT_RMODS_TAP:
1028:quantum/action.c ****         case ACT_LAYER_TAP:
1029:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
1030:quantum/action.c ****             switch (action.layer_tap.code) {
 2243              		.loc 1 1030 13 view .LVU618
 2244 001e F02B     		cmp	r3, #240
 2245 0020 13D0     		beq	.L220
 2246 0022 04D8     		bhi	.L217
 2247 0024 E72B     		cmp	r3, #231
 2248 0026 8CBF     		ite	hi
 2249 0028 0020     		movhi	r0, #0
 2250              	.LVL222:
 2251              		.loc 1 1030 13 is_stmt 0 view .LVU619
 2252 002a 0120     		movls	r0, #1
 2253 002c 7047     		bx	lr
 2254              	.LVL223:
 2255              	.L217:
 2256              		.loc 1 1030 13 view .LVU620
 2257 002e F42B     		cmp	r3, #244
 2258              	.L221:
 2259 0030 14BF     		ite	ne
 2260 0032 0020     		movne	r0, #0
 2261              	.LVL224:
 2262              		.loc 1 1030 13 view .LVU621
 2263 0034 0120     		moveq	r0, #1
 2264 0036 7047     		bx	lr
 2265              	.LVL225:
 2266              	.L216:
1031:quantum/action.c ****                 case KC_NO ... KC_RGUI:
1032:quantum/action.c ****                 case OP_TAP_TOGGLE:
1033:quantum/action.c ****                 case OP_ONESHOT:
1034:quantum/action.c ****                     return true;
1035:quantum/action.c ****             }
1036:quantum/action.c ****             return false;
1037:quantum/action.c ****         case ACT_SWAP_HANDS:
1038:quantum/action.c ****             switch (action.swap.code) {
 2267              		.loc 1 1038 13 is_stmt 1 view .LVU622
 2268 0038 E72B     		cmp	r3, #231
 2269 003a 06D9     		bls	.L220
 2270 003c F12B     		cmp	r3, #241
 2271 003e F7E7     		b	.L221
 2272              	.L213:
1039:quantum/action.c ****                 case KC_NO ... KC_RGUI:
1040:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
1041:quantum/action.c ****                     return true;
1042:quantum/action.c ****             }
1043:quantum/action.c ****             return false;
1044:quantum/action.c ****         case ACT_MACRO:
1045:quantum/action.c ****         case ACT_FUNCTION:
1046:quantum/action.c ****             if (action.func.opt & FUNC_TAP) {
 2273              		.loc 1 1046 13 view .LVU623
 2274              		.loc 1 1046 16 is_stmt 0 view .LVU624
 2275 0040 C0F3C020 		ubfx	r0, r0, #11, #1
 2276              	.LVL226:
 2277              		.loc 1 1046 16 view .LVU625
 2278 0044 7047     		bx	lr
 2279              	.LVL227:
 2280              	.L218:
1025:quantum/action.c ****         case ACT_LMODS_TAP:
 2281              		.loc 1 1025 5 view .LVU626
 2282 0046 0020     		movs	r0, #0
 2283              	.LVL228:
1025:quantum/action.c ****         case ACT_LMODS_TAP:
 2284              		.loc 1 1025 5 view .LVU627
 2285 0048 7047     		bx	lr
 2286              	.LVL229:
 2287              	.L220:
1034:quantum/action.c ****             }
 2288              		.loc 1 1034 28 view .LVU628
 2289 004a 0120     		movs	r0, #1
 2290              	.LVL230:
1047:quantum/action.c ****                 return true;
1048:quantum/action.c ****             }
1049:quantum/action.c ****             return false;
1050:quantum/action.c ****     }
1051:quantum/action.c ****     return false;
1052:quantum/action.c **** }
 2291              		.loc 1 1052 1 view .LVU629
 2292 004c 7047     		bx	lr
 2293              		.cfi_endproc
 2294              	.LFE359:
 2296              		.section	.text.is_tap_key,"ax",%progbits
 2297              		.align	1
 2298              		.global	is_tap_key
 2299              		.syntax unified
 2300              		.thumb
 2301              		.thumb_func
 2302              		.fpu fpv4-sp-d16
 2304              	is_tap_key:
 2305              	.LFB357:
 997:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 2306              		.loc 1 997 31 is_stmt 1 view -0
 2307              		.cfi_startproc
 2308              		@ args = 0, pretend = 0, frame = 8
 2309              		@ frame_needed = 0, uses_anonymous_args = 0
 998:quantum/action.c ****     return is_tap_action(action);
 2310              		.loc 1 998 5 view .LVU631
 997:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 2311              		.loc 1 997 31 is_stmt 0 view .LVU632
 2312 0000 07B5     		push	{r0, r1, r2, lr}
 2313              		.cfi_def_cfa_offset 16
 2314              		.cfi_offset 14, -4
 997:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 2315              		.loc 1 997 31 view .LVU633
 2316 0002 ADF80400 		strh	r0, [sp, #4]	@ movhi
 998:quantum/action.c ****     return is_tap_action(action);
 2317              		.loc 1 998 23 view .LVU634
 2318 0006 0198     		ldr	r0, [sp, #4]
 2319 0008 FFF7FEFF 		bl	layer_switch_get_action
 2320              	.LVL231:
 999:quantum/action.c **** }
 2321              		.loc 1 999 5 is_stmt 1 view .LVU635
1000:quantum/action.c **** 
 2322              		.loc 1 1000 1 is_stmt 0 view .LVU636
 2323 000c 03B0     		add	sp, sp, #12
 2324              		.cfi_def_cfa_offset 4
 2325              		@ sp needed
 2326 000e 5DF804EB 		ldr	lr, [sp], #4
 2327              		.cfi_restore 14
 2328              		.cfi_def_cfa_offset 0
 999:quantum/action.c **** }
 2329              		.loc 1 999 12 view .LVU637
 2330 0012 FFF7FEBF 		b	is_tap_action
 2331              	.LVL232:
 2332              		.cfi_endproc
 2333              	.LFE357:
 2335              		.section	.text.is_tap_record,"ax",%progbits
 2336              		.align	1
 2337              		.global	is_tap_record
 2338              		.syntax unified
 2339              		.thumb
 2340              		.thumb_func
 2341              		.fpu fpv4-sp-d16
 2343              	is_tap_record:
 2344              	.LVL233:
 2345              	.LFB358:
1006:quantum/action.c **** #ifdef COMBO_ENABLE
 2346              		.loc 1 1006 41 is_stmt 1 view -0
 2347              		.cfi_startproc
 2348              		@ args = 0, pretend = 0, frame = 0
 2349              		@ frame_needed = 0, uses_anonymous_args = 0
1015:quantum/action.c **** #endif
 2350              		.loc 1 1015 5 view .LVU639
1006:quantum/action.c **** #ifdef COMBO_ENABLE
 2351              		.loc 1 1006 41 is_stmt 0 view .LVU640
 2352 0000 08B5     		push	{r3, lr}
 2353              		.cfi_def_cfa_offset 8
 2354              		.cfi_offset 3, -8
 2355              		.cfi_offset 14, -4
1015:quantum/action.c **** #endif
 2356              		.loc 1 1015 23 view .LVU641
 2357 0002 0088     		ldrh	r0, [r0]
 2358              	.LVL234:
1015:quantum/action.c **** #endif
 2359              		.loc 1 1015 23 view .LVU642
 2360 0004 FFF7FEFF 		bl	layer_switch_get_action
 2361              	.LVL235:
1017:quantum/action.c **** }
 2362              		.loc 1 1017 5 is_stmt 1 view .LVU643
1018:quantum/action.c **** 
 2363              		.loc 1 1018 1 is_stmt 0 view .LVU644
 2364 0008 BDE80840 		pop	{r3, lr}
 2365              		.cfi_restore 14
 2366              		.cfi_restore 3
 2367              		.cfi_def_cfa_offset 0
1017:quantum/action.c **** }
 2368              		.loc 1 1017 12 view .LVU645
 2369 000c FFF7FEBF 		b	is_tap_action
 2370              	.LVL236:
 2371              		.cfi_endproc
 2372              	.LFE358:
 2374              		.section	.text.debug_event,"ax",%progbits
 2375              		.align	1
 2376              		.global	debug_event
 2377              		.syntax unified
 2378              		.thumb
 2379              		.thumb_func
 2380              		.fpu fpv4-sp-d16
 2382              	debug_event:
 2383              	.LFB360:
1053:quantum/action.c **** 
1054:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1055:quantum/action.c ****  *
1056:quantum/action.c ****  * FIXME: Needs documentation.
1057:quantum/action.c ****  */
1058:quantum/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2384              		.loc 1 1058 36 is_stmt 1 view -0
 2385              		.cfi_startproc
 2386              		@ args = 0, pretend = 0, frame = 8
 2387              		@ frame_needed = 0, uses_anonymous_args = 0
 2388              		@ link register save eliminated.
 2389              		.loc 1 1058 138 view .LVU647
 2390              		.loc 1 1058 36 is_stmt 0 view .LVU648
 2391 0000 82B0     		sub	sp, sp, #8
 2392              		.cfi_def_cfa_offset 8
 2393              		.loc 1 1058 36 view .LVU649
 2394 0002 02AB     		add	r3, sp, #8
 2395 0004 03E90300 		stmdb	r3, {r0, r1}
 2396              		.loc 1 1058 140 view .LVU650
 2397 0008 02B0     		add	sp, sp, #8
 2398              		.cfi_def_cfa_offset 0
 2399              		@ sp needed
 2400 000a 7047     		bx	lr
 2401              		.cfi_endproc
 2402              	.LFE360:
 2404              		.section	.text.debug_record,"ax",%progbits
 2405              		.align	1
 2406              		.global	debug_record
 2407              		.syntax unified
 2408              		.thumb
 2409              		.thumb_func
 2410              		.fpu fpv4-sp-d16
 2412              	debug_record:
 2413              	.LFB361:
1059:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1060:quantum/action.c ****  *
1061:quantum/action.c ****  * FIXME: Needs documentation.
1062:quantum/action.c ****  */
1063:quantum/action.c **** void debug_record(keyrecord_t record) {
 2414              		.loc 1 1063 39 is_stmt 1 view -0
 2415              		.cfi_startproc
 2416              		@ args = 0, pretend = 0, frame = 8
 2417              		@ frame_needed = 0, uses_anonymous_args = 0
 2418              		@ link register save eliminated.
1064:quantum/action.c ****     debug_event(record.event);
 2419              		.loc 1 1064 5 view .LVU652
1065:quantum/action.c **** #ifndef NO_ACTION_TAPPING
1066:quantum/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2420              		.loc 1 1066 77 view .LVU653
1063:quantum/action.c ****     debug_event(record.event);
 2421              		.loc 1 1063 39 is_stmt 0 view .LVU654
 2422 0000 82B0     		sub	sp, sp, #8
 2423              		.cfi_def_cfa_offset 8
1063:quantum/action.c ****     debug_event(record.event);
 2424              		.loc 1 1063 39 view .LVU655
 2425 0002 02AB     		add	r3, sp, #8
 2426 0004 03E90300 		stmdb	r3, {r0, r1}
1067:quantum/action.c **** #endif
1068:quantum/action.c **** }
 2427              		.loc 1 1068 1 view .LVU656
 2428 0008 02B0     		add	sp, sp, #8
 2429              		.cfi_def_cfa_offset 0
 2430              		@ sp needed
 2431 000a 7047     		bx	lr
 2432              		.cfi_endproc
 2433              	.LFE361:
 2435              		.section	.text.debug_action,"ax",%progbits
 2436              		.align	1
 2437              		.global	debug_action
 2438              		.syntax unified
 2439              		.thumb
 2440              		.thumb_func
 2441              		.fpu fpv4-sp-d16
 2443              	debug_action:
 2444              	.LVL237:
 2445              	.LFB362:
1069:quantum/action.c **** 
1070:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1071:quantum/action.c ****  *
1072:quantum/action.c ****  * FIXME: Needs documentation.
1073:quantum/action.c ****  */
1074:quantum/action.c **** void debug_action(action_t action) {
 2446              		.loc 1 1074 36 is_stmt 1 view -0
 2447              		.cfi_startproc
 2448              		@ args = 0, pretend = 0, frame = 0
 2449              		@ frame_needed = 0, uses_anonymous_args = 0
 2450              		@ link register save eliminated.
1075:quantum/action.c ****     switch (action.kind.id) {
 2451              		.loc 1 1075 5 view .LVU658
1076:quantum/action.c ****         case ACT_LMODS:
1077:quantum/action.c ****             dprint("ACT_LMODS");
1078:quantum/action.c ****             break;
1079:quantum/action.c ****         case ACT_RMODS:
1080:quantum/action.c ****             dprint("ACT_RMODS");
1081:quantum/action.c ****             break;
1082:quantum/action.c ****         case ACT_LMODS_TAP:
1083:quantum/action.c ****             dprint("ACT_LMODS_TAP");
1084:quantum/action.c ****             break;
1085:quantum/action.c ****         case ACT_RMODS_TAP:
1086:quantum/action.c ****             dprint("ACT_RMODS_TAP");
1087:quantum/action.c ****             break;
1088:quantum/action.c ****         case ACT_USAGE:
1089:quantum/action.c ****             dprint("ACT_USAGE");
1090:quantum/action.c ****             break;
1091:quantum/action.c ****         case ACT_MOUSEKEY:
1092:quantum/action.c ****             dprint("ACT_MOUSEKEY");
1093:quantum/action.c ****             break;
1094:quantum/action.c ****         case ACT_LAYER:
1095:quantum/action.c ****             dprint("ACT_LAYER");
1096:quantum/action.c ****             break;
1097:quantum/action.c ****         case ACT_LAYER_MODS:
1098:quantum/action.c ****             dprint("ACT_LAYER_MODS");
1099:quantum/action.c ****             break;
1100:quantum/action.c ****         case ACT_LAYER_TAP:
1101:quantum/action.c ****             dprint("ACT_LAYER_TAP");
1102:quantum/action.c ****             break;
1103:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
1104:quantum/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1105:quantum/action.c ****             break;
1106:quantum/action.c ****         case ACT_MACRO:
1107:quantum/action.c ****             dprint("ACT_MACRO");
1108:quantum/action.c ****             break;
1109:quantum/action.c ****         case ACT_FUNCTION:
1110:quantum/action.c ****             dprint("ACT_FUNCTION");
1111:quantum/action.c ****             break;
1112:quantum/action.c ****         case ACT_SWAP_HANDS:
1113:quantum/action.c ****             dprint("ACT_SWAP_HANDS");
1114:quantum/action.c ****             break;
1115:quantum/action.c ****         default:
1116:quantum/action.c ****             dprint("UNKNOWN");
1117:quantum/action.c ****             break;
1118:quantum/action.c ****     }
1119:quantum/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2452              		.loc 1 1119 75 view .LVU659
1120:quantum/action.c **** }
 2453              		.loc 1 1120 1 is_stmt 0 view .LVU660
 2454 0000 7047     		bx	lr
 2455              		.cfi_endproc
 2456              	.LFE362:
 2458              		.global	disable_action_cache
 2459              		.comm	tp_buttons,4,4
 2460              		.section	.bss.disable_action_cache,"aw",%nobits
 2461              		.set	.LANCHOR1,. + 0
 2464              	disable_action_cache:
 2465 0000 00       		.space	1
 2466              		.section	.rodata.CSWTCH.14,"a"
 2467              		.align	1
 2468              		.set	.LANCHOR0,. + 0
 2471              	CSWTCH.14:
 2472 0000 E200     		.short	226
 2473 0002 E900     		.short	233
 2474 0004 EA00     		.short	234
 2475 0006 B500     		.short	181
 2476 0008 B600     		.short	182
 2477 000a B700     		.short	183
 2478 000c CD00     		.short	205
 2479 000e 8301     		.short	387
 2480 0010 CC00     		.short	204
 2481 0012 8A01     		.short	394
 2482 0014 9201     		.short	402
 2483 0016 9401     		.short	404
 2484 0018 2102     		.short	545
 2485 001a 2302     		.short	547
 2486 001c 2402     		.short	548
 2487 001e 2502     		.short	549
 2488 0020 2602     		.short	550
 2489 0022 2702     		.short	551
 2490 0024 2A02     		.short	554
 2491 0026 B300     		.short	179
 2492 0028 B400     		.short	180
 2493 002a 6F00     		.short	111
 2494 002c 7000     		.short	112
 2495              		.text
 2496              	.Letext0:
 2497              		.file 4 "/usr/arm-none-eabi/include/machine/_default_types.h"
 2498              		.file 5 "/usr/arm-none-eabi/include/sys/_stdint.h"
 2499              		.file 6 "quantum/keycode.h"
 2500              		.file 7 "/usr/lib/gcc/arm-none-eabi/11.2.0/include/stddef.h"
 2501              		.file 8 "./lib/chibios/os/rt/include/chtime.h"
 2502              		.file 9 "quantum/action_code.h"
 2503              		.file 10 "quantum/action_macro.h"
 2504              		.file 11 "quantum/action.h"
 2505              		.file 12 "quantum/action_layer.h"
 2506              		.file 13 "quantum/action_util.h"
 2507              		.file 14 "quantum/mousekey.h"
 2508              		.file 15 "quantum/command.h"
 2509              		.file 16 "quantum/led.h"
 2510              		.file 17 "tmk_core/common/host.h"
 2511              		.file 18 "./lib/chibios/os/rt/include/chthreads.h"
 2512              		.file 19 "quantum/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/ccixSPCF.s:18     .text.pre_process_record_quantum:0000000000000000 $t
     /tmp/ccixSPCF.s:26     .text.pre_process_record_quantum:0000000000000000 pre_process_record_quantum
     /tmp/ccixSPCF.s:38     .text.action_exec:0000000000000000 $t
     /tmp/ccixSPCF.s:45     .text.action_exec:0000000000000000 action_exec
     /tmp/ccixSPCF.s:134    .text.process_record_quantum:0000000000000000 $t
     /tmp/ccixSPCF.s:141    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccixSPCF.s:159    .text.post_process_record_quantum:0000000000000000 $t
     /tmp/ccixSPCF.s:166    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
     /tmp/ccixSPCF.s:180    .text.process_record_tap_hint:0000000000000000 $t
     /tmp/ccixSPCF.s:187    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/ccixSPCF.s:206    .text.register_code:0000000000000000 $t
     /tmp/ccixSPCF.s:213    .text.register_code:0000000000000000 register_code
     /tmp/ccixSPCF.s:500    .text.register_code:0000000000000100 $d
     /tmp/ccixSPCF.s:506    .text.unregister_code:0000000000000000 $t
     /tmp/ccixSPCF.s:513    .text.unregister_code:0000000000000000 unregister_code
     /tmp/ccixSPCF.s:732    .text.tap_code_delay:0000000000000000 $t
     /tmp/ccixSPCF.s:739    .text.tap_code_delay:0000000000000000 tap_code_delay
     /tmp/ccixSPCF.s:806    .text.tap_code:0000000000000000 $t
     /tmp/ccixSPCF.s:813    .text.tap_code:0000000000000000 tap_code
     /tmp/ccixSPCF.s:833    .text.register_mods:0000000000000000 $t
     /tmp/ccixSPCF.s:840    .text.register_mods:0000000000000000 register_mods
     /tmp/ccixSPCF.s:876    .text.unregister_mods:0000000000000000 $t
     /tmp/ccixSPCF.s:883    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/ccixSPCF.s:919    .text.process_action:0000000000000000 $t
     /tmp/ccixSPCF.s:926    .text.process_action:0000000000000000 process_action
     /tmp/ccixSPCF.s:1005   .text.process_action:000000000000004e $d
     /tmp/ccixSPCF.s:1022   .text.process_action:000000000000006e $t
     /tmp/ccixSPCF.s:1848   .text.process_record:0000000000000000 process_record
     /tmp/ccixSPCF.s:1611   .text.process_action:00000000000002d6 $d
     /tmp/ccixSPCF.s:1775   .text.process_record_handler:0000000000000000 $t
     /tmp/ccixSPCF.s:1782   .text.process_record_handler:0000000000000000 process_record_handler
     /tmp/ccixSPCF.s:1841   .text.process_record:0000000000000000 $t
     /tmp/ccixSPCF.s:1953   .text.process_record_nocache:0000000000000000 $t
     /tmp/ccixSPCF.s:1960   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/ccixSPCF.s:1989   .text.process_record_nocache:0000000000000014 $d
     /tmp/ccixSPCF.s:1994   .text.register_weak_mods:0000000000000000 $t
     /tmp/ccixSPCF.s:2001   .text.register_weak_mods:0000000000000000 register_weak_mods
     /tmp/ccixSPCF.s:2037   .text.unregister_weak_mods:0000000000000000 $t
     /tmp/ccixSPCF.s:2044   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
     /tmp/ccixSPCF.s:2080   .text.clear_keyboard_but_mods_and_keys:0000000000000000 $t
     /tmp/ccixSPCF.s:2087   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
     /tmp/ccixSPCF.s:2132   .text.clear_keyboard_but_mods:0000000000000000 $t
     /tmp/ccixSPCF.s:2139   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/ccixSPCF.s:2167   .text.clear_keyboard:0000000000000000 $t
     /tmp/ccixSPCF.s:2174   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/ccixSPCF.s:2202   .text.is_tap_action:0000000000000000 $t
     /tmp/ccixSPCF.s:2209   .text.is_tap_action:0000000000000000 is_tap_action
     /tmp/ccixSPCF.s:2227   .text.is_tap_action:0000000000000010 $d
     /tmp/ccixSPCF.s:2241   .text.is_tap_action:000000000000001e $t
     /tmp/ccixSPCF.s:2297   .text.is_tap_key:0000000000000000 $t
     /tmp/ccixSPCF.s:2304   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/ccixSPCF.s:2336   .text.is_tap_record:0000000000000000 $t
     /tmp/ccixSPCF.s:2343   .text.is_tap_record:0000000000000000 is_tap_record
     /tmp/ccixSPCF.s:2375   .text.debug_event:0000000000000000 $t
     /tmp/ccixSPCF.s:2382   .text.debug_event:0000000000000000 debug_event
     /tmp/ccixSPCF.s:2405   .text.debug_record:0000000000000000 $t
     /tmp/ccixSPCF.s:2412   .text.debug_record:0000000000000000 debug_record
     /tmp/ccixSPCF.s:2436   .text.debug_action:0000000000000000 $t
     /tmp/ccixSPCF.s:2443   .text.debug_action:0000000000000000 debug_action
     /tmp/ccixSPCF.s:2464   .bss.disable_action_cache:0000000000000000 disable_action_cache
                            *COM*:0000000000000004 tp_buttons
     /tmp/ccixSPCF.s:2465   .bss.disable_action_cache:0000000000000000 $d
     /tmp/ccixSPCF.s:2467   .rodata.CSWTCH.14:0000000000000000 $d
     /tmp/ccixSPCF.s:2471   .rodata.CSWTCH.14:0000000000000000 CSWTCH.14
     /tmp/ccixSPCF.s:1616   .text.process_action:00000000000002db $d
     /tmp/ccixSPCF.s:1616   .text.process_action:00000000000002dc $t

UNDEFINED SYMBOLS
clear_weak_mods
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
chThdSleep
del_key
command_proc
is_key_pressed
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
keyboard_report
del_mods
mousekey_off
is_oneshot_layer_active
clear_oneshot_layer_state
add_weak_mods
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
