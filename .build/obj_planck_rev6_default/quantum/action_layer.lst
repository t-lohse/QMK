   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 2
  13              		.file	"action_layer.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.default_layer_state_set_user,"ax",%progbits
  18              		.align	1
  19              		.weak	default_layer_state_set_user
  20              		.arch armv7e-m
  21              		.syntax unified
  22              		.thumb
  23              		.thumb_func
  24              		.fpu fpv4-sp-d16
  26              	default_layer_state_set_user:
  27              	.LVL0:
  28              	.LFB3:
  29              		.file 1 "quantum/action_layer.c"
   1:quantum/action_layer.c **** #include <stdint.h>
   2:quantum/action_layer.c **** #include "keyboard.h"
   3:quantum/action_layer.c **** #include "action.h"
   4:quantum/action_layer.c **** #include "util.h"
   5:quantum/action_layer.c **** #include "action_layer.h"
   6:quantum/action_layer.c **** 
   7:quantum/action_layer.c **** #ifdef DEBUG_ACTION
   8:quantum/action_layer.c **** #    include "debug.h"
   9:quantum/action_layer.c **** #else
  10:quantum/action_layer.c **** #    include "nodebug.h"
  11:quantum/action_layer.c **** #endif
  12:quantum/action_layer.c **** 
  13:quantum/action_layer.c **** /** \brief Default Layer State
  14:quantum/action_layer.c ****  */
  15:quantum/action_layer.c **** layer_state_t default_layer_state = 0;
  16:quantum/action_layer.c **** 
  17:quantum/action_layer.c **** /** \brief Default Layer State Set At user Level
  18:quantum/action_layer.c ****  *
  19:quantum/action_layer.c ****  * Run user code on default layer state change
  20:quantum/action_layer.c ****  */
  21:quantum/action_layer.c **** __attribute__((weak)) layer_state_t default_layer_state_set_user(layer_state_t state) { return stat
  30              		.loc 1 21 87 view -0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 0
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              		@ link register save eliminated.
  35              		.loc 1 21 89 view .LVU1
  36              		.loc 1 21 103 is_stmt 0 view .LVU2
  37 0000 7047     		bx	lr
  38              		.cfi_endproc
  39              	.LFE3:
  41              		.section	.text.default_layer_state_set_kb,"ax",%progbits
  42              		.align	1
  43              		.weak	default_layer_state_set_kb
  44              		.syntax unified
  45              		.thumb
  46              		.thumb_func
  47              		.fpu fpv4-sp-d16
  49              	default_layer_state_set_kb:
  50              	.LVL1:
  51              	.LFB4:
  22:quantum/action_layer.c **** 
  23:quantum/action_layer.c **** /** \brief Default Layer State Set At Keyboard Level
  24:quantum/action_layer.c ****  *
  25:quantum/action_layer.c ****  *  Run keyboard code on default layer state change
  26:quantum/action_layer.c ****  */
  27:quantum/action_layer.c **** __attribute__((weak)) layer_state_t default_layer_state_set_kb(layer_state_t state) { return defaul
  52              		.loc 1 27 85 is_stmt 1 view -0
  53              		.cfi_startproc
  54              		@ args = 0, pretend = 0, frame = 0
  55              		@ frame_needed = 0, uses_anonymous_args = 0
  56              		.loc 1 27 87 view .LVU4
  57              		.loc 1 27 85 is_stmt 0 view .LVU5
  58 0000 08B5     		push	{r3, lr}
  59              		.cfi_def_cfa_offset 8
  60              		.cfi_offset 3, -8
  61              		.cfi_offset 14, -4
  62              		.loc 1 27 94 view .LVU6
  63 0002 FFF7FEFF 		bl	default_layer_state_set_user
  64              	.LVL2:
  65              		.loc 1 27 131 view .LVU7
  66 0006 08BD     		pop	{r3, pc}
  67              		.cfi_endproc
  68              	.LFE4:
  70              		.section	.text.default_layer_state_set,"ax",%progbits
  71              		.align	1
  72              		.syntax unified
  73              		.thumb
  74              		.thumb_func
  75              		.fpu fpv4-sp-d16
  77              	default_layer_state_set:
  78              	.LVL3:
  79              	.LFB5:
  28:quantum/action_layer.c **** 
  29:quantum/action_layer.c **** /** \brief Default Layer State Set
  30:quantum/action_layer.c ****  *
  31:quantum/action_layer.c ****  * Static function to set the default layer state, prints debug info and clears keys
  32:quantum/action_layer.c ****  */
  33:quantum/action_layer.c **** static void default_layer_state_set(layer_state_t state) {
  80              		.loc 1 33 58 is_stmt 1 view -0
  81              		.cfi_startproc
  82              		@ args = 0, pretend = 0, frame = 0
  83              		@ frame_needed = 0, uses_anonymous_args = 0
  34:quantum/action_layer.c ****     state = default_layer_state_set_kb(state);
  84              		.loc 1 34 5 view .LVU9
  33:quantum/action_layer.c ****     state = default_layer_state_set_kb(state);
  85              		.loc 1 33 58 is_stmt 0 view .LVU10
  86 0000 08B5     		push	{r3, lr}
  87              		.cfi_def_cfa_offset 8
  88              		.cfi_offset 3, -8
  89              		.cfi_offset 14, -4
  90              		.loc 1 34 13 view .LVU11
  91 0002 FFF7FEFF 		bl	default_layer_state_set_kb
  92              	.LVL4:
  35:quantum/action_layer.c ****     debug("default_layer_state: ");
  93              		.loc 1 35 35 is_stmt 1 view .LVU12
  36:quantum/action_layer.c ****     default_layer_debug();
  94              		.loc 1 36 5 view .LVU13
  37:quantum/action_layer.c ****     debug(" to ");
  95              		.loc 1 37 18 view .LVU14
  38:quantum/action_layer.c ****     default_layer_state = state;
  96              		.loc 1 38 5 view .LVU15
  97              		.loc 1 38 25 is_stmt 0 view .LVU16
  98 0006 034B     		ldr	r3, .L4
  99 0008 1860     		str	r0, [r3]
  39:quantum/action_layer.c ****     default_layer_debug();
 100              		.loc 1 39 5 is_stmt 1 view .LVU17
  40:quantum/action_layer.c ****     debug("\n");
 101              		.loc 1 40 16 view .LVU18
  41:quantum/action_layer.c **** #ifdef STRICT_LAYER_RELEASE
  42:quantum/action_layer.c ****     clear_keyboard_but_mods();  // To avoid stuck keys
  43:quantum/action_layer.c **** #else
  44:quantum/action_layer.c ****     clear_keyboard_but_mods_and_keys();  // Don't reset held keys
 102              		.loc 1 44 5 view .LVU19
  45:quantum/action_layer.c **** #endif
  46:quantum/action_layer.c **** }
 103              		.loc 1 46 1 is_stmt 0 view .LVU20
 104 000a BDE80840 		pop	{r3, lr}
 105              		.cfi_restore 14
 106              		.cfi_restore 3
 107              		.cfi_def_cfa_offset 0
  44:quantum/action_layer.c **** #endif
 108              		.loc 1 44 5 view .LVU21
 109 000e FFF7FEBF 		b	clear_keyboard_but_mods_and_keys
 110              	.LVL5:
 111              	.L5:
  44:quantum/action_layer.c **** #endif
 112              		.loc 1 44 5 view .LVU22
 113 0012 00BF     		.align	2
 114              	.L4:
 115 0014 00000000 		.word	.LANCHOR0
 116              		.cfi_endproc
 117              	.LFE5:
 119              		.section	.text.default_layer_debug,"ax",%progbits
 120              		.align	1
 121              		.global	default_layer_debug
 122              		.syntax unified
 123              		.thumb
 124              		.thumb_func
 125              		.fpu fpv4-sp-d16
 127              	default_layer_debug:
 128              	.LFB6:
  47:quantum/action_layer.c **** 
  48:quantum/action_layer.c **** /** \brief Default Layer Print
  49:quantum/action_layer.c ****  *
  50:quantum/action_layer.c ****  * Print out the hex value of the 32-bit default layer state, as well as the value of the highest b
  51:quantum/action_layer.c ****  */
  52:quantum/action_layer.c **** void default_layer_debug(void) { dprintf("%08lX(%u)", default_layer_state, get_highest_layer(defaul
 129              		.loc 1 52 32 is_stmt 1 view -0
 130              		.cfi_startproc
 131              		@ args = 0, pretend = 0, frame = 0
 132              		@ frame_needed = 0, uses_anonymous_args = 0
 133              		@ link register save eliminated.
 134              		.loc 1 52 115 view .LVU24
 135              		.loc 1 52 117 is_stmt 0 view .LVU25
 136 0000 7047     		bx	lr
 137              		.cfi_endproc
 138              	.LFE6:
 140              		.section	.text.default_layer_set,"ax",%progbits
 141              		.align	1
 142              		.global	default_layer_set
 143              		.syntax unified
 144              		.thumb
 145              		.thumb_func
 146              		.fpu fpv4-sp-d16
 148              	default_layer_set:
 149              	.LVL6:
 150              	.LFB7:
  53:quantum/action_layer.c **** 
  54:quantum/action_layer.c **** /** \brief Default Layer Set
  55:quantum/action_layer.c ****  *
  56:quantum/action_layer.c ****  * Sets the default layer state.
  57:quantum/action_layer.c ****  */
  58:quantum/action_layer.c **** void default_layer_set(layer_state_t state) { default_layer_state_set(state); }
 151              		.loc 1 58 45 is_stmt 1 view -0
 152              		.cfi_startproc
 153              		@ args = 0, pretend = 0, frame = 0
 154              		@ frame_needed = 0, uses_anonymous_args = 0
 155              		@ link register save eliminated.
 156              		.loc 1 58 47 view .LVU27
 157 0000 FFF7FEBF 		b	default_layer_state_set
 158              	.LVL7:
 159              		.loc 1 58 47 is_stmt 0 view .LVU28
 160              		.cfi_endproc
 161              	.LFE7:
 163              		.section	.text.default_layer_or,"ax",%progbits
 164              		.align	1
 165              		.global	default_layer_or
 166              		.syntax unified
 167              		.thumb
 168              		.thumb_func
 169              		.fpu fpv4-sp-d16
 171              	default_layer_or:
 172              	.LVL8:
 173              	.LFB8:
  59:quantum/action_layer.c **** 
  60:quantum/action_layer.c **** #ifndef NO_ACTION_LAYER
  61:quantum/action_layer.c **** /** \brief Default Layer Or
  62:quantum/action_layer.c ****  *
  63:quantum/action_layer.c ****  * Turns on the default layer based on matching bits between specifed layer and existing layer stat
  64:quantum/action_layer.c ****  */
  65:quantum/action_layer.c **** void default_layer_or(layer_state_t state) { default_layer_state_set(default_layer_state | state); 
 174              		.loc 1 65 44 is_stmt 1 view -0
 175              		.cfi_startproc
 176              		@ args = 0, pretend = 0, frame = 0
 177              		@ frame_needed = 0, uses_anonymous_args = 0
 178              		@ link register save eliminated.
 179              		.loc 1 65 46 view .LVU30
 180 0000 024B     		ldr	r3, .L9
 181 0002 1B68     		ldr	r3, [r3]
 182 0004 1843     		orrs	r0, r0, r3
 183              	.LVL9:
 184              		.loc 1 65 46 is_stmt 0 view .LVU31
 185 0006 FFF7FEBF 		b	default_layer_state_set
 186              	.LVL10:
 187              	.L10:
 188 000a 00BF     		.align	2
 189              	.L9:
 190 000c 00000000 		.word	.LANCHOR0
 191              		.cfi_endproc
 192              	.LFE8:
 194              		.section	.text.default_layer_and,"ax",%progbits
 195              		.align	1
 196              		.global	default_layer_and
 197              		.syntax unified
 198              		.thumb
 199              		.thumb_func
 200              		.fpu fpv4-sp-d16
 202              	default_layer_and:
 203              	.LVL11:
 204              	.LFB9:
  66:quantum/action_layer.c **** /** \brief Default Layer And
  67:quantum/action_layer.c ****  *
  68:quantum/action_layer.c ****  * Turns on default layer based on matching enabled bits between specifed layer and existing layer 
  69:quantum/action_layer.c ****  */
  70:quantum/action_layer.c **** void default_layer_and(layer_state_t state) { default_layer_state_set(default_layer_state & state);
 205              		.loc 1 70 45 is_stmt 1 view -0
 206              		.cfi_startproc
 207              		@ args = 0, pretend = 0, frame = 0
 208              		@ frame_needed = 0, uses_anonymous_args = 0
 209              		@ link register save eliminated.
 210              		.loc 1 70 47 view .LVU33
 211 0000 024B     		ldr	r3, .L12
 212 0002 1B68     		ldr	r3, [r3]
 213 0004 1840     		ands	r0, r0, r3
 214              	.LVL12:
 215              		.loc 1 70 47 is_stmt 0 view .LVU34
 216 0006 FFF7FEBF 		b	default_layer_state_set
 217              	.LVL13:
 218              	.L13:
 219 000a 00BF     		.align	2
 220              	.L12:
 221 000c 00000000 		.word	.LANCHOR0
 222              		.cfi_endproc
 223              	.LFE9:
 225              		.section	.text.default_layer_xor,"ax",%progbits
 226              		.align	1
 227              		.global	default_layer_xor
 228              		.syntax unified
 229              		.thumb
 230              		.thumb_func
 231              		.fpu fpv4-sp-d16
 233              	default_layer_xor:
 234              	.LVL14:
 235              	.LFB10:
  71:quantum/action_layer.c **** /** \brief Default Layer Xor
  72:quantum/action_layer.c ****  *
  73:quantum/action_layer.c ****  * Turns on default layer based on non-matching bits between specifed layer and existing layer stat
  74:quantum/action_layer.c ****  */
  75:quantum/action_layer.c **** void default_layer_xor(layer_state_t state) { default_layer_state_set(default_layer_state ^ state);
 236              		.loc 1 75 45 is_stmt 1 view -0
 237              		.cfi_startproc
 238              		@ args = 0, pretend = 0, frame = 0
 239              		@ frame_needed = 0, uses_anonymous_args = 0
 240              		@ link register save eliminated.
 241              		.loc 1 75 47 view .LVU36
 242 0000 024B     		ldr	r3, .L15
 243 0002 1B68     		ldr	r3, [r3]
 244 0004 5840     		eors	r0, r0, r3
 245              	.LVL15:
 246              		.loc 1 75 47 is_stmt 0 view .LVU37
 247 0006 FFF7FEBF 		b	default_layer_state_set
 248              	.LVL16:
 249              	.L16:
 250 000a 00BF     		.align	2
 251              	.L15:
 252 000c 00000000 		.word	.LANCHOR0
 253              		.cfi_endproc
 254              	.LFE10:
 256              		.section	.text.layer_state_set_user,"ax",%progbits
 257              		.align	1
 258              		.weak	layer_state_set_user
 259              		.syntax unified
 260              		.thumb
 261              		.thumb_func
 262              		.fpu fpv4-sp-d16
 264              	layer_state_set_user:
 265              	.LFB33:
 266              		.cfi_startproc
 267              		@ args = 0, pretend = 0, frame = 0
 268              		@ frame_needed = 0, uses_anonymous_args = 0
 269              		@ link register save eliminated.
 270 0000 7047     		bx	lr
 271              		.cfi_endproc
 272              	.LFE33:
 274              		.section	.text.layer_state_set_kb,"ax",%progbits
 275              		.align	1
 276              		.weak	layer_state_set_kb
 277              		.syntax unified
 278              		.thumb
 279              		.thumb_func
 280              		.fpu fpv4-sp-d16
 282              	layer_state_set_kb:
 283              	.LVL17:
 284              	.LFB12:
  76:quantum/action_layer.c **** #endif
  77:quantum/action_layer.c **** 
  78:quantum/action_layer.c **** #ifndef NO_ACTION_LAYER
  79:quantum/action_layer.c **** /** \brief Keymap Layer State
  80:quantum/action_layer.c ****  */
  81:quantum/action_layer.c **** layer_state_t layer_state = 0;
  82:quantum/action_layer.c **** 
  83:quantum/action_layer.c **** /** \brief Layer state set user
  84:quantum/action_layer.c ****  *
  85:quantum/action_layer.c ****  * Runs user code on layer state change
  86:quantum/action_layer.c ****  */
  87:quantum/action_layer.c **** __attribute__((weak)) layer_state_t layer_state_set_user(layer_state_t state) { return state; }
  88:quantum/action_layer.c **** 
  89:quantum/action_layer.c **** /** \brief Layer state set keyboard
  90:quantum/action_layer.c ****  *
  91:quantum/action_layer.c ****  * Runs keyboard code on layer state change
  92:quantum/action_layer.c ****  */
  93:quantum/action_layer.c **** __attribute__((weak)) layer_state_t layer_state_set_kb(layer_state_t state) { return layer_state_se
 285              		.loc 1 93 77 is_stmt 1 view -0
 286              		.cfi_startproc
 287              		@ args = 0, pretend = 0, frame = 0
 288              		@ frame_needed = 0, uses_anonymous_args = 0
 289              		.loc 1 93 79 view .LVU39
 290              		.loc 1 93 77 is_stmt 0 view .LVU40
 291 0000 08B5     		push	{r3, lr}
 292              		.cfi_def_cfa_offset 8
 293              		.cfi_offset 3, -8
 294              		.cfi_offset 14, -4
 295              		.loc 1 93 86 view .LVU41
 296 0002 FFF7FEFF 		bl	layer_state_set_user
 297              	.LVL18:
 298              		.loc 1 93 115 view .LVU42
 299 0006 08BD     		pop	{r3, pc}
 300              		.cfi_endproc
 301              	.LFE12:
 303              		.section	.text.layer_state_set,"ax",%progbits
 304              		.align	1
 305              		.global	layer_state_set
 306              		.syntax unified
 307              		.thumb
 308              		.thumb_func
 309              		.fpu fpv4-sp-d16
 311              	layer_state_set:
 312              	.LVL19:
 313              	.LFB13:
  94:quantum/action_layer.c **** 
  95:quantum/action_layer.c **** /** \brief Layer state set
  96:quantum/action_layer.c ****  *
  97:quantum/action_layer.c ****  * Sets the layer to match the specifed state (a bitmask)
  98:quantum/action_layer.c ****  */
  99:quantum/action_layer.c **** void layer_state_set(layer_state_t state) {
 314              		.loc 1 99 43 is_stmt 1 view -0
 315              		.cfi_startproc
 316              		@ args = 0, pretend = 0, frame = 0
 317              		@ frame_needed = 0, uses_anonymous_args = 0
 100:quantum/action_layer.c ****     state = layer_state_set_kb(state);
 318              		.loc 1 100 5 view .LVU44
  99:quantum/action_layer.c ****     state = layer_state_set_kb(state);
 319              		.loc 1 99 43 is_stmt 0 view .LVU45
 320 0000 08B5     		push	{r3, lr}
 321              		.cfi_def_cfa_offset 8
 322              		.cfi_offset 3, -8
 323              		.cfi_offset 14, -4
 324              		.loc 1 100 13 view .LVU46
 325 0002 FFF7FEFF 		bl	layer_state_set_kb
 326              	.LVL20:
 101:quantum/action_layer.c ****     dprint("layer_state: ");
 327              		.loc 1 101 28 is_stmt 1 view .LVU47
 102:quantum/action_layer.c ****     layer_debug();
 328              		.loc 1 102 5 view .LVU48
 103:quantum/action_layer.c ****     dprint(" to ");
 329              		.loc 1 103 19 view .LVU49
 104:quantum/action_layer.c ****     layer_state = state;
 330              		.loc 1 104 5 view .LVU50
 331              		.loc 1 104 17 is_stmt 0 view .LVU51
 332 0006 034B     		ldr	r3, .L20
 333 0008 1860     		str	r0, [r3]
 105:quantum/action_layer.c ****     layer_debug();
 334              		.loc 1 105 5 is_stmt 1 view .LVU52
 106:quantum/action_layer.c ****     dprintln();
 335              		.loc 1 106 15 view .LVU53
 107:quantum/action_layer.c **** #    ifdef STRICT_LAYER_RELEASE
 108:quantum/action_layer.c ****     clear_keyboard_but_mods();  // To avoid stuck keys
 109:quantum/action_layer.c **** #    else
 110:quantum/action_layer.c ****     clear_keyboard_but_mods_and_keys();  // Don't reset held keys
 336              		.loc 1 110 5 view .LVU54
 111:quantum/action_layer.c **** #    endif
 112:quantum/action_layer.c **** }
 337              		.loc 1 112 1 is_stmt 0 view .LVU55
 338 000a BDE80840 		pop	{r3, lr}
 339              		.cfi_restore 14
 340              		.cfi_restore 3
 341              		.cfi_def_cfa_offset 0
 110:quantum/action_layer.c **** #    endif
 342              		.loc 1 110 5 view .LVU56
 343 000e FFF7FEBF 		b	clear_keyboard_but_mods_and_keys
 344              	.LVL21:
 345              	.L21:
 110:quantum/action_layer.c **** #    endif
 346              		.loc 1 110 5 view .LVU57
 347 0012 00BF     		.align	2
 348              	.L20:
 349 0014 00000000 		.word	.LANCHOR1
 350              		.cfi_endproc
 351              	.LFE13:
 353              		.section	.text.layer_clear,"ax",%progbits
 354              		.align	1
 355              		.global	layer_clear
 356              		.syntax unified
 357              		.thumb
 358              		.thumb_func
 359              		.fpu fpv4-sp-d16
 361              	layer_clear:
 362              	.LFB14:
 113:quantum/action_layer.c **** 
 114:quantum/action_layer.c **** /** \brief Layer clear
 115:quantum/action_layer.c ****  *
 116:quantum/action_layer.c ****  * Turn off all layers
 117:quantum/action_layer.c ****  */
 118:quantum/action_layer.c **** void layer_clear(void) { layer_state_set(0); }
 363              		.loc 1 118 24 is_stmt 1 view -0
 364              		.cfi_startproc
 365              		@ args = 0, pretend = 0, frame = 0
 366              		@ frame_needed = 0, uses_anonymous_args = 0
 367              		@ link register save eliminated.
 368              		.loc 1 118 26 view .LVU59
 369 0000 0020     		movs	r0, #0
 370 0002 FFF7FEBF 		b	layer_state_set
 371              	.LVL22:
 372              		.cfi_endproc
 373              	.LFE14:
 375              		.section	.text.layer_state_is,"ax",%progbits
 376              		.align	1
 377              		.global	layer_state_is
 378              		.syntax unified
 379              		.thumb
 380              		.thumb_func
 381              		.fpu fpv4-sp-d16
 383              	layer_state_is:
 384              	.LVL23:
 385              	.LFB15:
 119:quantum/action_layer.c **** 
 120:quantum/action_layer.c **** /** \brief Layer state is
 121:quantum/action_layer.c ****  *
 122:quantum/action_layer.c ****  * Return whether the given state is on (it might still be shadowed by a higher state, though)
 123:quantum/action_layer.c ****  */
 124:quantum/action_layer.c **** bool layer_state_is(uint8_t layer) { return layer_state_cmp(layer_state, layer); }
 386              		.loc 1 124 36 view -0
 387              		.cfi_startproc
 388              		@ args = 0, pretend = 0, frame = 0
 389              		@ frame_needed = 0, uses_anonymous_args = 0
 390              		@ link register save eliminated.
 391              		.loc 1 124 38 view .LVU61
 392              		.loc 1 124 45 is_stmt 0 view .LVU62
 393 0000 054B     		ldr	r3, .L26
 394 0002 1B68     		ldr	r3, [r3]
 395              	.LVL24:
 396              	.LBB12:
 397              	.LBI12:
 125:quantum/action_layer.c **** 
 126:quantum/action_layer.c **** /** \brief Layer state compare
 127:quantum/action_layer.c ****  *
 128:quantum/action_layer.c ****  * Used for comparing layers {mostly used for unit testing}
 129:quantum/action_layer.c ****  */
 130:quantum/action_layer.c **** bool layer_state_cmp(layer_state_t cmp_layer_state, uint8_t layer) {
 398              		.loc 1 130 6 is_stmt 1 view .LVU63
 399              	.LBB13:
 131:quantum/action_layer.c ****     if (!cmp_layer_state) {
 400              		.loc 1 131 5 view .LVU64
 401              		.loc 1 131 8 is_stmt 0 view .LVU65
 402 0004 1BB9     		cbnz	r3, .L24
 132:quantum/action_layer.c ****         return layer == 0;
 403              		.loc 1 132 9 is_stmt 1 view .LVU66
 404              		.loc 1 132 22 is_stmt 0 view .LVU67
 405 0006 B0FA80F0 		clz	r0, r0
 406              	.LVL25:
 407              		.loc 1 132 22 view .LVU68
 408 000a 4009     		lsrs	r0, r0, #5
 409 000c 7047     		bx	lr
 410              	.LVL26:
 411              	.L24:
 133:quantum/action_layer.c ****     }
 134:quantum/action_layer.c ****     return (cmp_layer_state & ((layer_state_t)1 << layer)) != 0;
 412              		.loc 1 134 5 is_stmt 1 view .LVU69
 413              		.loc 1 134 60 is_stmt 0 view .LVU70
 414 000e 23FA00F0 		lsr	r0, r3, r0
 415              	.LVL27:
 416              		.loc 1 134 60 view .LVU71
 417 0012 00F00100 		and	r0, r0, #1
 418              	.LVL28:
 419              		.loc 1 134 60 view .LVU72
 420              	.LBE13:
 421              	.LBE12:
 124:quantum/action_layer.c **** 
 422              		.loc 1 124 82 view .LVU73
 423 0016 7047     		bx	lr
 424              	.L27:
 425              		.align	2
 426              	.L26:
 427 0018 00000000 		.word	.LANCHOR1
 428              		.cfi_endproc
 429              	.LFE15:
 431              		.section	.text.layer_state_cmp,"ax",%progbits
 432              		.align	1
 433              		.global	layer_state_cmp
 434              		.syntax unified
 435              		.thumb
 436              		.thumb_func
 437              		.fpu fpv4-sp-d16
 439              	layer_state_cmp:
 440              	.LVL29:
 441              	.LFB16:
 130:quantum/action_layer.c ****     if (!cmp_layer_state) {
 442              		.loc 1 130 68 is_stmt 1 view -0
 443              		.cfi_startproc
 444              		@ args = 0, pretend = 0, frame = 0
 445              		@ frame_needed = 0, uses_anonymous_args = 0
 446              		@ link register save eliminated.
 131:quantum/action_layer.c ****         return layer == 0;
 447              		.loc 1 131 5 view .LVU75
 131:quantum/action_layer.c ****         return layer == 0;
 448              		.loc 1 131 8 is_stmt 0 view .LVU76
 449 0000 18B9     		cbnz	r0, .L29
 132:quantum/action_layer.c ****     }
 450              		.loc 1 132 9 is_stmt 1 view .LVU77
 132:quantum/action_layer.c ****     }
 451              		.loc 1 132 22 is_stmt 0 view .LVU78
 452 0002 B1FA81F0 		clz	r0, r1
 453              	.LVL30:
 132:quantum/action_layer.c ****     }
 454              		.loc 1 132 22 view .LVU79
 455 0006 4009     		lsrs	r0, r0, #5
 456 0008 7047     		bx	lr
 457              	.LVL31:
 458              	.L29:
 459              		.loc 1 134 5 is_stmt 1 view .LVU80
 460              		.loc 1 134 60 is_stmt 0 view .LVU81
 461 000a 20FA01F1 		lsr	r1, r0, r1
 462              	.LVL32:
 463              		.loc 1 134 60 view .LVU82
 464 000e 01F00100 		and	r0, r1, #1
 465              	.LVL33:
 135:quantum/action_layer.c **** }
 466              		.loc 1 135 1 view .LVU83
 467 0012 7047     		bx	lr
 468              		.cfi_endproc
 469              	.LFE16:
 471              		.section	.text.layer_move,"ax",%progbits
 472              		.align	1
 473              		.global	layer_move
 474              		.syntax unified
 475              		.thumb
 476              		.thumb_func
 477              		.fpu fpv4-sp-d16
 479              	layer_move:
 480              	.LVL34:
 481              	.LFB17:
 136:quantum/action_layer.c **** 
 137:quantum/action_layer.c **** /** \brief Layer move
 138:quantum/action_layer.c ****  *
 139:quantum/action_layer.c ****  * Turns on the given layer and turn off all other layers
 140:quantum/action_layer.c ****  */
 141:quantum/action_layer.c **** void layer_move(uint8_t layer) { layer_state_set((layer_state_t)1 << layer); }
 482              		.loc 1 141 32 is_stmt 1 view -0
 483              		.cfi_startproc
 484              		@ args = 0, pretend = 0, frame = 0
 485              		@ frame_needed = 0, uses_anonymous_args = 0
 486              		@ link register save eliminated.
 487              		.loc 1 141 34 view .LVU85
 488 0000 0123     		movs	r3, #1
 489 0002 03FA00F0 		lsl	r0, r3, r0
 490              	.LVL35:
 491              		.loc 1 141 34 is_stmt 0 view .LVU86
 492 0006 FFF7FEBF 		b	layer_state_set
 493              	.LVL36:
 494              		.cfi_endproc
 495              	.LFE17:
 497              		.section	.text.layer_on,"ax",%progbits
 498              		.align	1
 499              		.global	layer_on
 500              		.syntax unified
 501              		.thumb
 502              		.thumb_func
 503              		.fpu fpv4-sp-d16
 505              	layer_on:
 506              	.LVL37:
 507              	.LFB18:
 142:quantum/action_layer.c **** 
 143:quantum/action_layer.c **** /** \brief Layer on
 144:quantum/action_layer.c ****  *
 145:quantum/action_layer.c ****  * Turns on given layer
 146:quantum/action_layer.c ****  */
 147:quantum/action_layer.c **** void layer_on(uint8_t layer) { layer_state_set(layer_state | ((layer_state_t)1 << layer)); }
 508              		.loc 1 147 30 is_stmt 1 view -0
 509              		.cfi_startproc
 510              		@ args = 0, pretend = 0, frame = 0
 511              		@ frame_needed = 0, uses_anonymous_args = 0
 512              		@ link register save eliminated.
 513              		.loc 1 147 32 view .LVU88
 514              		.loc 1 147 80 is_stmt 0 view .LVU89
 515 0000 0123     		movs	r3, #1
 516 0002 03FA00F0 		lsl	r0, r3, r0
 517              	.LVL38:
 518              		.loc 1 147 32 view .LVU90
 519 0006 024B     		ldr	r3, .L33
 520 0008 1B68     		ldr	r3, [r3]
 521 000a 1843     		orrs	r0, r0, r3
 522 000c FFF7FEBF 		b	layer_state_set
 523              	.LVL39:
 524              	.L34:
 525              		.align	2
 526              	.L33:
 527 0010 00000000 		.word	.LANCHOR1
 528              		.cfi_endproc
 529              	.LFE18:
 531              		.section	.text.layer_off,"ax",%progbits
 532              		.align	1
 533              		.global	layer_off
 534              		.syntax unified
 535              		.thumb
 536              		.thumb_func
 537              		.fpu fpv4-sp-d16
 539              	layer_off:
 540              	.LVL40:
 541              	.LFB19:
 148:quantum/action_layer.c **** 
 149:quantum/action_layer.c **** /** \brief Layer off
 150:quantum/action_layer.c ****  *
 151:quantum/action_layer.c ****  * Turns off given layer
 152:quantum/action_layer.c ****  */
 153:quantum/action_layer.c **** void layer_off(uint8_t layer) { layer_state_set(layer_state & ~((layer_state_t)1 << layer)); }
 542              		.loc 1 153 31 is_stmt 1 view -0
 543              		.cfi_startproc
 544              		@ args = 0, pretend = 0, frame = 0
 545              		@ frame_needed = 0, uses_anonymous_args = 0
 546              		@ link register save eliminated.
 547              		.loc 1 153 33 view .LVU92
 548              		.loc 1 153 82 is_stmt 0 view .LVU93
 549 0000 0123     		movs	r3, #1
 550 0002 03FA00F0 		lsl	r0, r3, r0
 551              	.LVL41:
 552              		.loc 1 153 33 view .LVU94
 553 0006 034B     		ldr	r3, .L36
 554 0008 1B68     		ldr	r3, [r3]
 555 000a 23EA0000 		bic	r0, r3, r0
 556 000e FFF7FEBF 		b	layer_state_set
 557              	.LVL42:
 558              	.L37:
 559 0012 00BF     		.align	2
 560              	.L36:
 561 0014 00000000 		.word	.LANCHOR1
 562              		.cfi_endproc
 563              	.LFE19:
 565              		.section	.text.layer_invert,"ax",%progbits
 566              		.align	1
 567              		.global	layer_invert
 568              		.syntax unified
 569              		.thumb
 570              		.thumb_func
 571              		.fpu fpv4-sp-d16
 573              	layer_invert:
 574              	.LVL43:
 575              	.LFB20:
 154:quantum/action_layer.c **** 
 155:quantum/action_layer.c **** /** \brief Layer invert
 156:quantum/action_layer.c ****  *
 157:quantum/action_layer.c ****  * Toggle the given layer (set it if it's unset, or unset it if it's set)
 158:quantum/action_layer.c ****  */
 159:quantum/action_layer.c **** void layer_invert(uint8_t layer) { layer_state_set(layer_state ^ ((layer_state_t)1 << layer)); }
 576              		.loc 1 159 34 is_stmt 1 view -0
 577              		.cfi_startproc
 578              		@ args = 0, pretend = 0, frame = 0
 579              		@ frame_needed = 0, uses_anonymous_args = 0
 580              		@ link register save eliminated.
 581              		.loc 1 159 36 view .LVU96
 582              		.loc 1 159 84 is_stmt 0 view .LVU97
 583 0000 0123     		movs	r3, #1
 584 0002 03FA00F0 		lsl	r0, r3, r0
 585              	.LVL44:
 586              		.loc 1 159 36 view .LVU98
 587 0006 024B     		ldr	r3, .L39
 588 0008 1B68     		ldr	r3, [r3]
 589 000a 5840     		eors	r0, r0, r3
 590 000c FFF7FEBF 		b	layer_state_set
 591              	.LVL45:
 592              	.L40:
 593              		.align	2
 594              	.L39:
 595 0010 00000000 		.word	.LANCHOR1
 596              		.cfi_endproc
 597              	.LFE20:
 599              		.section	.text.layer_or,"ax",%progbits
 600              		.align	1
 601              		.global	layer_or
 602              		.syntax unified
 603              		.thumb
 604              		.thumb_func
 605              		.fpu fpv4-sp-d16
 607              	layer_or:
 608              	.LVL46:
 609              	.LFB21:
 160:quantum/action_layer.c **** 
 161:quantum/action_layer.c **** /** \brief Layer or
 162:quantum/action_layer.c ****  *
 163:quantum/action_layer.c ****  * Turns on layers based on matching bits between specifed layer and existing layer state
 164:quantum/action_layer.c ****  */
 165:quantum/action_layer.c **** void layer_or(layer_state_t state) { layer_state_set(layer_state | state); }
 610              		.loc 1 165 36 is_stmt 1 view -0
 611              		.cfi_startproc
 612              		@ args = 0, pretend = 0, frame = 0
 613              		@ frame_needed = 0, uses_anonymous_args = 0
 614              		@ link register save eliminated.
 615              		.loc 1 165 38 view .LVU100
 616 0000 024B     		ldr	r3, .L42
 617 0002 1B68     		ldr	r3, [r3]
 618 0004 1843     		orrs	r0, r0, r3
 619              	.LVL47:
 620              		.loc 1 165 38 is_stmt 0 view .LVU101
 621 0006 FFF7FEBF 		b	layer_state_set
 622              	.LVL48:
 623              	.L43:
 624 000a 00BF     		.align	2
 625              	.L42:
 626 000c 00000000 		.word	.LANCHOR1
 627              		.cfi_endproc
 628              	.LFE21:
 630              		.section	.text.layer_and,"ax",%progbits
 631              		.align	1
 632              		.global	layer_and
 633              		.syntax unified
 634              		.thumb
 635              		.thumb_func
 636              		.fpu fpv4-sp-d16
 638              	layer_and:
 639              	.LVL49:
 640              	.LFB22:
 166:quantum/action_layer.c **** /** \brief Layer and
 167:quantum/action_layer.c ****  *
 168:quantum/action_layer.c ****  * Turns on layers based on matching enabled bits between specifed layer and existing layer state
 169:quantum/action_layer.c ****  */
 170:quantum/action_layer.c **** void layer_and(layer_state_t state) { layer_state_set(layer_state & state); }
 641              		.loc 1 170 37 is_stmt 1 view -0
 642              		.cfi_startproc
 643              		@ args = 0, pretend = 0, frame = 0
 644              		@ frame_needed = 0, uses_anonymous_args = 0
 645              		@ link register save eliminated.
 646              		.loc 1 170 39 view .LVU103
 647 0000 024B     		ldr	r3, .L45
 648 0002 1B68     		ldr	r3, [r3]
 649 0004 1840     		ands	r0, r0, r3
 650              	.LVL50:
 651              		.loc 1 170 39 is_stmt 0 view .LVU104
 652 0006 FFF7FEBF 		b	layer_state_set
 653              	.LVL51:
 654              	.L46:
 655 000a 00BF     		.align	2
 656              	.L45:
 657 000c 00000000 		.word	.LANCHOR1
 658              		.cfi_endproc
 659              	.LFE22:
 661              		.section	.text.layer_xor,"ax",%progbits
 662              		.align	1
 663              		.global	layer_xor
 664              		.syntax unified
 665              		.thumb
 666              		.thumb_func
 667              		.fpu fpv4-sp-d16
 669              	layer_xor:
 670              	.LVL52:
 671              	.LFB23:
 171:quantum/action_layer.c **** /** \brief Layer xor
 172:quantum/action_layer.c ****  *
 173:quantum/action_layer.c ****  * Turns on layers based on non-matching bits between specifed layer and existing layer state
 174:quantum/action_layer.c ****  */
 175:quantum/action_layer.c **** void layer_xor(layer_state_t state) { layer_state_set(layer_state ^ state); }
 672              		.loc 1 175 37 is_stmt 1 view -0
 673              		.cfi_startproc
 674              		@ args = 0, pretend = 0, frame = 0
 675              		@ frame_needed = 0, uses_anonymous_args = 0
 676              		@ link register save eliminated.
 677              		.loc 1 175 39 view .LVU106
 678 0000 024B     		ldr	r3, .L48
 679 0002 1B68     		ldr	r3, [r3]
 680 0004 5840     		eors	r0, r0, r3
 681              	.LVL53:
 682              		.loc 1 175 39 is_stmt 0 view .LVU107
 683 0006 FFF7FEBF 		b	layer_state_set
 684              	.LVL54:
 685              	.L49:
 686 000a 00BF     		.align	2
 687              	.L48:
 688 000c 00000000 		.word	.LANCHOR1
 689              		.cfi_endproc
 690              	.LFE23:
 692              		.section	.text.layer_debug,"ax",%progbits
 693              		.align	1
 694              		.global	layer_debug
 695              		.syntax unified
 696              		.thumb
 697              		.thumb_func
 698              		.fpu fpv4-sp-d16
 700              	layer_debug:
 701              	.LFB31:
 702              		.cfi_startproc
 703              		@ args = 0, pretend = 0, frame = 0
 704              		@ frame_needed = 0, uses_anonymous_args = 0
 705              		@ link register save eliminated.
 706 0000 7047     		bx	lr
 707              		.cfi_endproc
 708              	.LFE31:
 710              		.section	.text.update_source_layers_cache,"ax",%progbits
 711              		.align	1
 712              		.global	update_source_layers_cache
 713              		.syntax unified
 714              		.thumb
 715              		.thumb_func
 716              		.fpu fpv4-sp-d16
 718              	update_source_layers_cache:
 719              	.LVL55:
 720              	.LFB25:
 176:quantum/action_layer.c **** 
 177:quantum/action_layer.c **** /** \brief Layer debug printing
 178:quantum/action_layer.c ****  *
 179:quantum/action_layer.c ****  * Print out the hex value of the 32-bit layer state, as well as the value of the highest bit.
 180:quantum/action_layer.c ****  */
 181:quantum/action_layer.c **** void layer_debug(void) { dprintf("%08lX(%u)", layer_state, get_highest_layer(layer_state)); }
 182:quantum/action_layer.c **** #endif
 183:quantum/action_layer.c **** 
 184:quantum/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 185:quantum/action_layer.c **** /** \brief source layer cache
 186:quantum/action_layer.c ****  */
 187:quantum/action_layer.c **** 
 188:quantum/action_layer.c **** uint8_t source_layers_cache[(MATRIX_ROWS * MATRIX_COLS + 7) / 8][MAX_LAYER_BITS] = {{0}};
 189:quantum/action_layer.c **** 
 190:quantum/action_layer.c **** /** \brief update source layers cache
 191:quantum/action_layer.c ****  *
 192:quantum/action_layer.c ****  * Updates the cached keys when changing layers
 193:quantum/action_layer.c ****  */
 194:quantum/action_layer.c **** void update_source_layers_cache(keypos_t key, uint8_t layer) {
 721              		.loc 1 194 62 is_stmt 1 view -0
 722              		.cfi_startproc
 723              		@ args = 0, pretend = 0, frame = 8
 724              		@ frame_needed = 0, uses_anonymous_args = 0
 195:quantum/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 725              		.loc 1 195 5 view .LVU109
 726              		.loc 1 195 41 is_stmt 0 view .LVU110
 727 0000 C0F30723 		ubfx	r3, r0, #8, #8
 728 0004 03EB4303 		add	r3, r3, r3, lsl #1
 194:quantum/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 729              		.loc 1 194 62 view .LVU111
 730 0008 37B5     		push	{r0, r1, r2, r4, r5, lr}
 731              		.cfi_def_cfa_offset 24
 732              		.cfi_offset 4, -12
 733              		.cfi_offset 5, -8
 734              		.cfi_offset 14, -4
 735              		.loc 1 195 19 view .LVU112
 736 000a 00EB4300 		add	r0, r0, r3, lsl #1
 737              	.LVL56:
 196:quantum/action_layer.c ****     const uint8_t storage_row = key_number / 8;
 738              		.loc 1 196 5 is_stmt 1 view .LVU113
 197:quantum/action_layer.c ****     const uint8_t storage_bit = key_number % 8;
 739              		.loc 1 197 5 view .LVU114
 198:quantum/action_layer.c **** 
 199:quantum/action_layer.c ****     for (uint8_t bit_number = 0; bit_number < MAX_LAYER_BITS; bit_number++) {
 740              		.loc 1 199 5 view .LVU115
 741              	.LBB14:
 742              		.loc 1 199 10 view .LVU116
 743              		.loc 1 199 45 view .LVU117
 200:quantum/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 744              		.loc 1 200 149 is_stmt 0 view .LVU118
 745 000e 00F00703 		and	r3, r0, #7
 746 0012 0C4A     		ldr	r2, .L54
 747 0014 0124     		movs	r4, #1
 748 0016 C0F3C400 		ubfx	r0, r0, #3, #5
 749              	.LVL57:
 750              		.loc 1 200 149 view .LVU119
 751 001a 00EB8000 		add	r0, r0, r0, lsl #2
 752 001e 9C40     		lsls	r4, r4, r3
 753 0020 0244     		add	r2, r2, r0
 754              		.loc 1 200 143 view .LVU120
 755 0022 E4B2     		uxtb	r4, r4
 756 0024 0020     		movs	r0, #0
 757              	.LVL58:
 758              	.L52:
 759              		.loc 1 200 9 is_stmt 1 discriminator 3 view .LVU121
 760              		.loc 1 200 54 is_stmt 0 discriminator 3 view .LVU122
 761 0026 1578     		ldrb	r5, [r2]	@ zero_extendqisi2
 762              		.loc 1 200 89 discriminator 3 view .LVU123
 763 0028 21FA00F3 		lsr	r3, r1, r0
 764              		.loc 1 200 95 discriminator 3 view .LVU124
 765 002c 43F30003 		sbfx	r3, r3, #0, #1
 766              		.loc 1 200 143 discriminator 3 view .LVU125
 767 0030 6B40     		eors	r3, r3, r5
 768 0032 2340     		ands	r3, r3, r4
 199:quantum/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 769              		.loc 1 199 45 discriminator 3 view .LVU126
 770 0034 0130     		adds	r0, r0, #1
 771              	.LVL59:
 772              		.loc 1 200 54 discriminator 3 view .LVU127
 773 0036 5D40     		eors	r5, r5, r3
 199:quantum/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 774              		.loc 1 199 45 discriminator 3 view .LVU128
 775 0038 0528     		cmp	r0, #5
 776              		.loc 1 200 54 discriminator 3 view .LVU129
 777 003a 02F8015B 		strb	r5, [r2], #1
 199:quantum/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 778              		.loc 1 199 73 is_stmt 1 discriminator 3 view .LVU130
 199:quantum/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 779              		.loc 1 199 45 discriminator 3 view .LVU131
 780 003e F2D1     		bne	.L52
 781              	.LBE14:
 201:quantum/action_layer.c ****     }
 202:quantum/action_layer.c **** }
 782              		.loc 1 202 1 is_stmt 0 view .LVU132
 783 0040 03B0     		add	sp, sp, #12
 784              		.cfi_def_cfa_offset 12
 785              		@ sp needed
 786 0042 30BD     		pop	{r4, r5, pc}
 787              	.L55:
 788              		.align	2
 789              	.L54:
 790 0044 00000000 		.word	.LANCHOR2
 791              		.cfi_endproc
 792              	.LFE25:
 794              		.section	.text.read_source_layers_cache,"ax",%progbits
 795              		.align	1
 796              		.global	read_source_layers_cache
 797              		.syntax unified
 798              		.thumb
 799              		.thumb_func
 800              		.fpu fpv4-sp-d16
 802              	read_source_layers_cache:
 803              	.LFB26:
 203:quantum/action_layer.c **** 
 204:quantum/action_layer.c **** /** \brief read source layers cache
 205:quantum/action_layer.c ****  *
 206:quantum/action_layer.c ****  * reads the cached keys stored when the layer was changed
 207:quantum/action_layer.c ****  */
 208:quantum/action_layer.c **** uint8_t read_source_layers_cache(keypos_t key) {
 804              		.loc 1 208 48 is_stmt 1 view -0
 805              		.cfi_startproc
 806              		@ args = 0, pretend = 0, frame = 8
 807              		@ frame_needed = 0, uses_anonymous_args = 0
 209:quantum/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 808              		.loc 1 209 5 view .LVU134
 809              		.loc 1 209 41 is_stmt 0 view .LVU135
 810 0000 C0F30723 		ubfx	r3, r0, #8, #8
 811 0004 03EB4303 		add	r3, r3, r3, lsl #1
 208:quantum/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 812              		.loc 1 208 48 view .LVU136
 813 0008 13B5     		push	{r0, r1, r4, lr}
 814              		.cfi_def_cfa_offset 16
 815              		.cfi_offset 4, -8
 816              		.cfi_offset 14, -4
 817              		.loc 1 209 19 view .LVU137
 818 000a 00EB4300 		add	r0, r0, r3, lsl #1
 819              	.LVL60:
 210:quantum/action_layer.c ****     const uint8_t storage_row = key_number / 8;
 820              		.loc 1 210 5 is_stmt 1 view .LVU138
 211:quantum/action_layer.c ****     const uint8_t storage_bit = key_number % 8;
 821              		.loc 1 211 5 view .LVU139
 822 000e 0B49     		ldr	r1, .L59
 823              		.loc 1 211 19 is_stmt 0 view .LVU140
 824 0010 00F00704 		and	r4, r0, #7
 825              	.LVL61:
 212:quantum/action_layer.c ****     uint8_t       layer       = 0;
 826              		.loc 1 212 5 is_stmt 1 view .LVU141
 213:quantum/action_layer.c **** 
 214:quantum/action_layer.c ****     for (uint8_t bit_number = 0; bit_number < MAX_LAYER_BITS; bit_number++) {
 827              		.loc 1 214 5 view .LVU142
 828              	.LBB15:
 829              		.loc 1 214 10 view .LVU143
 830              		.loc 1 214 45 view .LVU144
 831 0014 C0F3C400 		ubfx	r0, r0, #3, #5
 832              	.LVL62:
 833              		.loc 1 214 45 is_stmt 0 view .LVU145
 834 0018 00EB8000 		add	r0, r0, r0, lsl #2
 835              	.LBE15:
 211:quantum/action_layer.c ****     uint8_t       layer       = 0;
 836              		.loc 1 211 19 view .LVU146
 837 001c 0022     		movs	r2, #0
 838 001e 0144     		add	r1, r1, r0
 212:quantum/action_layer.c ****     uint8_t       layer       = 0;
 839              		.loc 1 212 19 view .LVU147
 840 0020 1046     		mov	r0, r2
 841              	.LVL63:
 842              	.L57:
 843              	.LBB16:
 215:quantum/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 844              		.loc 1 215 9 is_stmt 1 discriminator 3 view .LVU148
 845              		.loc 1 215 52 is_stmt 0 discriminator 3 view .LVU149
 846 0022 11F8013B 		ldrb	r3, [r1], #1	@ zero_extendqisi2
 847              		.loc 1 215 88 discriminator 3 view .LVU150
 848 0026 E340     		lsrs	r3, r3, r4
 849 0028 03F00103 		and	r3, r3, #1
 850              		.loc 1 215 94 discriminator 3 view .LVU151
 851 002c 9340     		lsls	r3, r3, r2
 214:quantum/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 852              		.loc 1 214 45 discriminator 3 view .LVU152
 853 002e 0132     		adds	r2, r2, #1
 854              	.LVL64:
 855              		.loc 1 215 15 discriminator 3 view .LVU153
 856 0030 1843     		orrs	r0, r0, r3
 857              	.LVL65:
 214:quantum/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 858              		.loc 1 214 45 discriminator 3 view .LVU154
 859 0032 052A     		cmp	r2, #5
 860              		.loc 1 215 15 discriminator 3 view .LVU155
 861 0034 C0B2     		uxtb	r0, r0
 862              	.LVL66:
 214:quantum/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 863              		.loc 1 214 73 is_stmt 1 discriminator 3 view .LVU156
 214:quantum/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 864              		.loc 1 214 45 discriminator 3 view .LVU157
 865 0036 F4D1     		bne	.L57
 866              	.LBE16:
 216:quantum/action_layer.c ****     }
 217:quantum/action_layer.c **** 
 218:quantum/action_layer.c ****     return layer;
 867              		.loc 1 218 5 view .LVU158
 219:quantum/action_layer.c **** }
 868              		.loc 1 219 1 is_stmt 0 view .LVU159
 869 0038 02B0     		add	sp, sp, #8
 870              		.cfi_def_cfa_offset 8
 871              		@ sp needed
 872 003a 10BD     		pop	{r4, pc}
 873              	.LVL67:
 874              	.L60:
 875              		.loc 1 219 1 view .LVU160
 876              		.align	2
 877              	.L59:
 878 003c 00000000 		.word	.LANCHOR2
 879              		.cfi_endproc
 880              	.LFE26:
 882              		.section	.text.layer_switch_get_layer,"ax",%progbits
 883              		.align	1
 884              		.global	layer_switch_get_layer
 885              		.syntax unified
 886              		.thumb
 887              		.thumb_func
 888              		.fpu fpv4-sp-d16
 890              	layer_switch_get_layer:
 891              	.LFB28:
 220:quantum/action_layer.c **** #endif
 221:quantum/action_layer.c **** 
 222:quantum/action_layer.c **** /** \brief Store or get action (FIXME: Needs better summary)
 223:quantum/action_layer.c ****  *
 224:quantum/action_layer.c ****  * Make sure the action triggered when the key is released is the same
 225:quantum/action_layer.c ****  * one as the one triggered on press. It's important for the mod keys
 226:quantum/action_layer.c ****  * when the layer is switched after the down event but before the up
 227:quantum/action_layer.c ****  * event as they may get stuck otherwise.
 228:quantum/action_layer.c ****  */
 229:quantum/action_layer.c **** action_t store_or_get_action(bool pressed, keypos_t key) {
 230:quantum/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 231:quantum/action_layer.c ****     if (disable_action_cache) {
 232:quantum/action_layer.c ****         return layer_switch_get_action(key);
 233:quantum/action_layer.c ****     }
 234:quantum/action_layer.c **** 
 235:quantum/action_layer.c ****     uint8_t layer;
 236:quantum/action_layer.c **** 
 237:quantum/action_layer.c ****     if (pressed) {
 238:quantum/action_layer.c ****         layer = layer_switch_get_layer(key);
 239:quantum/action_layer.c ****         update_source_layers_cache(key, layer);
 240:quantum/action_layer.c ****     } else {
 241:quantum/action_layer.c ****         layer = read_source_layers_cache(key);
 242:quantum/action_layer.c ****     }
 243:quantum/action_layer.c ****     return action_for_key(layer, key);
 244:quantum/action_layer.c **** #else
 245:quantum/action_layer.c ****     return layer_switch_get_action(key);
 246:quantum/action_layer.c **** #endif
 247:quantum/action_layer.c **** }
 248:quantum/action_layer.c **** 
 249:quantum/action_layer.c **** /** \brief Layer switch get layer
 250:quantum/action_layer.c ****  *
 251:quantum/action_layer.c ****  * Gets the layer based on key info
 252:quantum/action_layer.c ****  */
 253:quantum/action_layer.c **** uint8_t layer_switch_get_layer(keypos_t key) {
 892              		.loc 1 253 46 is_stmt 1 view -0
 893              		.cfi_startproc
 894              		@ args = 0, pretend = 0, frame = 8
 895              		@ frame_needed = 0, uses_anonymous_args = 0
 254:quantum/action_layer.c **** #ifndef NO_ACTION_LAYER
 255:quantum/action_layer.c ****     action_t action;
 896              		.loc 1 255 5 view .LVU162
 256:quantum/action_layer.c ****     action.code = ACTION_TRANSPARENT;
 897              		.loc 1 256 5 view .LVU163
 898              	.LVL68:
 257:quantum/action_layer.c **** 
 258:quantum/action_layer.c ****     layer_state_t layers = layer_state | default_layer_state;
 899              		.loc 1 258 5 view .LVU164
 900              		.loc 1 258 19 is_stmt 0 view .LVU165
 901 0000 0D4B     		ldr	r3, .L70
 253:quantum/action_layer.c **** #ifndef NO_ACTION_LAYER
 902              		.loc 1 253 46 view .LVU166
 903 0002 73B5     		push	{r0, r1, r4, r5, r6, lr}
 904              		.cfi_def_cfa_offset 24
 905              		.cfi_offset 4, -16
 906              		.cfi_offset 5, -12
 907              		.cfi_offset 6, -8
 908              		.cfi_offset 14, -4
 909              		.loc 1 258 19 view .LVU167
 910 0004 1E68     		ldr	r6, [r3]
 911 0006 0D4B     		ldr	r3, .L70+4
 253:quantum/action_layer.c **** #ifndef NO_ACTION_LAYER
 912              		.loc 1 253 46 view .LVU168
 913 0008 ADF80400 		strh	r0, [sp, #4]	@ movhi
 914              		.loc 1 258 19 view .LVU169
 915 000c 1B68     		ldr	r3, [r3]
 916 000e 1F24     		movs	r4, #31
 917 0010 1E43     		orrs	r6, r6, r3
 918              	.LVL69:
 259:quantum/action_layer.c ****     /* check top layer first */
 260:quantum/action_layer.c ****     for (int8_t i = MAX_LAYER - 1; i >= 0; i--) {
 919              		.loc 1 260 5 is_stmt 1 view .LVU170
 920              	.LBB17:
 921              		.loc 1 260 10 view .LVU171
 922              		.loc 1 260 38 view .LVU172
 923              	.L63:
 261:quantum/action_layer.c ****         if (layers & ((layer_state_t)1 << i)) {
 924              		.loc 1 261 9 view .LVU173
 925              		.loc 1 261 13 is_stmt 0 view .LVU174
 926 0012 26FA04F3 		lsr	r3, r6, r4
 927              		.loc 1 261 12 view .LVU175
 928 0016 DB07     		lsls	r3, r3, #31
 929 0018 E5B2     		uxtb	r5, r4
 930 001a 05D4     		bmi	.L62
 931              	.L65:
 260:quantum/action_layer.c ****         if (layers & ((layer_state_t)1 << i)) {
 932              		.loc 1 260 45 is_stmt 1 view .LVU176
 933              	.LVL70:
 260:quantum/action_layer.c ****         if (layers & ((layer_state_t)1 << i)) {
 934              		.loc 1 260 38 view .LVU177
 935 001c 013C     		subs	r4, r4, #1
 936              	.LVL71:
 260:quantum/action_layer.c ****         if (layers & ((layer_state_t)1 << i)) {
 937              		.loc 1 260 38 is_stmt 0 view .LVU178
 938 001e F8D2     		bcs	.L63
 939              	.LBE17:
 262:quantum/action_layer.c ****             action = action_for_key(i, key);
 263:quantum/action_layer.c ****             if (action.code != ACTION_TRANSPARENT) {
 264:quantum/action_layer.c ****                 return i;
 265:quantum/action_layer.c ****             }
 266:quantum/action_layer.c ****         }
 267:quantum/action_layer.c ****     }
 268:quantum/action_layer.c ****     /* fall back to layer 0 */
 269:quantum/action_layer.c ****     return 0;
 940              		.loc 1 269 12 view .LVU179
 941 0020 0025     		movs	r5, #0
 942              	.LVL72:
 943              	.L64:
 270:quantum/action_layer.c **** #else
 271:quantum/action_layer.c ****     return get_highest_layer(default_layer_state);
 272:quantum/action_layer.c **** #endif
 273:quantum/action_layer.c **** }
 944              		.loc 1 273 1 view .LVU180
 945 0022 2846     		mov	r0, r5
 946              	.LVL73:
 947              		.loc 1 273 1 view .LVU181
 948 0024 02B0     		add	sp, sp, #8
 949              		.cfi_remember_state
 950              		.cfi_def_cfa_offset 16
 951              		@ sp needed
 952 0026 70BD     		pop	{r4, r5, r6, pc}
 953              	.LVL74:
 954              	.L62:
 955              		.cfi_restore_state
 956              	.LBB18:
 262:quantum/action_layer.c ****             action = action_for_key(i, key);
 957              		.loc 1 262 13 is_stmt 1 view .LVU182
 262:quantum/action_layer.c ****             action = action_for_key(i, key);
 958              		.loc 1 262 22 is_stmt 0 view .LVU183
 959 0028 0199     		ldr	r1, [sp, #4]
 960 002a 2846     		mov	r0, r5
 961              	.LVL75:
 262:quantum/action_layer.c ****             action = action_for_key(i, key);
 962              		.loc 1 262 22 view .LVU184
 963 002c FFF7FEFF 		bl	action_for_key
 964              	.LVL76:
 263:quantum/action_layer.c ****                 return i;
 965              		.loc 1 263 13 is_stmt 1 view .LVU185
 263:quantum/action_layer.c ****                 return i;
 966              		.loc 1 263 16 is_stmt 0 view .LVU186
 967 0030 80B2     		uxth	r0, r0
 968              	.LVL77:
 263:quantum/action_layer.c ****                 return i;
 969              		.loc 1 263 16 view .LVU187
 970 0032 0128     		cmp	r0, #1
 971 0034 F2D0     		beq	.L65
 972 0036 F4E7     		b	.L64
 973              	.L71:
 974              		.align	2
 975              	.L70:
 976 0038 00000000 		.word	.LANCHOR1
 977 003c 00000000 		.word	.LANCHOR0
 978              	.LBE18:
 979              		.cfi_endproc
 980              	.LFE28:
 982              		.section	.text.layer_switch_get_action,"ax",%progbits
 983              		.align	1
 984              		.global	layer_switch_get_action
 985              		.syntax unified
 986              		.thumb
 987              		.thumb_func
 988              		.fpu fpv4-sp-d16
 990              	layer_switch_get_action:
 991              	.LFB29:
 274:quantum/action_layer.c **** 
 275:quantum/action_layer.c **** /** \brief Layer switch get layer
 276:quantum/action_layer.c ****  *
 277:quantum/action_layer.c ****  * Gets action code based on key position
 278:quantum/action_layer.c ****  */
 279:quantum/action_layer.c **** action_t layer_switch_get_action(keypos_t key) { return action_for_key(layer_switch_get_layer(key),
 992              		.loc 1 279 48 is_stmt 1 view -0
 993              		.cfi_startproc
 994              		@ args = 0, pretend = 0, frame = 8
 995              		@ frame_needed = 0, uses_anonymous_args = 0
 996              		.loc 1 279 50 view .LVU189
 997              		.loc 1 279 48 is_stmt 0 view .LVU190
 998 0000 07B5     		push	{r0, r1, r2, lr}
 999              		.cfi_def_cfa_offset 16
 1000              		.cfi_offset 14, -4
 1001              		.loc 1 279 48 view .LVU191
 1002 0002 ADF80400 		strh	r0, [sp, #4]	@ movhi
 1003              		.loc 1 279 57 view .LVU192
 1004 0006 0198     		ldr	r0, [sp, #4]
 1005 0008 FFF7FEFF 		bl	layer_switch_get_layer
 1006              	.LVL78:
 1007 000c 0199     		ldr	r1, [sp, #4]
 1008              		.loc 1 279 107 view .LVU193
 1009 000e 03B0     		add	sp, sp, #12
 1010              		.cfi_def_cfa_offset 4
 1011              		@ sp needed
 1012 0010 5DF804EB 		ldr	lr, [sp], #4
 1013              		.cfi_restore 14
 1014              		.cfi_def_cfa_offset 0
 1015              		.loc 1 279 57 view .LVU194
 1016 0014 FFF7FEBF 		b	action_for_key
 1017              	.LVL79:
 1018              		.cfi_endproc
 1019              	.LFE29:
 1021              		.section	.text.store_or_get_action,"ax",%progbits
 1022              		.align	1
 1023              		.global	store_or_get_action
 1024              		.syntax unified
 1025              		.thumb
 1026              		.thumb_func
 1027              		.fpu fpv4-sp-d16
 1029              	store_or_get_action:
 1030              	.LVL80:
 1031              	.LFB27:
 229:quantum/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 1032              		.loc 1 229 58 is_stmt 1 view -0
 1033              		.cfi_startproc
 1034              		@ args = 0, pretend = 0, frame = 8
 1035              		@ frame_needed = 0, uses_anonymous_args = 0
 231:quantum/action_layer.c ****         return layer_switch_get_action(key);
 1036              		.loc 1 231 5 view .LVU196
 229:quantum/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 1037              		.loc 1 229 58 is_stmt 0 view .LVU197
 1038 0000 13B5     		push	{r0, r1, r4, lr}
 1039              		.cfi_def_cfa_offset 16
 1040              		.cfi_offset 4, -8
 1041              		.cfi_offset 14, -4
 231:quantum/action_layer.c ****         return layer_switch_get_action(key);
 1042              		.loc 1 231 9 view .LVU198
 1043 0002 104B     		ldr	r3, .L77
 229:quantum/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 1044              		.loc 1 229 58 view .LVU199
 1045 0004 ADF80410 		strh	r1, [sp, #4]	@ movhi
 231:quantum/action_layer.c ****         return layer_switch_get_action(key);
 1046              		.loc 1 231 8 view .LVU200
 1047 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1048 000a 2BB1     		cbz	r3, .L74
 232:quantum/action_layer.c ****     }
 1049              		.loc 1 232 9 is_stmt 1 view .LVU201
 232:quantum/action_layer.c ****     }
 1050              		.loc 1 232 16 is_stmt 0 view .LVU202
 1051 000c 0198     		ldr	r0, [sp, #4]
 1052              	.LVL81:
 247:quantum/action_layer.c **** 
 1053              		.loc 1 247 1 view .LVU203
 1054 000e 02B0     		add	sp, sp, #8
 1055              		.cfi_remember_state
 1056              		.cfi_def_cfa_offset 8
 1057              		@ sp needed
 1058 0010 BDE81040 		pop	{r4, lr}
 1059              		.cfi_restore 14
 1060              		.cfi_restore 4
 1061              		.cfi_def_cfa_offset 0
 232:quantum/action_layer.c ****     }
 1062              		.loc 1 232 16 view .LVU204
 1063 0014 FFF7FEBF 		b	layer_switch_get_action
 1064              	.LVL82:
 1065              	.L74:
 1066              		.cfi_restore_state
 235:quantum/action_layer.c **** 
 1067              		.loc 1 235 5 is_stmt 1 view .LVU205
 237:quantum/action_layer.c ****         layer = layer_switch_get_layer(key);
 1068              		.loc 1 237 5 view .LVU206
 237:quantum/action_layer.c ****         layer = layer_switch_get_layer(key);
 1069              		.loc 1 237 8 is_stmt 0 view .LVU207
 1070 0018 70B1     		cbz	r0, .L75
 238:quantum/action_layer.c ****         update_source_layers_cache(key, layer);
 1071              		.loc 1 238 9 is_stmt 1 view .LVU208
 238:quantum/action_layer.c ****         update_source_layers_cache(key, layer);
 1072              		.loc 1 238 17 is_stmt 0 view .LVU209
 1073 001a 0198     		ldr	r0, [sp, #4]
 1074              	.LVL83:
 238:quantum/action_layer.c ****         update_source_layers_cache(key, layer);
 1075              		.loc 1 238 17 view .LVU210
 1076 001c FFF7FEFF 		bl	layer_switch_get_layer
 1077              	.LVL84:
 1078 0020 0446     		mov	r4, r0
 1079              	.LVL85:
 239:quantum/action_layer.c ****     } else {
 1080              		.loc 1 239 9 is_stmt 1 view .LVU211
 1081 0022 0146     		mov	r1, r0
 1082 0024 0198     		ldr	r0, [sp, #4]
 1083              	.LVL86:
 239:quantum/action_layer.c ****     } else {
 1084              		.loc 1 239 9 is_stmt 0 view .LVU212
 1085 0026 FFF7FEFF 		bl	update_source_layers_cache
 1086              	.LVL87:
 1087              	.L76:
 243:quantum/action_layer.c **** #else
 1088              		.loc 1 243 5 is_stmt 1 view .LVU213
 243:quantum/action_layer.c **** #else
 1089              		.loc 1 243 12 is_stmt 0 view .LVU214
 1090 002a 0199     		ldr	r1, [sp, #4]
 1091 002c 2046     		mov	r0, r4
 247:quantum/action_layer.c **** 
 1092              		.loc 1 247 1 view .LVU215
 1093 002e 02B0     		add	sp, sp, #8
 1094              		.cfi_remember_state
 1095              		.cfi_def_cfa_offset 8
 1096              		@ sp needed
 1097 0030 BDE81040 		pop	{r4, lr}
 1098              		.cfi_restore 14
 1099              		.cfi_restore 4
 1100              		.cfi_def_cfa_offset 0
 1101              	.LVL88:
 243:quantum/action_layer.c **** #else
 1102              		.loc 1 243 12 view .LVU216
 1103 0034 FFF7FEBF 		b	action_for_key
 1104              	.LVL89:
 1105              	.L75:
 1106              		.cfi_restore_state
 241:quantum/action_layer.c ****     }
 1107              		.loc 1 241 9 is_stmt 1 view .LVU217
 241:quantum/action_layer.c ****     }
 1108              		.loc 1 241 17 is_stmt 0 view .LVU218
 1109 0038 0198     		ldr	r0, [sp, #4]
 1110              	.LVL90:
 241:quantum/action_layer.c ****     }
 1111              		.loc 1 241 17 view .LVU219
 1112 003a FFF7FEFF 		bl	read_source_layers_cache
 1113              	.LVL91:
 1114 003e 0446     		mov	r4, r0
 1115              	.LVL92:
 241:quantum/action_layer.c ****     }
 1116              		.loc 1 241 17 view .LVU220
 1117 0040 F3E7     		b	.L76
 1118              	.L78:
 1119 0042 00BF     		.align	2
 1120              	.L77:
 1121 0044 00000000 		.word	disable_action_cache
 1122              		.cfi_endproc
 1123              	.LFE27:
 1125              		.global	source_layers_cache
 1126              		.global	layer_state
 1127              		.global	default_layer_state
 1128              		.section	.bss.default_layer_state,"aw",%nobits
 1129              		.align	2
 1130              		.set	.LANCHOR0,. + 0
 1133              	default_layer_state:
 1134 0000 00000000 		.space	4
 1135              		.section	.bss.layer_state,"aw",%nobits
 1136              		.align	2
 1137              		.set	.LANCHOR1,. + 0
 1140              	layer_state:
 1141 0000 00000000 		.space	4
 1142              		.section	.bss.source_layers_cache,"aw",%nobits
 1143              		.set	.LANCHOR2,. + 0
 1146              	source_layers_cache:
 1147 0000 00000000 		.space	30
 1147      00000000 
 1147      00000000 
 1147      00000000 
 1147      00000000 
 1148              		.text
 1149              	.Letext0:
 1150              		.file 2 "/usr/arm-none-eabi/include/machine/_default_types.h"
 1151              		.file 3 "/usr/arm-none-eabi/include/sys/_stdint.h"
 1152              		.file 4 "quantum/keyboard.h"
 1153              		.file 5 "quantum/action_code.h"
 1154              		.file 6 "quantum/action_layer.h"
 1155              		.file 7 "quantum/action.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action_layer.c
     /tmp/ccxdFj2l.s:18     .text.default_layer_state_set_user:0000000000000000 $t
     /tmp/ccxdFj2l.s:26     .text.default_layer_state_set_user:0000000000000000 default_layer_state_set_user
     /tmp/ccxdFj2l.s:42     .text.default_layer_state_set_kb:0000000000000000 $t
     /tmp/ccxdFj2l.s:49     .text.default_layer_state_set_kb:0000000000000000 default_layer_state_set_kb
     /tmp/ccxdFj2l.s:71     .text.default_layer_state_set:0000000000000000 $t
     /tmp/ccxdFj2l.s:77     .text.default_layer_state_set:0000000000000000 default_layer_state_set
     /tmp/ccxdFj2l.s:115    .text.default_layer_state_set:0000000000000014 $d
     /tmp/ccxdFj2l.s:120    .text.default_layer_debug:0000000000000000 $t
     /tmp/ccxdFj2l.s:127    .text.default_layer_debug:0000000000000000 default_layer_debug
     /tmp/ccxdFj2l.s:141    .text.default_layer_set:0000000000000000 $t
     /tmp/ccxdFj2l.s:148    .text.default_layer_set:0000000000000000 default_layer_set
     /tmp/ccxdFj2l.s:164    .text.default_layer_or:0000000000000000 $t
     /tmp/ccxdFj2l.s:171    .text.default_layer_or:0000000000000000 default_layer_or
     /tmp/ccxdFj2l.s:190    .text.default_layer_or:000000000000000c $d
     /tmp/ccxdFj2l.s:195    .text.default_layer_and:0000000000000000 $t
     /tmp/ccxdFj2l.s:202    .text.default_layer_and:0000000000000000 default_layer_and
     /tmp/ccxdFj2l.s:221    .text.default_layer_and:000000000000000c $d
     /tmp/ccxdFj2l.s:226    .text.default_layer_xor:0000000000000000 $t
     /tmp/ccxdFj2l.s:233    .text.default_layer_xor:0000000000000000 default_layer_xor
     /tmp/ccxdFj2l.s:252    .text.default_layer_xor:000000000000000c $d
     /tmp/ccxdFj2l.s:257    .text.layer_state_set_user:0000000000000000 $t
     /tmp/ccxdFj2l.s:264    .text.layer_state_set_user:0000000000000000 layer_state_set_user
     /tmp/ccxdFj2l.s:275    .text.layer_state_set_kb:0000000000000000 $t
     /tmp/ccxdFj2l.s:282    .text.layer_state_set_kb:0000000000000000 layer_state_set_kb
     /tmp/ccxdFj2l.s:304    .text.layer_state_set:0000000000000000 $t
     /tmp/ccxdFj2l.s:311    .text.layer_state_set:0000000000000000 layer_state_set
     /tmp/ccxdFj2l.s:349    .text.layer_state_set:0000000000000014 $d
     /tmp/ccxdFj2l.s:354    .text.layer_clear:0000000000000000 $t
     /tmp/ccxdFj2l.s:361    .text.layer_clear:0000000000000000 layer_clear
     /tmp/ccxdFj2l.s:376    .text.layer_state_is:0000000000000000 $t
     /tmp/ccxdFj2l.s:383    .text.layer_state_is:0000000000000000 layer_state_is
     /tmp/ccxdFj2l.s:427    .text.layer_state_is:0000000000000018 $d
     /tmp/ccxdFj2l.s:432    .text.layer_state_cmp:0000000000000000 $t
     /tmp/ccxdFj2l.s:439    .text.layer_state_cmp:0000000000000000 layer_state_cmp
     /tmp/ccxdFj2l.s:472    .text.layer_move:0000000000000000 $t
     /tmp/ccxdFj2l.s:479    .text.layer_move:0000000000000000 layer_move
     /tmp/ccxdFj2l.s:498    .text.layer_on:0000000000000000 $t
     /tmp/ccxdFj2l.s:505    .text.layer_on:0000000000000000 layer_on
     /tmp/ccxdFj2l.s:527    .text.layer_on:0000000000000010 $d
     /tmp/ccxdFj2l.s:532    .text.layer_off:0000000000000000 $t
     /tmp/ccxdFj2l.s:539    .text.layer_off:0000000000000000 layer_off
     /tmp/ccxdFj2l.s:561    .text.layer_off:0000000000000014 $d
     /tmp/ccxdFj2l.s:566    .text.layer_invert:0000000000000000 $t
     /tmp/ccxdFj2l.s:573    .text.layer_invert:0000000000000000 layer_invert
     /tmp/ccxdFj2l.s:595    .text.layer_invert:0000000000000010 $d
     /tmp/ccxdFj2l.s:600    .text.layer_or:0000000000000000 $t
     /tmp/ccxdFj2l.s:607    .text.layer_or:0000000000000000 layer_or
     /tmp/ccxdFj2l.s:626    .text.layer_or:000000000000000c $d
     /tmp/ccxdFj2l.s:631    .text.layer_and:0000000000000000 $t
     /tmp/ccxdFj2l.s:638    .text.layer_and:0000000000000000 layer_and
     /tmp/ccxdFj2l.s:657    .text.layer_and:000000000000000c $d
     /tmp/ccxdFj2l.s:662    .text.layer_xor:0000000000000000 $t
     /tmp/ccxdFj2l.s:669    .text.layer_xor:0000000000000000 layer_xor
     /tmp/ccxdFj2l.s:688    .text.layer_xor:000000000000000c $d
     /tmp/ccxdFj2l.s:693    .text.layer_debug:0000000000000000 $t
     /tmp/ccxdFj2l.s:700    .text.layer_debug:0000000000000000 layer_debug
     /tmp/ccxdFj2l.s:711    .text.update_source_layers_cache:0000000000000000 $t
     /tmp/ccxdFj2l.s:718    .text.update_source_layers_cache:0000000000000000 update_source_layers_cache
     /tmp/ccxdFj2l.s:790    .text.update_source_layers_cache:0000000000000044 $d
     /tmp/ccxdFj2l.s:795    .text.read_source_layers_cache:0000000000000000 $t
     /tmp/ccxdFj2l.s:802    .text.read_source_layers_cache:0000000000000000 read_source_layers_cache
     /tmp/ccxdFj2l.s:878    .text.read_source_layers_cache:000000000000003c $d
     /tmp/ccxdFj2l.s:883    .text.layer_switch_get_layer:0000000000000000 $t
     /tmp/ccxdFj2l.s:890    .text.layer_switch_get_layer:0000000000000000 layer_switch_get_layer
     /tmp/ccxdFj2l.s:976    .text.layer_switch_get_layer:0000000000000038 $d
     /tmp/ccxdFj2l.s:983    .text.layer_switch_get_action:0000000000000000 $t
     /tmp/ccxdFj2l.s:990    .text.layer_switch_get_action:0000000000000000 layer_switch_get_action
     /tmp/ccxdFj2l.s:1022   .text.store_or_get_action:0000000000000000 $t
     /tmp/ccxdFj2l.s:1029   .text.store_or_get_action:0000000000000000 store_or_get_action
     /tmp/ccxdFj2l.s:1121   .text.store_or_get_action:0000000000000044 $d
     /tmp/ccxdFj2l.s:1146   .bss.source_layers_cache:0000000000000000 source_layers_cache
     /tmp/ccxdFj2l.s:1140   .bss.layer_state:0000000000000000 layer_state
     /tmp/ccxdFj2l.s:1133   .bss.default_layer_state:0000000000000000 default_layer_state
     /tmp/ccxdFj2l.s:1129   .bss.default_layer_state:0000000000000000 $d
     /tmp/ccxdFj2l.s:1136   .bss.layer_state:0000000000000000 $d
     /tmp/ccxdFj2l.s:1147   .bss.source_layers_cache:0000000000000000 $d

UNDEFINED SYMBOLS
clear_keyboard_but_mods_and_keys
action_for_key
disable_action_cache
