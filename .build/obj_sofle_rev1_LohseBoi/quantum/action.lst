   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.process_hand_swap,"ax",@progbits
  11               	.global	process_hand_swap
  13               	process_hand_swap:
  14               	.LVL0:
  15               	.LFB21:
  16               		.file 1 "quantum/action.c"
   1:quantum/action.c **** /*
   2:quantum/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:quantum/action.c **** 
   4:quantum/action.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/action.c **** it under the terms of the GNU General Public License as published by
   6:quantum/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/action.c **** (at your option) any later version.
   8:quantum/action.c **** 
   9:quantum/action.c **** This program is distributed in the hope that it will be useful,
  10:quantum/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/action.c **** GNU General Public License for more details.
  13:quantum/action.c **** 
  14:quantum/action.c **** You should have received a copy of the GNU General Public License
  15:quantum/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/action.c **** */
  17:quantum/action.c **** #include "host.h"
  18:quantum/action.c **** #include "keycode.h"
  19:quantum/action.c **** #include "keyboard.h"
  20:quantum/action.c **** #include "mousekey.h"
  21:quantum/action.c **** #include "command.h"
  22:quantum/action.c **** #include "led.h"
  23:quantum/action.c **** #include "action_layer.h"
  24:quantum/action.c **** #include "action_tapping.h"
  25:quantum/action.c **** #include "action_macro.h"
  26:quantum/action.c **** #include "action_util.h"
  27:quantum/action.c **** #include "action.h"
  28:quantum/action.c **** #include "wait.h"
  29:quantum/action.c **** 
  30:quantum/action.c **** #ifdef BACKLIGHT_ENABLE
  31:quantum/action.c **** #    include "backlight.h"
  32:quantum/action.c **** #endif
  33:quantum/action.c **** 
  34:quantum/action.c **** #ifdef DEBUG_ACTION
  35:quantum/action.c **** #    include "debug.h"
  36:quantum/action.c **** #else
  37:quantum/action.c **** #    include "nodebug.h"
  38:quantum/action.c **** #endif
  39:quantum/action.c **** 
  40:quantum/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:quantum/action.c **** #    include "pointing_device.h"
  42:quantum/action.c **** #endif
  43:quantum/action.c **** 
  44:quantum/action.c **** int tp_buttons;
  45:quantum/action.c **** 
  46:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:quantum/action.c **** int retro_tapping_counter = 0;
  48:quantum/action.c **** #endif
  49:quantum/action.c **** 
  50:quantum/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:quantum/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:quantum/action.c **** #endif
  53:quantum/action.c **** 
  54:quantum/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  55:quantum/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  56:quantum/action.c **** #endif
  57:quantum/action.c **** 
  58:quantum/action.c **** __attribute__((weak)) bool pre_process_record_quantum(keyrecord_t *record) { return true; }
  59:quantum/action.c **** 
  60:quantum/action.c **** /** \brief Called to execute an action.
  61:quantum/action.c ****  *
  62:quantum/action.c ****  * FIXME: Needs documentation.
  63:quantum/action.c ****  */
  64:quantum/action.c **** void action_exec(keyevent_t event) {
  65:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  66:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:quantum/action.c ****         dprint("EVENT: ");
  68:quantum/action.c ****         debug_event(event);
  69:quantum/action.c ****         dprintln();
  70:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  71:quantum/action.c ****         retro_tapping_counter++;
  72:quantum/action.c **** #endif
  73:quantum/action.c ****     }
  74:quantum/action.c **** 
  75:quantum/action.c ****     if (event.pressed) {
  76:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
  77:quantum/action.c ****         clear_weak_mods();
  78:quantum/action.c ****     }
  79:quantum/action.c **** 
  80:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
  81:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  82:quantum/action.c ****         process_hand_swap(&event);
  83:quantum/action.c ****     }
  84:quantum/action.c **** #endif
  85:quantum/action.c **** 
  86:quantum/action.c ****     keyrecord_t record = {.event = event};
  87:quantum/action.c **** 
  88:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
  89:quantum/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  90:quantum/action.c ****     if (has_oneshot_layer_timed_out()) {
  91:quantum/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  92:quantum/action.c ****     }
  93:quantum/action.c ****     if (has_oneshot_mods_timed_out()) {
  94:quantum/action.c ****         clear_oneshot_mods();
  95:quantum/action.c ****     }
  96:quantum/action.c **** #        ifdef SWAP_HANDS_ENABLE
  97:quantum/action.c ****     if (has_oneshot_swaphands_timed_out()) {
  98:quantum/action.c ****         clear_oneshot_swaphands();
  99:quantum/action.c ****     }
 100:quantum/action.c **** #        endif
 101:quantum/action.c **** #    endif
 102:quantum/action.c **** #endif
 103:quantum/action.c **** 
 104:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 105:quantum/action.c ****     if (IS_NOEVENT(record.event) || pre_process_record_quantum(&record)) {
 106:quantum/action.c ****         action_tapping_process(record);
 107:quantum/action.c ****     }
 108:quantum/action.c **** #else
 109:quantum/action.c ****     if (IS_NOEVENT(record.event) || pre_process_record_quantum(&record)) {
 110:quantum/action.c ****         process_record(&record);
 111:quantum/action.c ****     }
 112:quantum/action.c ****     if (!IS_NOEVENT(record.event)) {
 113:quantum/action.c ****         dprint("processed: ");
 114:quantum/action.c ****         debug_record(record);
 115:quantum/action.c ****         dprintln();
 116:quantum/action.c ****     }
 117:quantum/action.c **** #endif
 118:quantum/action.c **** }
 119:quantum/action.c **** 
 120:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 121:quantum/action.c **** bool swap_hands = false;
 122:quantum/action.c **** bool swap_held  = false;
 123:quantum/action.c **** 
 124:quantum/action.c **** /** \brief Process Hand Swap
 125:quantum/action.c ****  *
 126:quantum/action.c ****  * FIXME: Needs documentation.
 127:quantum/action.c ****  */
 128:quantum/action.c **** void process_hand_swap(keyevent_t *event) {
  17               		.loc 1 128 43 view -0
  18               		.cfi_startproc
  19               		.loc 1 128 43 is_stmt 0 view .LVU1
  20 0000 CF93      		push r28
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 28, -2
  24 0002 DF93      		push r29
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 29, -3
  28               	/* prologue: function */
  29               	/* frame size = 0 */
  30               	/* stack size = 2 */
  31               	.L__stack_usage = 2
  32 0004 EC01      		movw r28,r24
 129:quantum/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
  33               		.loc 1 129 5 is_stmt 1 view .LVU2
 130:quantum/action.c **** 
 131:quantum/action.c ****     keypos_t         pos     = event->key;
  34               		.loc 1 131 5 view .LVU3
  35               		.loc 1 131 22 is_stmt 0 view .LVU4
  36 0006 8881      		ld r24,Y
  37               	.LVL1:
  38               		.loc 1 131 22 view .LVU5
  39 0008 5981      		ldd r21,Y+1
  40               	.LVL2:
 132:quantum/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
  41               		.loc 1 132 5 is_stmt 1 view .LVU6
  42               		.loc 1 132 52 is_stmt 0 view .LVU7
  43 000a 21E0      		ldi r18,lo8(1)
  44 000c 30E0      		ldi r19,0
  45 000e 082E      		mov r0,r24
  46 0010 00C0      		rjmp 2f
  47               		1:
  48 0012 220F      		lsl r18
  49               		2:
  50 0014 0A94      		dec r0
  51 0016 02F4      		brpl 1b
  52               	.LVL3:
 133:quantum/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
  53               		.loc 1 133 5 is_stmt 1 view .LVU8
  54               		.loc 1 133 76 is_stmt 0 view .LVU9
  55 0018 A52F      		mov r26,r21
  56 001a B0E0      		ldi r27,0
  57               		.loc 1 133 72 view .LVU10
  58 001c A050      		subi r26,lo8(-(swap_state.0))
  59 001e B040      		sbci r27,hi8(-(swap_state.0))
  60 0020 4C91      		ld r20,X
  61               		.loc 1 133 60 view .LVU11
  62 0022 9A81      		ldd r25,Y+2
  63 0024 9923      		tst r25
  64 0026 01F0      		breq .L2
  65               	.LVL4:
 134:quantum/action.c **** 
 135:quantum/action.c ****     if (do_swap) {
  66               		.loc 1 135 5 is_stmt 1 discriminator 1 view .LVU12
  67               		.loc 1 135 8 is_stmt 0 discriminator 1 view .LVU13
  68 0028 9091 0000 		lds r25,swap_hands
  69               	.LVL5:
  70               	.L9:
  71               		.loc 1 135 8 discriminator 2 view .LVU14
  72 002c 9923      		tst r25
  73 002e 01F0      		breq .L4
 136:quantum/action.c ****         event->key.row = pgm_read_byte(&hand_swap_config[pos.row][pos.col].row);
  74               		.loc 1 136 9 is_stmt 1 view .LVU15
  75               	.LBB58:
  76               		.loc 1 136 26 view .LVU16
  77 0030 90E0      		ldi r25,0
  78 0032 66E0      		ldi r22,lo8(6)
  79 0034 569F      		mul r21,r22
  80 0036 800D      		add r24,r0
  81 0038 911D      		adc r25,r1
  82 003a 1124      		clr __zero_reg__
  83               	.LVL6:
  84               		.loc 1 136 26 is_stmt 0 view .LVU17
  85 003c 880F      		lsl r24
  86 003e 991F      		rol r25
  87               	.LVL7:
  88               		.loc 1 136 26 is_stmt 1 view .LVU18
  89               		.loc 1 136 26 view .LVU19
  90 0040 FC01      		movw r30,r24
  91 0042 E050      		subi r30,lo8(-(hand_swap_config+1))
  92 0044 F040      		sbci r31,hi8(-(hand_swap_config+1))
  93               	.LVL8:
  94               		.loc 1 136 26 is_stmt 0 view .LVU20
  95               	/* #APP */
  96               	 ;  136 "quantum/action.c" 1
  97 0046 E491      		lpm r30, Z
  98               		
  99               	 ;  0 "" 2
 100               	.LVL9:
 101               		.loc 1 136 26 is_stmt 1 view .LVU21
 102               	/* #NOAPP */
 103               	.LBE58:
 104               		.loc 1 136 24 is_stmt 0 view .LVU22
 105 0048 E983      		std Y+1,r30
 137:quantum/action.c ****         event->key.col = pgm_read_byte(&hand_swap_config[pos.row][pos.col].col);
 106               		.loc 1 137 9 is_stmt 1 view .LVU23
 107               	.LBB59:
 108               		.loc 1 137 26 view .LVU24
 109               	.LVL10:
 110               		.loc 1 137 26 view .LVU25
 111               		.loc 1 137 26 view .LVU26
 112 004a FC01      		movw r30,r24
 113               	.LVL11:
 114               		.loc 1 137 26 is_stmt 0 view .LVU27
 115 004c E050      		subi r30,lo8(-(hand_swap_config))
 116 004e F040      		sbci r31,hi8(-(hand_swap_config))
 117               	.LVL12:
 118               		.loc 1 137 26 view .LVU28
 119               	/* #APP */
 120               	 ;  137 "quantum/action.c" 1
 121 0050 E491      		lpm r30, Z
 122               		
 123               	 ;  0 "" 2
 124               	.LVL13:
 125               		.loc 1 137 26 is_stmt 1 view .LVU29
 126               	/* #NOAPP */
 127               	.LBE59:
 128               		.loc 1 137 24 is_stmt 0 view .LVU30
 129 0052 E883      		st Y,r30
 130               	.LVL14:
 138:quantum/action.c ****         swap_state[pos.row] |= col_bit;
 131               		.loc 1 138 9 is_stmt 1 view .LVU31
 132               		.loc 1 138 29 is_stmt 0 view .LVU32
 133 0054 422B      		or r20,r18
 134               	.LVL15:
 135               	.L5:
 136               		.loc 1 138 29 view .LVU33
 137 0056 4C93      		st X,r20
 138               	.LVL16:
 139               	/* epilogue start */
 139:quantum/action.c ****     } else {
 140:quantum/action.c ****         swap_state[pos.row] &= ~(col_bit);
 141:quantum/action.c ****     }
 142:quantum/action.c **** }
 140               		.loc 1 142 1 view .LVU34
 141 0058 DF91      		pop r29
 142 005a CF91      		pop r28
 143               	.LVL17:
 144               		.loc 1 142 1 view .LVU35
 145 005c 0895      		ret
 146               	.LVL18:
 147               	.L2:
 135:quantum/action.c ****         event->key.row = pgm_read_byte(&hand_swap_config[pos.row][pos.col].row);
 148               		.loc 1 135 5 is_stmt 1 discriminator 2 view .LVU36
 133:quantum/action.c **** 
 149               		.loc 1 133 60 is_stmt 0 discriminator 2 view .LVU37
 150 005e 942F      		mov r25,r20
 151 0060 9223      		and r25,r18
 152 0062 00C0      		rjmp .L9
 153               	.LVL19:
 154               	.L4:
 140:quantum/action.c ****     }
 155               		.loc 1 140 9 is_stmt 1 view .LVU38
 140:quantum/action.c ****     }
 156               		.loc 1 140 29 is_stmt 0 view .LVU39
 157 0064 2095      		com r18
 158               	.LVL20:
 140:quantum/action.c ****     }
 159               		.loc 1 140 29 view .LVU40
 160 0066 4223      		and r20,r18
 161 0068 00C0      		rjmp .L5
 162               		.cfi_endproc
 163               	.LFE21:
 165               		.section	.text.process_record_quantum,"ax",@progbits
 166               		.weak	process_record_quantum
 168               	process_record_quantum:
 169               	.LVL21:
 170               	.LFB23:
 143:quantum/action.c **** #endif
 144:quantum/action.c **** 
 145:quantum/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:quantum/action.c **** bool disable_action_cache = false;
 147:quantum/action.c **** 
 148:quantum/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:quantum/action.c ****     disable_action_cache = true;
 150:quantum/action.c ****     process_record(record);
 151:quantum/action.c ****     disable_action_cache = false;
 152:quantum/action.c **** }
 153:quantum/action.c **** #else
 154:quantum/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:quantum/action.c **** #endif
 156:quantum/action.c **** 
 157:quantum/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
 171               		.loc 1 157 72 is_stmt 1 view -0
 172               		.cfi_startproc
 173               	/* prologue: function */
 174               	/* frame size = 0 */
 175               	/* stack size = 0 */
 176               	.L__stack_usage = 0
 177               		.loc 1 157 74 view .LVU42
 178               		.loc 1 157 87 is_stmt 0 view .LVU43
 179 0000 81E0      		ldi r24,lo8(1)
 180               	.LVL22:
 181               	/* epilogue start */
 182               		.loc 1 157 87 view .LVU44
 183 0002 0895      		ret
 184               		.cfi_endproc
 185               	.LFE23:
 187               		.set	process_record_quantum.localalias,process_record_quantum
 188               		.section	.text.pre_process_record_quantum,"ax",@progbits
 189               		.weak	pre_process_record_quantum
 191               	pre_process_record_quantum:
 192               	.LFB47:
 193               		.cfi_startproc
 194               	/* prologue: function */
 195               	/* frame size = 0 */
 196               	/* stack size = 0 */
 197               	.L__stack_usage = 0
 198 0000 0C94 0000 		jmp process_record_quantum.localalias
 199               		.cfi_endproc
 200               	.LFE47:
 202               		.section	.text.action_exec,"ax",@progbits
 203               	.global	action_exec
 205               	action_exec:
 206               	.LFB20:
  64:quantum/action.c ****     if (!IS_NOEVENT(event)) {
 207               		.loc 1 64 36 is_stmt 1 view -0
 208               		.cfi_startproc
 209 0000 EF92      		push r14
 210               	.LCFI2:
 211               		.cfi_def_cfa_offset 3
 212               		.cfi_offset 14, -2
 213 0002 FF92      		push r15
 214               	.LCFI3:
 215               		.cfi_def_cfa_offset 4
 216               		.cfi_offset 15, -3
 217 0004 0F93      		push r16
 218               	.LCFI4:
 219               		.cfi_def_cfa_offset 5
 220               		.cfi_offset 16, -4
 221 0006 1F93      		push r17
 222               	.LCFI5:
 223               		.cfi_def_cfa_offset 6
 224               		.cfi_offset 17, -5
 225 0008 CF93      		push r28
 226               	.LCFI6:
 227               		.cfi_def_cfa_offset 7
 228               		.cfi_offset 28, -6
 229 000a DF93      		push r29
 230               	.LCFI7:
 231               		.cfi_def_cfa_offset 8
 232               		.cfi_offset 29, -7
 233 000c CDB7      		in r28,__SP_L__
 234 000e DEB7      		in r29,__SP_H__
 235               	.LCFI8:
 236               		.cfi_def_cfa_register 28
 237 0010 2B97      		sbiw r28,11
 238               	.LCFI9:
 239               		.cfi_def_cfa_offset 19
 240 0012 0FB6      		in __tmp_reg__,__SREG__
 241 0014 F894      		cli
 242 0016 DEBF      		out __SP_H__,r29
 243 0018 0FBE      		out __SREG__,__tmp_reg__
 244 001a CDBF      		out __SP_L__,r28
 245               	/* prologue: function */
 246               	/* frame size = 11 */
 247               	/* stack size = 17 */
 248               	.L__stack_usage = 17
 249 001c 042F      		mov r16,r20
 250 001e 4F83      		std Y+7,r20
 251 0020 152F      		mov r17,r21
 252 0022 5887      		std Y+8,r21
 253 0024 6987      		std Y+9,r22
 254 0026 7A87      		std Y+10,r23
 255 0028 8B87      		std Y+11,r24
  65:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
 256               		.loc 1 65 5 view .LVU46
 257               	.LVL23:
  65:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
 258               		.loc 1 65 5 is_stmt 0 view .LVU47
 259 002a EA84      		ldd r14,Y+10
 260 002c FB84      		ldd r15,Y+11
 261               	.LVL24:
 262               	.LBB60:
 263               	.LBI60:
 264               		.file 2 "quantum/keyboard.h"
   1:quantum/keyboard.h **** /*
   2:quantum/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:quantum/keyboard.h **** 
   4:quantum/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:quantum/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:quantum/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/keyboard.h **** (at your option) any later version.
   8:quantum/keyboard.h **** 
   9:quantum/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:quantum/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/keyboard.h **** GNU General Public License for more details.
  13:quantum/keyboard.h **** 
  14:quantum/keyboard.h **** You should have received a copy of the GNU General Public License
  15:quantum/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/keyboard.h **** */
  17:quantum/keyboard.h **** 
  18:quantum/keyboard.h **** #pragma once
  19:quantum/keyboard.h **** 
  20:quantum/keyboard.h **** #include <stdbool.h>
  21:quantum/keyboard.h **** #include <stdint.h>
  22:quantum/keyboard.h **** 
  23:quantum/keyboard.h **** #ifdef __cplusplus
  24:quantum/keyboard.h **** extern "C" {
  25:quantum/keyboard.h **** #endif
  26:quantum/keyboard.h **** 
  27:quantum/keyboard.h **** /* key matrix position */
  28:quantum/keyboard.h **** typedef struct {
  29:quantum/keyboard.h ****     uint8_t col;
  30:quantum/keyboard.h ****     uint8_t row;
  31:quantum/keyboard.h **** } keypos_t;
  32:quantum/keyboard.h **** 
  33:quantum/keyboard.h **** /* key event */
  34:quantum/keyboard.h **** typedef struct {
  35:quantum/keyboard.h ****     keypos_t key;
  36:quantum/keyboard.h ****     bool     pressed;
  37:quantum/keyboard.h ****     uint16_t time;
  38:quantum/keyboard.h **** } keyevent_t;
  39:quantum/keyboard.h **** 
  40:quantum/keyboard.h **** /* equivalent test of keypos_t */
  41:quantum/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  42:quantum/keyboard.h **** 
  43:quantum/keyboard.h **** /* Rules for No Event:
  44:quantum/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  45:quantum/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  46:quantum/keyboard.h ****  */
  47:quantum/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 265               		.loc 2 47 20 is_stmt 1 view .LVU48
 266               		.loc 2 47 51 view .LVU49
 267               		.loc 2 47 51 is_stmt 0 view .LVU50
 268               	.LBE60:
  69:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 269               		.loc 1 69 19 is_stmt 1 view .LVU51
  75:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
 270               		.loc 1 75 5 view .LVU52
  75:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
 271               		.loc 1 75 8 is_stmt 0 view .LVU53
 272 002e 6111      		cpse r22,__zero_reg__
  77:quantum/action.c ****     }
 273               		.loc 1 77 9 is_stmt 1 view .LVU54
 274 0030 0E94 0000 		call clear_weak_mods
 275               	.LVL25:
 276               	.L13:
  81:quantum/action.c ****         process_hand_swap(&event);
 277               		.loc 1 81 5 view .LVU55
 278               	.LBB61:
 279               	.LBI61:
 280               		.loc 2 47 20 view .LVU56
 281               	.LBB62:
 282               		.loc 2 47 51 view .LVU57
 283               		.loc 2 47 74 is_stmt 0 view .LVU58
 284 0034 EF28      		or r14,r15
 285 0036 01F0      		breq .L14
 286 0038 1023      		and r17,r16
 287               	.LVL26:
 288               		.loc 2 47 74 view .LVU59
 289 003a 1F3F      		cpi r17,lo8(-1)
 290 003c 01F4      		brne .L15
 291               	.LVL27:
 292               	.L14:
 293               		.loc 2 47 74 view .LVU60
 294               	.LBE62:
 295               	.LBE61:
  86:quantum/action.c **** 
 296               		.loc 1 86 5 is_stmt 1 view .LVU61
  86:quantum/action.c **** 
 297               		.loc 1 86 17 is_stmt 0 view .LVU62
 298 003e 1E82      		std Y+6,__zero_reg__
 299 0040 85E0      		ldi r24,lo8(5)
 300 0042 FE01      		movw r30,r28
 301 0044 3796      		adiw r30,7
 302 0046 DE01      		movw r26,r28
 303 0048 1196      		adiw r26,1
 304               		0:
 305 004a 0190      		ld r0,Z+
 306 004c 0D92      		st X+,r0
 307 004e 8A95      		dec r24
 308 0050 01F4      		brne 0b
 105:quantum/action.c ****         action_tapping_process(record);
 309               		.loc 1 105 5 is_stmt 1 view .LVU63
 310 0052 8981      		ldd r24,Y+1
 311               	.LVL28:
 105:quantum/action.c ****         action_tapping_process(record);
 312               		.loc 1 105 5 is_stmt 0 view .LVU64
 313 0054 9A81      		ldd r25,Y+2
 314               	.LVL29:
 315               	.LBB63:
 316               	.LBI63:
 317               		.loc 2 47 20 is_stmt 1 view .LVU65
 318               	.LBB64:
 319               		.loc 2 47 51 view .LVU66
 320               		.loc 2 47 74 is_stmt 0 view .LVU67
 321 0056 2C81      		ldd r18,Y+4
 322 0058 3D81      		ldd r19,Y+5
 323 005a 232B      		or r18,r19
 324 005c 01F4      		brne .L16
 325               	.LVL30:
 326               	.L18:
 327               		.loc 2 47 74 view .LVU68
 328               	.LBE64:
 329               	.LBE63:
 106:quantum/action.c ****     }
 330               		.loc 1 106 9 is_stmt 1 view .LVU69
 331 005e 4981      		ldd r20,Y+1
 332 0060 5A81      		ldd r21,Y+2
 333 0062 6B81      		ldd r22,Y+3
 334 0064 7C81      		ldd r23,Y+4
 335 0066 8D81      		ldd r24,Y+5
 336 0068 9E81      		ldd r25,Y+6
 337 006a 0E94 0000 		call action_tapping_process
 338               	.LVL31:
 339               	.L12:
 340               	/* epilogue start */
 118:quantum/action.c **** 
 341               		.loc 1 118 1 is_stmt 0 view .LVU70
 342 006e 2B96      		adiw r28,11
 343 0070 0FB6      		in __tmp_reg__,__SREG__
 344 0072 F894      		cli
 345 0074 DEBF      		out __SP_H__,r29
 346 0076 0FBE      		out __SREG__,__tmp_reg__
 347 0078 CDBF      		out __SP_L__,r28
 348 007a DF91      		pop r29
 349 007c CF91      		pop r28
 350 007e 1F91      		pop r17
 351 0080 0F91      		pop r16
 352 0082 FF90      		pop r15
 353 0084 EF90      		pop r14
 354 0086 0895      		ret
 355               	.LVL32:
 356               	.L16:
 357               	.LBB66:
 358               	.LBB65:
 359               		.loc 2 47 74 view .LVU71
 360 0088 8923      		and r24,r25
 361               	.LVL33:
 362               		.loc 2 47 74 view .LVU72
 363 008a 8F3F      		cpi r24,lo8(-1)
 364 008c 01F0      		breq .L18
 365               	.LVL34:
 366               		.loc 2 47 74 view .LVU73
 367               	.LBE65:
 368               	.LBE66:
 105:quantum/action.c ****         action_tapping_process(record);
 369               		.loc 1 105 37 view .LVU74
 370 008e CE01      		movw r24,r28
 371 0090 0196      		adiw r24,1
 372 0092 0E94 0000 		call pre_process_record_quantum
 373               	.LVL35:
 105:quantum/action.c ****         action_tapping_process(record);
 374               		.loc 1 105 34 view .LVU75
 375 0096 8111      		cpse r24,__zero_reg__
 376 0098 00C0      		rjmp .L18
 377 009a 00C0      		rjmp .L12
 378               	.LVL36:
 379               	.L15:
  82:quantum/action.c ****     }
 380               		.loc 1 82 9 is_stmt 1 view .LVU76
 381 009c CE01      		movw r24,r28
 382 009e 0796      		adiw r24,7
 383 00a0 0E94 0000 		call process_hand_swap
 384               	.LVL37:
 385 00a4 00C0      		rjmp .L14
 386               		.cfi_endproc
 387               	.LFE20:
 389               		.section	.text.post_process_record_quantum,"ax",@progbits
 390               		.weak	post_process_record_quantum
 392               	post_process_record_quantum:
 393               	.LVL38:
 394               	.LFB24:
 158:quantum/action.c **** 
 159:quantum/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 395               		.loc 1 159 77 view -0
 396               		.cfi_startproc
 397               	/* prologue: function */
 398               	/* frame size = 0 */
 399               	/* stack size = 0 */
 400               	.L__stack_usage = 0
 401               		.loc 1 159 78 view .LVU78
 402               	/* epilogue start */
 403 0000 0895      		ret
 404               		.cfi_endproc
 405               	.LFE24:
 407               		.section	.text.process_record_tap_hint,"ax",@progbits
 408               	.global	process_record_tap_hint
 410               	process_record_tap_hint:
 411               	.LVL39:
 412               	.LFB25:
 160:quantum/action.c **** 
 161:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 162:quantum/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:quantum/action.c ****  *
 164:quantum/action.c ****  * FIXME: Needs documentation.
 165:quantum/action.c ****  */
 166:quantum/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 413               		.loc 1 166 51 view -0
 414               		.cfi_startproc
 415               	/* prologue: function */
 416               	/* frame size = 0 */
 417               	/* stack size = 0 */
 418               	.L__stack_usage = 0
 167:quantum/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 419               		.loc 1 167 5 view .LVU80
 420               		.loc 1 167 23 is_stmt 0 view .LVU81
 421 0000 FC01      		movw r30,r24
 422 0002 8081      		ld r24,Z
 423 0004 9181      		ldd r25,Z+1
 424               	.LVL40:
 425               		.loc 1 167 23 view .LVU82
 426 0006 0E94 0000 		call layer_switch_get_action
 427               	.LVL41:
 168:quantum/action.c **** 
 169:quantum/action.c ****     switch (action.kind.id) {
 428               		.loc 1 169 5 is_stmt 1 view .LVU83
 429               		.loc 1 169 24 is_stmt 0 view .LVU84
 430 000a 9295      		swap r25
 431 000c 9F70      		andi r25,lo8(15)
 432               		.loc 1 169 5 view .LVU85
 433 000e 9630      		cpi r25,lo8(6)
 434 0010 01F4      		brne .L31
 170:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:quantum/action.c ****         case ACT_SWAP_HANDS:
 172:quantum/action.c ****             switch (action.swap.code) {
 435               		.loc 1 172 13 is_stmt 1 view .LVU86
 436               	.LVL42:
 437               		.loc 1 172 13 is_stmt 0 view .LVU87
 438 0012 863F      		cpi r24,lo8(-10)
 439 0014 01F0      		breq .L31
 173:quantum/action.c ****                 case OP_SH_ONESHOT:
 174:quantum/action.c ****                     break;
 175:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:quantum/action.c ****                 default:
 177:quantum/action.c ****                     swap_hands = !swap_hands;
 440               		.loc 1 177 21 is_stmt 1 view .LVU88
 441 0016 8091 0000 		lds r24,swap_hands
 442               		.loc 1 177 21 is_stmt 0 view .LVU89
 443 001a 91E0      		ldi r25,lo8(1)
 444 001c 8927      		eor r24,r25
 445               		.loc 1 177 32 view .LVU90
 446 001e 8093 0000 		sts swap_hands,r24
 178:quantum/action.c ****                     swap_held  = true;
 447               		.loc 1 178 21 is_stmt 1 view .LVU91
 448               		.loc 1 178 32 is_stmt 0 view .LVU92
 449 0022 9093 0000 		sts swap_held,r25
 450               	.L31:
 451               	/* epilogue start */
 179:quantum/action.c ****             }
 180:quantum/action.c ****             break;
 181:quantum/action.c **** #    endif
 182:quantum/action.c ****     }
 183:quantum/action.c **** }
 452               		.loc 1 183 1 discriminator 1 view .LVU93
 453 0026 0895      		ret
 454               		.cfi_endproc
 455               	.LFE25:
 457               		.section	.text.register_code,"ax",@progbits
 458               	.global	register_code
 460               	register_code:
 461               	.LVL43:
 462               	.LFB29:
 184:quantum/action.c **** #endif
 185:quantum/action.c **** 
 186:quantum/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:quantum/action.c ****  *
 188:quantum/action.c ****  * FIXME: Needs documentation.
 189:quantum/action.c ****  */
 190:quantum/action.c **** void process_record(keyrecord_t *record) {
 191:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 192:quantum/action.c ****         return;
 193:quantum/action.c ****     }
 194:quantum/action.c **** 
 195:quantum/action.c ****     if (!process_record_quantum(record)) {
 196:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 197:quantum/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:quantum/action.c ****         }
 200:quantum/action.c **** #endif
 201:quantum/action.c ****         return;
 202:quantum/action.c ****     }
 203:quantum/action.c **** 
 204:quantum/action.c ****     process_record_handler(record);
 205:quantum/action.c ****     post_process_record_quantum(record);
 206:quantum/action.c **** }
 207:quantum/action.c **** 
 208:quantum/action.c **** void process_record_handler(keyrecord_t *record) {
 209:quantum/action.c **** #ifdef COMBO_ENABLE
 210:quantum/action.c ****     action_t action;
 211:quantum/action.c ****     if (record->keycode) {
 212:quantum/action.c ****         action = action_for_keycode(record->keycode);
 213:quantum/action.c ****     } else {
 214:quantum/action.c ****         action = store_or_get_action(record->event.pressed, record->event.key);
 215:quantum/action.c ****     }
 216:quantum/action.c **** #else
 217:quantum/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 218:quantum/action.c **** #endif
 219:quantum/action.c ****     dprint("ACTION: ");
 220:quantum/action.c ****     debug_action(action);
 221:quantum/action.c **** #ifndef NO_ACTION_LAYER
 222:quantum/action.c ****     dprint(" layer_state: ");
 223:quantum/action.c ****     layer_debug();
 224:quantum/action.c ****     dprint(" default_layer_state: ");
 225:quantum/action.c ****     default_layer_debug();
 226:quantum/action.c **** #endif
 227:quantum/action.c ****     dprintln();
 228:quantum/action.c **** 
 229:quantum/action.c ****     process_action(record, action);
 230:quantum/action.c **** }
 231:quantum/action.c **** 
 232:quantum/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 233:quantum/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 234:quantum/action.c **** #    ifdef PS2_MOUSE_ENABLE
 235:quantum/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 236:quantum/action.c **** #    endif
 237:quantum/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 238:quantum/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 239:quantum/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 240:quantum/action.c ****     pointing_device_set_report(currentReport);
 241:quantum/action.c **** #    endif
 242:quantum/action.c **** }
 243:quantum/action.c **** #endif
 244:quantum/action.c **** 
 245:quantum/action.c **** /** \brief Take an action and processes it.
 246:quantum/action.c ****  *
 247:quantum/action.c ****  * FIXME: Needs documentation.
 248:quantum/action.c ****  */
 249:quantum/action.c **** void process_action(keyrecord_t *record, action_t action) {
 250:quantum/action.c ****     keyevent_t event = record->event;
 251:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 252:quantum/action.c ****     uint8_t tap_count = record->tap.count;
 253:quantum/action.c **** #endif
 254:quantum/action.c **** 
 255:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 256:quantum/action.c ****     bool do_release_oneshot = false;
 257:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 258:quantum/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 259:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 260:quantum/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 261:quantum/action.c **** #    endif
 262:quantum/action.c ****     ) {
 263:quantum/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 264:quantum/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 265:quantum/action.c ****     }
 266:quantum/action.c **** #endif
 267:quantum/action.c **** 
 268:quantum/action.c ****     switch (action.kind.id) {
 269:quantum/action.c ****         /* Key and Mods */
 270:quantum/action.c ****         case ACT_LMODS:
 271:quantum/action.c ****         case ACT_RMODS: {
 272:quantum/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 273:quantum/action.c ****             if (event.pressed) {
 274:quantum/action.c ****                 if (mods) {
 275:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 276:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 277:quantum/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 278:quantum/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 279:quantum/action.c ****                         add_mods(mods);
 280:quantum/action.c ****                     } else {
 281:quantum/action.c ****                         add_weak_mods(mods);
 282:quantum/action.c ****                     }
 283:quantum/action.c ****                     send_keyboard_report();
 284:quantum/action.c ****                 }
 285:quantum/action.c ****                 register_code(action.key.code);
 286:quantum/action.c ****             } else {
 287:quantum/action.c ****                 unregister_code(action.key.code);
 288:quantum/action.c ****                 if (mods) {
 289:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 290:quantum/action.c ****                         del_mods(mods);
 291:quantum/action.c ****                     } else {
 292:quantum/action.c ****                         del_weak_mods(mods);
 293:quantum/action.c ****                     }
 294:quantum/action.c ****                     send_keyboard_report();
 295:quantum/action.c ****                 }
 296:quantum/action.c ****             }
 297:quantum/action.c ****         } break;
 298:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 299:quantum/action.c ****         case ACT_LMODS_TAP:
 300:quantum/action.c ****         case ACT_RMODS_TAP: {
 301:quantum/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 302:quantum/action.c ****             switch (action.layer_tap.code) {
 303:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 304:quantum/action.c ****                 case MODS_ONESHOT:
 305:quantum/action.c ****                     // Oneshot modifier
 306:quantum/action.c ****                     if (event.pressed) {
 307:quantum/action.c ****                         if (tap_count == 0) {
 308:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 309:quantum/action.c ****                             register_mods(mods | get_oneshot_mods());
 310:quantum/action.c ****                         } else if (tap_count == 1) {
 311:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 312:quantum/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 313:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 314:quantum/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 315:quantum/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 316:quantum/action.c ****                             clear_oneshot_mods();
 317:quantum/action.c ****                             set_oneshot_locked_mods(mods);
 318:quantum/action.c ****                             register_mods(mods);
 319:quantum/action.c **** #        endif
 320:quantum/action.c ****                         } else {
 321:quantum/action.c ****                             register_mods(mods | get_oneshot_mods());
 322:quantum/action.c ****                         }
 323:quantum/action.c ****                     } else {
 324:quantum/action.c ****                         if (tap_count == 0) {
 325:quantum/action.c ****                             clear_oneshot_mods();
 326:quantum/action.c ****                             unregister_mods(mods);
 327:quantum/action.c ****                         } else if (tap_count == 1) {
 328:quantum/action.c ****                             // Retain Oneshot mods
 329:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 330:quantum/action.c ****                             if (mods & get_mods()) {
 331:quantum/action.c ****                                 clear_oneshot_locked_mods();
 332:quantum/action.c ****                                 clear_oneshot_mods();
 333:quantum/action.c ****                                 unregister_mods(mods);
 334:quantum/action.c ****                             }
 335:quantum/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 336:quantum/action.c ****                             // Toggle Oneshot Layer
 337:quantum/action.c **** #        endif
 338:quantum/action.c ****                         } else {
 339:quantum/action.c ****                             clear_oneshot_mods();
 340:quantum/action.c ****                             unregister_mods(mods);
 341:quantum/action.c ****                         }
 342:quantum/action.c ****                     }
 343:quantum/action.c ****                     break;
 344:quantum/action.c **** #    endif
 345:quantum/action.c ****                 case MODS_TAP_TOGGLE:
 346:quantum/action.c ****                     if (event.pressed) {
 347:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 348:quantum/action.c ****                             register_mods(mods);
 349:quantum/action.c ****                         }
 350:quantum/action.c ****                     } else {
 351:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 352:quantum/action.c ****                             unregister_mods(mods);
 353:quantum/action.c ****                         }
 354:quantum/action.c ****                     }
 355:quantum/action.c ****                     break;
 356:quantum/action.c ****                 default:
 357:quantum/action.c ****                     if (event.pressed) {
 358:quantum/action.c ****                         if (tap_count > 0) {
 359:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 360:quantum/action.c ****                             if (
 361:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 362:quantum/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 363:quantum/action.c **** #        endif
 364:quantum/action.c ****                                 record->tap.interrupted) {
 365:quantum/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 366:quantum/action.c ****                                 // ad hoc: set 0 to cancel tap
 367:quantum/action.c ****                                 record->tap.count = 0;
 368:quantum/action.c ****                                 register_mods(mods);
 369:quantum/action.c ****                             } else
 370:quantum/action.c **** #    endif
 371:quantum/action.c ****                             {
 372:quantum/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 373:quantum/action.c ****                                 register_code(action.key.code);
 374:quantum/action.c ****                             }
 375:quantum/action.c ****                         } else {
 376:quantum/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 377:quantum/action.c ****                             register_mods(mods);
 378:quantum/action.c ****                         }
 379:quantum/action.c ****                     } else {
 380:quantum/action.c ****                         if (tap_count > 0) {
 381:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 382:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 383:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 384:quantum/action.c ****                             } else {
 385:quantum/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 386:quantum/action.c ****                             }
 387:quantum/action.c ****                             unregister_code(action.key.code);
 388:quantum/action.c ****                         } else {
 389:quantum/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 390:quantum/action.c ****                             unregister_mods(mods);
 391:quantum/action.c ****                         }
 392:quantum/action.c ****                     }
 393:quantum/action.c ****                     break;
 394:quantum/action.c ****             }
 395:quantum/action.c ****         } break;
 396:quantum/action.c **** #endif
 397:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 398:quantum/action.c ****         /* other HID usage */
 399:quantum/action.c ****         case ACT_USAGE:
 400:quantum/action.c ****             switch (action.usage.page) {
 401:quantum/action.c ****                 case PAGE_SYSTEM:
 402:quantum/action.c ****                     if (event.pressed) {
 403:quantum/action.c ****                         host_system_send(action.usage.code);
 404:quantum/action.c ****                     } else {
 405:quantum/action.c ****                         host_system_send(0);
 406:quantum/action.c ****                     }
 407:quantum/action.c ****                     break;
 408:quantum/action.c ****                 case PAGE_CONSUMER:
 409:quantum/action.c ****                     if (event.pressed) {
 410:quantum/action.c ****                         host_consumer_send(action.usage.code);
 411:quantum/action.c ****                     } else {
 412:quantum/action.c ****                         host_consumer_send(0);
 413:quantum/action.c ****                     }
 414:quantum/action.c ****                     break;
 415:quantum/action.c ****             }
 416:quantum/action.c ****             break;
 417:quantum/action.c **** #endif
 418:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 419:quantum/action.c ****         /* Mouse key */
 420:quantum/action.c ****         case ACT_MOUSEKEY:
 421:quantum/action.c ****             if (event.pressed) {
 422:quantum/action.c ****                 mousekey_on(action.key.code);
 423:quantum/action.c ****             } else {
 424:quantum/action.c ****                 mousekey_off(action.key.code);
 425:quantum/action.c ****             }
 426:quantum/action.c ****             switch (action.key.code) {
 427:quantum/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 428:quantum/action.c **** #        ifdef POINTING_DEVICE_ENABLE
 429:quantum/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN8:
 430:quantum/action.c **** #        else
 431:quantum/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN3:
 432:quantum/action.c **** #        endif
 433:quantum/action.c ****                     register_button(event.pressed, MOUSE_BTN_MASK(action.key.code - KC_MS_BTN1));
 434:quantum/action.c ****                     break;
 435:quantum/action.c **** #    endif
 436:quantum/action.c ****                 default:
 437:quantum/action.c ****                     mousekey_send();
 438:quantum/action.c ****                     break;
 439:quantum/action.c ****             }
 440:quantum/action.c ****             break;
 441:quantum/action.c **** #endif
 442:quantum/action.c **** #ifndef NO_ACTION_LAYER
 443:quantum/action.c ****         case ACT_LAYER:
 444:quantum/action.c ****             if (action.layer_bitop.on == 0) {
 445:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 446:quantum/action.c ****                 if (!event.pressed) {
 447:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 448:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 449:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 450:quantum/action.c ****                     switch (action.layer_bitop.op) {
 451:quantum/action.c ****                         case OP_BIT_AND:
 452:quantum/action.c ****                             default_layer_and(bits | mask);
 453:quantum/action.c ****                             break;
 454:quantum/action.c ****                         case OP_BIT_OR:
 455:quantum/action.c ****                             default_layer_or(bits | mask);
 456:quantum/action.c ****                             break;
 457:quantum/action.c ****                         case OP_BIT_XOR:
 458:quantum/action.c ****                             default_layer_xor(bits | mask);
 459:quantum/action.c ****                             break;
 460:quantum/action.c ****                         case OP_BIT_SET:
 461:quantum/action.c ****                             default_layer_set(bits | mask);
 462:quantum/action.c ****                             break;
 463:quantum/action.c ****                     }
 464:quantum/action.c ****                 }
 465:quantum/action.c ****             } else {
 466:quantum/action.c ****                 /* Layer Bitwise Operation */
 467:quantum/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 468:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 469:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 470:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 471:quantum/action.c ****                     switch (action.layer_bitop.op) {
 472:quantum/action.c ****                         case OP_BIT_AND:
 473:quantum/action.c ****                             layer_and(bits | mask);
 474:quantum/action.c ****                             break;
 475:quantum/action.c ****                         case OP_BIT_OR:
 476:quantum/action.c ****                             layer_or(bits | mask);
 477:quantum/action.c ****                             break;
 478:quantum/action.c ****                         case OP_BIT_XOR:
 479:quantum/action.c ****                             layer_xor(bits | mask);
 480:quantum/action.c ****                             break;
 481:quantum/action.c ****                         case OP_BIT_SET:
 482:quantum/action.c ****                             layer_state_set(bits | mask);
 483:quantum/action.c ****                             break;
 484:quantum/action.c ****                     }
 485:quantum/action.c ****                 }
 486:quantum/action.c ****             }
 487:quantum/action.c ****             break;
 488:quantum/action.c ****         case ACT_LAYER_MODS:
 489:quantum/action.c ****             if (event.pressed) {
 490:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 491:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 492:quantum/action.c ****             } else {
 493:quantum/action.c ****                 unregister_mods(action.layer_mods.mods);
 494:quantum/action.c ****                 layer_off(action.layer_mods.layer);
 495:quantum/action.c ****             }
 496:quantum/action.c ****             break;
 497:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 498:quantum/action.c ****         case ACT_LAYER_TAP:
 499:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
 500:quantum/action.c ****             switch (action.layer_tap.code) {
 501:quantum/action.c ****                 case OP_TAP_TOGGLE:
 502:quantum/action.c ****                     /* tap toggle */
 503:quantum/action.c ****                     if (event.pressed) {
 504:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 505:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 506:quantum/action.c ****                         }
 507:quantum/action.c ****                     } else {
 508:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 509:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 510:quantum/action.c ****                         }
 511:quantum/action.c ****                     }
 512:quantum/action.c ****                     break;
 513:quantum/action.c ****                 case OP_ON_OFF:
 514:quantum/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 515:quantum/action.c ****                     break;
 516:quantum/action.c ****                 case OP_OFF_ON:
 517:quantum/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 518:quantum/action.c ****                     break;
 519:quantum/action.c ****                 case OP_SET_CLEAR:
 520:quantum/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 521:quantum/action.c ****                     break;
 522:quantum/action.c **** #        ifndef NO_ACTION_ONESHOT
 523:quantum/action.c ****                 case OP_ONESHOT:
 524:quantum/action.c ****                     // Oneshot modifier
 525:quantum/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 526:quantum/action.c ****                     do_release_oneshot = false;
 527:quantum/action.c ****                     if (event.pressed) {
 528:quantum/action.c ****                         del_mods(get_oneshot_locked_mods());
 529:quantum/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 530:quantum/action.c ****                             reset_oneshot_layer();
 531:quantum/action.c ****                             layer_off(action.layer_tap.val);
 532:quantum/action.c ****                             break;
 533:quantum/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 534:quantum/action.c ****                             layer_on(action.layer_tap.val);
 535:quantum/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 536:quantum/action.c ****                         }
 537:quantum/action.c ****                     } else {
 538:quantum/action.c ****                         add_mods(get_oneshot_locked_mods());
 539:quantum/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 540:quantum/action.c ****                             reset_oneshot_layer();
 541:quantum/action.c ****                             clear_oneshot_locked_mods();
 542:quantum/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 543:quantum/action.c ****                         } else {
 544:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 545:quantum/action.c ****                         }
 546:quantum/action.c ****                     }
 547:quantum/action.c **** #            else
 548:quantum/action.c ****                     if (event.pressed) {
 549:quantum/action.c ****                         layer_on(action.layer_tap.val);
 550:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 551:quantum/action.c ****                     } else {
 552:quantum/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 553:quantum/action.c ****                         if (tap_count > 1) {
 554:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 555:quantum/action.c ****                         }
 556:quantum/action.c ****                     }
 557:quantum/action.c **** #            endif
 558:quantum/action.c ****                     break;
 559:quantum/action.c **** #        endif
 560:quantum/action.c ****                 default:
 561:quantum/action.c ****                     /* tap key */
 562:quantum/action.c ****                     if (event.pressed) {
 563:quantum/action.c ****                         if (tap_count > 0) {
 564:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 565:quantum/action.c ****                             register_code(action.layer_tap.code);
 566:quantum/action.c ****                         } else {
 567:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 568:quantum/action.c ****                             layer_on(action.layer_tap.val);
 569:quantum/action.c ****                         }
 570:quantum/action.c ****                     } else {
 571:quantum/action.c ****                         if (tap_count > 0) {
 572:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 573:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 574:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 575:quantum/action.c ****                             } else {
 576:quantum/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 577:quantum/action.c ****                             }
 578:quantum/action.c ****                             unregister_code(action.layer_tap.code);
 579:quantum/action.c ****                         } else {
 580:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 581:quantum/action.c ****                             layer_off(action.layer_tap.val);
 582:quantum/action.c ****                         }
 583:quantum/action.c ****                     }
 584:quantum/action.c ****                     break;
 585:quantum/action.c ****             }
 586:quantum/action.c ****             break;
 587:quantum/action.c **** #    endif
 588:quantum/action.c **** #endif
 589:quantum/action.c ****             /* Extentions */
 590:quantum/action.c **** #ifndef NO_ACTION_MACRO
 591:quantum/action.c ****         case ACT_MACRO:
 592:quantum/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 593:quantum/action.c ****             break;
 594:quantum/action.c **** #endif
 595:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 596:quantum/action.c ****         case ACT_SWAP_HANDS:
 597:quantum/action.c ****             switch (action.swap.code) {
 598:quantum/action.c ****                 case OP_SH_TOGGLE:
 599:quantum/action.c ****                     if (event.pressed) {
 600:quantum/action.c ****                         swap_hands = !swap_hands;
 601:quantum/action.c ****                     }
 602:quantum/action.c ****                     break;
 603:quantum/action.c ****                 case OP_SH_ON_OFF:
 604:quantum/action.c ****                     swap_hands = event.pressed;
 605:quantum/action.c ****                     break;
 606:quantum/action.c ****                 case OP_SH_OFF_ON:
 607:quantum/action.c ****                     swap_hands = !event.pressed;
 608:quantum/action.c ****                     break;
 609:quantum/action.c ****                 case OP_SH_ON:
 610:quantum/action.c ****                     if (!event.pressed) {
 611:quantum/action.c ****                         swap_hands = true;
 612:quantum/action.c ****                     }
 613:quantum/action.c ****                     break;
 614:quantum/action.c ****                 case OP_SH_OFF:
 615:quantum/action.c ****                     if (!event.pressed) {
 616:quantum/action.c ****                         swap_hands = false;
 617:quantum/action.c ****                     }
 618:quantum/action.c ****                     break;
 619:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 620:quantum/action.c ****                 case OP_SH_ONESHOT:
 621:quantum/action.c ****                     if (event.pressed) {
 622:quantum/action.c ****                         set_oneshot_swaphands();
 623:quantum/action.c ****                     } else {
 624:quantum/action.c ****                         release_oneshot_swaphands();
 625:quantum/action.c ****                     }
 626:quantum/action.c ****                     break;
 627:quantum/action.c **** #    endif
 628:quantum/action.c **** 
 629:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 630:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
 631:quantum/action.c ****                     /* tap toggle */
 632:quantum/action.c **** 
 633:quantum/action.c ****                     if (event.pressed) {
 634:quantum/action.c ****                         if (swap_held) {
 635:quantum/action.c ****                             swap_held = false;
 636:quantum/action.c ****                         } else {
 637:quantum/action.c ****                             swap_hands = !swap_hands;
 638:quantum/action.c ****                         }
 639:quantum/action.c ****                     } else {
 640:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 641:quantum/action.c ****                             swap_hands = !swap_hands;
 642:quantum/action.c ****                         }
 643:quantum/action.c ****                     }
 644:quantum/action.c ****                     break;
 645:quantum/action.c ****                 default:
 646:quantum/action.c ****                     /* tap key */
 647:quantum/action.c ****                     if (tap_count > 0) {
 648:quantum/action.c ****                         if (swap_held) {
 649:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 650:quantum/action.c ****                             swap_held  = false;
 651:quantum/action.c ****                         }
 652:quantum/action.c ****                         if (event.pressed) {
 653:quantum/action.c ****                             register_code(action.swap.code);
 654:quantum/action.c ****                         } else {
 655:quantum/action.c ****                             wait_ms(TAP_CODE_DELAY);
 656:quantum/action.c ****                             unregister_code(action.swap.code);
 657:quantum/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 658:quantum/action.c ****                         }
 659:quantum/action.c ****                     } else {
 660:quantum/action.c ****                         if (swap_held && !event.pressed) {
 661:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 662:quantum/action.c ****                             swap_held  = false;
 663:quantum/action.c ****                         }
 664:quantum/action.c ****                     }
 665:quantum/action.c **** #    endif
 666:quantum/action.c ****             }
 667:quantum/action.c **** #endif
 668:quantum/action.c **** #ifndef NO_ACTION_FUNCTION
 669:quantum/action.c ****         case ACT_FUNCTION:
 670:quantum/action.c ****             action_function(record, action.func.id, action.func.opt);
 671:quantum/action.c ****             break;
 672:quantum/action.c **** #endif
 673:quantum/action.c ****         default:
 674:quantum/action.c ****             break;
 675:quantum/action.c ****     }
 676:quantum/action.c **** 
 677:quantum/action.c **** #ifndef NO_ACTION_LAYER
 678:quantum/action.c ****     // if this event is a layer action, update the leds
 679:quantum/action.c ****     switch (action.kind.id) {
 680:quantum/action.c ****         case ACT_LAYER:
 681:quantum/action.c ****         case ACT_LAYER_MODS:
 682:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 683:quantum/action.c ****         case ACT_LAYER_TAP:
 684:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
 685:quantum/action.c **** #    endif
 686:quantum/action.c ****             led_set(host_keyboard_leds());
 687:quantum/action.c ****             break;
 688:quantum/action.c ****         default:
 689:quantum/action.c ****             break;
 690:quantum/action.c ****     }
 691:quantum/action.c **** #endif
 692:quantum/action.c **** 
 693:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 694:quantum/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 695:quantum/action.c ****     if (!is_tap_action(action)) {
 696:quantum/action.c ****         retro_tapping_counter = 0;
 697:quantum/action.c ****     } else {
 698:quantum/action.c ****         if (event.pressed) {
 699:quantum/action.c ****             if (tap_count > 0) {
 700:quantum/action.c ****                 retro_tapping_counter = 0;
 701:quantum/action.c ****             }
 702:quantum/action.c ****         } else {
 703:quantum/action.c ****             if (tap_count > 0) {
 704:quantum/action.c ****                 retro_tapping_counter = 0;
 705:quantum/action.c ****             } else {
 706:quantum/action.c ****                 if (
 707:quantum/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 708:quantum/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 709:quantum/action.c **** #        endif
 710:quantum/action.c ****                     retro_tapping_counter == 2) {
 711:quantum/action.c ****                     tap_code(action.layer_tap.code);
 712:quantum/action.c ****                 }
 713:quantum/action.c ****                 retro_tapping_counter = 0;
 714:quantum/action.c ****             }
 715:quantum/action.c ****         }
 716:quantum/action.c ****     }
 717:quantum/action.c **** #    endif
 718:quantum/action.c **** #endif
 719:quantum/action.c **** 
 720:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 721:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 722:quantum/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 723:quantum/action.c ****         use_oneshot_swaphands();
 724:quantum/action.c ****     }
 725:quantum/action.c **** #    endif
 726:quantum/action.c **** #endif
 727:quantum/action.c **** 
 728:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 729:quantum/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 730:quantum/action.c ****      * key before we leave the layer or no key up event will be generated.
 731:quantum/action.c ****      */
 732:quantum/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 733:quantum/action.c ****         record->event.pressed = false;
 734:quantum/action.c ****         layer_on(get_oneshot_layer());
 735:quantum/action.c ****         process_record(record);
 736:quantum/action.c ****         layer_off(get_oneshot_layer());
 737:quantum/action.c ****     }
 738:quantum/action.c **** #endif
 739:quantum/action.c **** }
 740:quantum/action.c **** 
 741:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 742:quantum/action.c ****  *
 743:quantum/action.c ****  * FIXME: Needs documentation.
 744:quantum/action.c ****  */
 745:quantum/action.c **** void register_code(uint8_t code) {
 463               		.loc 1 745 34 is_stmt 1 view -0
 464               		.cfi_startproc
 465               		.loc 1 745 34 is_stmt 0 view .LVU95
 466 0000 CF93      		push r28
 467               	.LCFI10:
 468               		.cfi_def_cfa_offset 3
 469               		.cfi_offset 28, -2
 470               	/* prologue: function */
 471               	/* frame size = 0 */
 472               	/* stack size = 1 */
 473               	.L__stack_usage = 1
 474 0002 C82F      		mov r28,r24
 746:quantum/action.c ****     if (code == KC_NO) {
 475               		.loc 1 746 5 is_stmt 1 view .LVU96
 476               		.loc 1 746 8 is_stmt 0 view .LVU97
 477 0004 8823      		tst r24
 478 0006 01F0      		breq .L35
 747:quantum/action.c ****         return;
 748:quantum/action.c ****     }
 749:quantum/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 750:quantum/action.c ****     else if (KC_LOCKING_CAPS == code) {
 751:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 752:quantum/action.c ****         // Resync: ignore if caps lock already is on
 753:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 754:quantum/action.c **** #    endif
 755:quantum/action.c ****         add_key(KC_CAPSLOCK);
 756:quantum/action.c ****         send_keyboard_report();
 757:quantum/action.c ****         wait_ms(100);
 758:quantum/action.c ****         del_key(KC_CAPSLOCK);
 759:quantum/action.c ****         send_keyboard_report();
 760:quantum/action.c ****     }
 761:quantum/action.c **** 
 762:quantum/action.c ****     else if (KC_LOCKING_NUM == code) {
 763:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 764:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 765:quantum/action.c **** #    endif
 766:quantum/action.c ****         add_key(KC_NUMLOCK);
 767:quantum/action.c ****         send_keyboard_report();
 768:quantum/action.c ****         wait_ms(100);
 769:quantum/action.c ****         del_key(KC_NUMLOCK);
 770:quantum/action.c ****         send_keyboard_report();
 771:quantum/action.c ****     }
 772:quantum/action.c **** 
 773:quantum/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 774:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 775:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 776:quantum/action.c **** #    endif
 777:quantum/action.c ****         add_key(KC_SCROLLLOCK);
 778:quantum/action.c ****         send_keyboard_report();
 779:quantum/action.c ****         wait_ms(100);
 780:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 781:quantum/action.c ****         send_keyboard_report();
 782:quantum/action.c ****     }
 783:quantum/action.c **** #endif
 784:quantum/action.c **** 
 785:quantum/action.c ****     else if IS_KEY (code) {
 479               		.loc 1 785 10 is_stmt 1 view .LVU98
 480               		.loc 1 785 13 is_stmt 0 view .LVU99
 481 0008 8CEF      		ldi r24,lo8(-4)
 482               	.LVL44:
 483               		.loc 1 785 13 view .LVU100
 484 000a 8C0F      		add r24,r28
 485 000c 813A      		cpi r24,lo8(-95)
 486 000e 00F4      		brsh .L37
 786:quantum/action.c ****         // TODO: should push command_proc out of this block?
 787:quantum/action.c ****         if (command_proc(code)) return;
 487               		.loc 1 787 9 is_stmt 1 view .LVU101
 788:quantum/action.c **** 
 789:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 790:quantum/action.c **** /* TODO: remove
 791:quantum/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 792:quantum/action.c ****             uint8_t tmp_mods = get_mods();
 793:quantum/action.c ****             add_mods(oneshot_state.mods);
 794:quantum/action.c **** 
 795:quantum/action.c ****             add_key(code);
 796:quantum/action.c ****             send_keyboard_report();
 797:quantum/action.c **** 
 798:quantum/action.c ****             set_mods(tmp_mods);
 799:quantum/action.c ****             send_keyboard_report();
 800:quantum/action.c ****             oneshot_cancel();
 801:quantum/action.c ****         } else
 802:quantum/action.c **** */
 803:quantum/action.c **** #endif
 804:quantum/action.c ****         {
 805:quantum/action.c ****             // Force a new key press if the key is already pressed
 806:quantum/action.c ****             // without this, keys with the same keycode, but different
 807:quantum/action.c ****             // modifiers will be reported incorrectly, see issue #1708
 808:quantum/action.c ****             if (is_key_pressed(keyboard_report, code)) {
 488               		.loc 1 808 13 view .LVU102
 489               		.loc 1 808 17 is_stmt 0 view .LVU103
 490 0010 6C2F      		mov r22,r28
 491 0012 8091 0000 		lds r24,keyboard_report
 492 0016 9091 0000 		lds r25,keyboard_report+1
 493 001a 0E94 0000 		call is_key_pressed
 494               	.LVL45:
 495               		.loc 1 808 16 view .LVU104
 496 001e 8823      		tst r24
 497 0020 01F0      		breq .L38
 809:quantum/action.c ****                 del_key(code);
 498               		.loc 1 809 17 is_stmt 1 view .LVU105
 499 0022 8C2F      		mov r24,r28
 500 0024 0E94 0000 		call del_key
 501               	.LVL46:
 810:quantum/action.c ****                 send_keyboard_report();
 502               		.loc 1 810 17 view .LVU106
 503 0028 0E94 0000 		call send_keyboard_report
 504               	.LVL47:
 505               	.L38:
 811:quantum/action.c ****             }
 812:quantum/action.c ****             add_key(code);
 506               		.loc 1 812 13 view .LVU107
 507 002c 8C2F      		mov r24,r28
 508 002e 0E94 0000 		call add_key
 509               	.LVL48:
 813:quantum/action.c ****             send_keyboard_report();
 510               		.loc 1 813 13 view .LVU108
 511               	.L47:
 814:quantum/action.c ****         }
 815:quantum/action.c ****     } else if IS_MOD (code) {
 816:quantum/action.c ****         add_mods(MOD_BIT(code));
 817:quantum/action.c ****         send_keyboard_report();
 512               		.loc 1 817 9 view .LVU109
 513               	/* epilogue start */
 818:quantum/action.c ****     }
 819:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 820:quantum/action.c ****     else if IS_SYSTEM (code) {
 821:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 822:quantum/action.c ****     } else if IS_CONSUMER (code) {
 823:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 824:quantum/action.c ****     }
 825:quantum/action.c **** #endif
 826:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 827:quantum/action.c ****     else if IS_MOUSEKEY (code) {
 828:quantum/action.c ****         mousekey_on(code);
 829:quantum/action.c ****         mousekey_send();
 830:quantum/action.c ****     }
 831:quantum/action.c **** #endif
 832:quantum/action.c **** }
 514               		.loc 1 832 1 is_stmt 0 view .LVU110
 515 0032 CF91      		pop r28
 817:quantum/action.c ****     }
 516               		.loc 1 817 9 view .LVU111
 517 0034 0C94 0000 		jmp send_keyboard_report
 518               	.LVL49:
 519               	.L37:
 815:quantum/action.c ****         add_mods(MOD_BIT(code));
 520               		.loc 1 815 12 is_stmt 1 view .LVU112
 815:quantum/action.c ****         add_mods(MOD_BIT(code));
 521               		.loc 1 815 15 is_stmt 0 view .LVU113
 522 0038 80E2      		ldi r24,lo8(32)
 523 003a 8C0F      		add r24,r28
 524 003c 8830      		cpi r24,lo8(8)
 525 003e 00F4      		brsh .L39
 816:quantum/action.c ****         send_keyboard_report();
 526               		.loc 1 816 9 is_stmt 1 view .LVU114
 816:quantum/action.c ****         send_keyboard_report();
 527               		.loc 1 816 18 is_stmt 0 view .LVU115
 528 0040 C770      		andi r28,lo8(7)
 529               	.LVL50:
 816:quantum/action.c ****         send_keyboard_report();
 530               		.loc 1 816 9 view .LVU116
 531 0042 81E0      		ldi r24,lo8(1)
 532 0044 00C0      		rjmp 2f
 533               		1:
 534 0046 880F      		lsl r24
 535               		2:
 536 0048 CA95      		dec r28
 537 004a 02F4      		brpl 1b
 538 004c 0E94 0000 		call add_mods
 539               	.LVL51:
 540 0050 00C0      		rjmp .L47
 541               	.LVL52:
 542               	.L39:
 820:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 543               		.loc 1 820 10 is_stmt 1 view .LVU117
 820:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 544               		.loc 1 820 13 is_stmt 0 view .LVU118
 545 0052 8BE5      		ldi r24,lo8(91)
 546 0054 8C0F      		add r24,r28
 547 0056 8330      		cpi r24,lo8(3)
 548 0058 00F4      		brsh .L40
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 549               		.loc 1 821 9 is_stmt 1 view .LVU119
 550 005a 2C2F      		mov r18,r28
 551 005c 2452      		subi r18,36
 552 005e 330B      		sbc r19,r19
 553 0060 C901      		movw r24,r18
 554               	/* epilogue start */
 555               		.loc 1 832 1 is_stmt 0 view .LVU120
 556 0062 CF91      		pop r28
 557               	.LVL53:
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 558               		.loc 1 821 9 view .LVU121
 559 0064 0C94 0000 		jmp host_system_send
 560               	.LVL54:
 561               	.L40:
 822:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 562               		.loc 1 822 12 is_stmt 1 view .LVU122
 822:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 563               		.loc 1 822 15 is_stmt 0 view .LVU123
 564 0068 C85A      		subi r28,lo8(-(88))
 565               	.LVL55:
 822:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 566               		.loc 1 822 15 view .LVU124
 567 006a C731      		cpi r28,lo8(23)
 568 006c 00F4      		brsh .L35
 823:quantum/action.c ****     }
 569               		.loc 1 823 9 is_stmt 1 view .LVU125
 570               	.LVL56:
 571               	.LBB71:
 572               	.LBI71:
 573               		.file 3 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK,
  34:tmk_core/common/report.h ****     REPORT_ID_DIGITIZER
  35:tmk_core/common/report.h **** };
  36:tmk_core/common/report.h **** 
  37:tmk_core/common/report.h **** /* Mouse buttons */
  38:tmk_core/common/report.h **** #define MOUSE_BTN_MASK(n) (1 << (n))
  39:tmk_core/common/report.h **** enum mouse_buttons {
  40:tmk_core/common/report.h ****     MOUSE_BTN1 = MOUSE_BTN_MASK(0),
  41:tmk_core/common/report.h ****     MOUSE_BTN2 = MOUSE_BTN_MASK(1),
  42:tmk_core/common/report.h ****     MOUSE_BTN3 = MOUSE_BTN_MASK(2),
  43:tmk_core/common/report.h ****     MOUSE_BTN4 = MOUSE_BTN_MASK(3),
  44:tmk_core/common/report.h ****     MOUSE_BTN5 = MOUSE_BTN_MASK(4),
  45:tmk_core/common/report.h ****     MOUSE_BTN6 = MOUSE_BTN_MASK(5),
  46:tmk_core/common/report.h ****     MOUSE_BTN7 = MOUSE_BTN_MASK(6),
  47:tmk_core/common/report.h ****     MOUSE_BTN8 = MOUSE_BTN_MASK(7)
  48:tmk_core/common/report.h **** };
  49:tmk_core/common/report.h **** 
  50:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  51:tmk_core/common/report.h ****  *
  52:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  53:tmk_core/common/report.h ****  */
  54:tmk_core/common/report.h **** enum consumer_usages {
  55:tmk_core/common/report.h ****     // 15.5 Display Controls
  56:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  57:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  58:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  59:tmk_core/common/report.h ****     // 15.7 Transport Controls
  60:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  61:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  62:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  63:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  64:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  65:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  66:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  67:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  68:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  69:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  70:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  71:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  72:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  73:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  74:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  75:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  76:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  77:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  78:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  79:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  80:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  81:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  82:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  83:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  84:tmk_core/common/report.h ****     AC_NEW                 = 0x201,
  85:tmk_core/common/report.h ****     AC_OPEN                = 0x202,
  86:tmk_core/common/report.h ****     AC_CLOSE               = 0x203,
  87:tmk_core/common/report.h ****     AC_EXIT                = 0x204,
  88:tmk_core/common/report.h ****     AC_MAXIMIZE            = 0x205,
  89:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  90:tmk_core/common/report.h ****     AC_SAVE                = 0x207,
  91:tmk_core/common/report.h ****     AC_PRINT               = 0x208,
  92:tmk_core/common/report.h ****     AC_PROPERTIES          = 0x209,
  93:tmk_core/common/report.h ****     AC_UNDO                = 0x21A,
  94:tmk_core/common/report.h ****     AC_COPY                = 0x21B,
  95:tmk_core/common/report.h ****     AC_CUT                 = 0x21C,
  96:tmk_core/common/report.h ****     AC_PASTE               = 0x21D,
  97:tmk_core/common/report.h ****     AC_SELECT_ALL          = 0x21E,
  98:tmk_core/common/report.h ****     AC_FIND                = 0x21F,
  99:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
 100:tmk_core/common/report.h ****     AC_HOME                = 0x223,
 101:tmk_core/common/report.h ****     AC_BACK                = 0x224,
 102:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
 103:tmk_core/common/report.h ****     AC_STOP                = 0x226,
 104:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
 105:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
 106:tmk_core/common/report.h **** };
 107:tmk_core/common/report.h **** 
 108:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
 109:tmk_core/common/report.h ****  *
 110:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
 111:tmk_core/common/report.h ****  */
 112:tmk_core/common/report.h **** enum desktop_usages {
 113:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
 114:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN             = 0x81,
 115:tmk_core/common/report.h ****     SYSTEM_SLEEP                  = 0x82,
 116:tmk_core/common/report.h ****     SYSTEM_WAKE_UP                = 0x83,
 117:tmk_core/common/report.h ****     SYSTEM_RESTART                = 0x8F,
 118:tmk_core/common/report.h ****     // 4.10 System Display Controls
 119:tmk_core/common/report.h ****     SYSTEM_DISPLAY_TOGGLE_INT_EXT = 0xB5
 120:tmk_core/common/report.h **** };
 121:tmk_core/common/report.h **** 
 122:tmk_core/common/report.h **** // clang-format on
 123:tmk_core/common/report.h **** 
 124:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 125:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 126:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 127:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 128:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 129:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 130:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 131:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 132:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 133:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 134:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 135:tmk_core/common/report.h **** #    else
 136:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 137:tmk_core/common/report.h **** #    endif
 138:tmk_core/common/report.h **** #endif
 139:tmk_core/common/report.h **** 
 140:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 141:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 142:tmk_core/common/report.h **** #else
 143:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 144:tmk_core/common/report.h **** #endif
 145:tmk_core/common/report.h **** 
 146:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 147:tmk_core/common/report.h **** 
 148:tmk_core/common/report.h **** #ifdef __cplusplus
 149:tmk_core/common/report.h **** extern "C" {
 150:tmk_core/common/report.h **** #endif
 151:tmk_core/common/report.h **** 
 152:tmk_core/common/report.h **** /*
 153:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 154:tmk_core/common/report.h ****  *
 155:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 156:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 157:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 158:tmk_core/common/report.h ****  *
 159:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 160:tmk_core/common/report.h ****  *
 161:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 162:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 163:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 164:tmk_core/common/report.h ****  *
 165:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 166:tmk_core/common/report.h ****  *
 167:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 168:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 169:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 170:tmk_core/common/report.h ****  *
 171:tmk_core/common/report.h ****  */
 172:tmk_core/common/report.h **** typedef union {
 173:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 174:tmk_core/common/report.h ****     struct {
 175:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 176:tmk_core/common/report.h ****         uint8_t report_id;
 177:tmk_core/common/report.h **** #endif
 178:tmk_core/common/report.h ****         uint8_t mods;
 179:tmk_core/common/report.h ****         uint8_t reserved;
 180:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 181:tmk_core/common/report.h ****     };
 182:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 183:tmk_core/common/report.h ****     struct nkro_report {
 184:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 185:tmk_core/common/report.h ****         uint8_t report_id;
 186:tmk_core/common/report.h **** #    endif
 187:tmk_core/common/report.h ****         uint8_t mods;
 188:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 189:tmk_core/common/report.h ****     } nkro;
 190:tmk_core/common/report.h **** #endif
 191:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 192:tmk_core/common/report.h **** 
 193:tmk_core/common/report.h **** typedef struct {
 194:tmk_core/common/report.h ****     uint8_t  report_id;
 195:tmk_core/common/report.h ****     uint16_t usage;
 196:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 197:tmk_core/common/report.h **** 
 198:tmk_core/common/report.h **** typedef struct {
 199:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 200:tmk_core/common/report.h ****     uint8_t report_id;
 201:tmk_core/common/report.h **** #endif
 202:tmk_core/common/report.h ****     uint8_t buttons;
 203:tmk_core/common/report.h ****     int8_t  x;
 204:tmk_core/common/report.h ****     int8_t  y;
 205:tmk_core/common/report.h ****     int8_t  v;
 206:tmk_core/common/report.h ****     int8_t  h;
 207:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 208:tmk_core/common/report.h **** 
 209:tmk_core/common/report.h **** typedef struct {
 210:tmk_core/common/report.h **** #ifdef DIGITIZER_SHARED_EP
 211:tmk_core/common/report.h ****     uint8_t report_id;
 212:tmk_core/common/report.h **** #endif
 213:tmk_core/common/report.h ****     uint8_t  tip : 1;
 214:tmk_core/common/report.h ****     uint8_t  inrange : 1;
 215:tmk_core/common/report.h ****     uint8_t  pad2 : 6;
 216:tmk_core/common/report.h ****     uint16_t x;
 217:tmk_core/common/report.h ****     uint16_t y;
 218:tmk_core/common/report.h **** } __attribute__((packed)) report_digitizer_t;
 219:tmk_core/common/report.h **** 
 220:tmk_core/common/report.h **** typedef struct {
 221:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 222:tmk_core/common/report.h **** #    if JOYSTICK_AXES_RESOLUTION > 8
 223:tmk_core/common/report.h ****     int16_t axes[JOYSTICK_AXES_COUNT];
 224:tmk_core/common/report.h **** #    else
 225:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 226:tmk_core/common/report.h **** #    endif
 227:tmk_core/common/report.h **** #endif
 228:tmk_core/common/report.h **** 
 229:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 230:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 231:tmk_core/common/report.h **** #endif
 232:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 233:tmk_core/common/report.h **** 
 234:tmk_core/common/report.h **** /* keycode to system usage */
 235:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 236:tmk_core/common/report.h ****     switch (key) {
 237:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 238:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 239:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 240:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 241:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 242:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 243:tmk_core/common/report.h ****         default:
 244:tmk_core/common/report.h ****             return 0;
 245:tmk_core/common/report.h ****     }
 246:tmk_core/common/report.h **** }
 247:tmk_core/common/report.h **** 
 248:tmk_core/common/report.h **** /* keycode to consumer usage */
 249:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 574               		.loc 3 249 24 view .LVU126
 250:tmk_core/common/report.h ****     switch (key) {
 575               		.loc 3 250 5 view .LVU127
 576               		.loc 3 250 5 is_stmt 0 view .LVU128
 577               	.LBE71:
 823:quantum/action.c ****     }
 578               		.loc 1 823 9 view .LVU129
 579 006e EC2F      		mov r30,r28
 580 0070 F0E0      		ldi r31,0
 581 0072 EE0F      		lsl r30
 582 0074 FF1F      		rol r31
 583 0076 E050      		subi r30,lo8(-(CSWTCH.25))
 584 0078 F040      		sbci r31,hi8(-(CSWTCH.25))
 585 007a 8081      		ld r24,Z
 586 007c 9181      		ldd r25,Z+1
 587               	/* epilogue start */
 588               		.loc 1 832 1 view .LVU130
 589 007e CF91      		pop r28
 590               	.LVL57:
 823:quantum/action.c ****     }
 591               		.loc 1 823 9 view .LVU131
 592 0080 0C94 0000 		jmp host_consumer_send
 593               	.LVL58:
 594               	.L35:
 595               	/* epilogue start */
 596               		.loc 1 832 1 view .LVU132
 597 0084 CF91      		pop r28
 598 0086 0895      		ret
 599               		.cfi_endproc
 600               	.LFE29:
 602               		.section	.text.unregister_code,"ax",@progbits
 603               	.global	unregister_code
 605               	unregister_code:
 606               	.LVL59:
 607               	.LFB30:
 833:quantum/action.c **** 
 834:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 835:quantum/action.c ****  *
 836:quantum/action.c ****  * FIXME: Needs documentation.
 837:quantum/action.c ****  */
 838:quantum/action.c **** void unregister_code(uint8_t code) {
 608               		.loc 1 838 36 is_stmt 1 view -0
 609               		.cfi_startproc
 610               	/* prologue: function */
 611               	/* frame size = 0 */
 612               	/* stack size = 0 */
 613               	.L__stack_usage = 0
 839:quantum/action.c ****     if (code == KC_NO) {
 614               		.loc 1 839 5 view .LVU134
 615               		.loc 1 839 8 is_stmt 0 view .LVU135
 616 0000 8823      		tst r24
 617 0002 01F0      		breq .L48
 840:quantum/action.c ****         return;
 841:quantum/action.c ****     }
 842:quantum/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 843:quantum/action.c ****     else if (KC_LOCKING_CAPS == code) {
 844:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 845:quantum/action.c ****         // Resync: ignore if caps lock already is off
 846:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 847:quantum/action.c **** #    endif
 848:quantum/action.c ****         add_key(KC_CAPSLOCK);
 849:quantum/action.c ****         send_keyboard_report();
 850:quantum/action.c ****         del_key(KC_CAPSLOCK);
 851:quantum/action.c ****         send_keyboard_report();
 852:quantum/action.c ****     }
 853:quantum/action.c **** 
 854:quantum/action.c ****     else if (KC_LOCKING_NUM == code) {
 855:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 856:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 857:quantum/action.c **** #    endif
 858:quantum/action.c ****         add_key(KC_NUMLOCK);
 859:quantum/action.c ****         send_keyboard_report();
 860:quantum/action.c ****         del_key(KC_NUMLOCK);
 861:quantum/action.c ****         send_keyboard_report();
 862:quantum/action.c ****     }
 863:quantum/action.c **** 
 864:quantum/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 865:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 866:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 867:quantum/action.c **** #    endif
 868:quantum/action.c ****         add_key(KC_SCROLLLOCK);
 869:quantum/action.c ****         send_keyboard_report();
 870:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 871:quantum/action.c ****         send_keyboard_report();
 872:quantum/action.c ****     }
 873:quantum/action.c **** #endif
 874:quantum/action.c **** 
 875:quantum/action.c ****     else if IS_KEY (code) {
 618               		.loc 1 875 10 is_stmt 1 view .LVU136
 619               		.loc 1 875 13 is_stmt 0 view .LVU137
 620 0004 9CEF      		ldi r25,lo8(-4)
 621 0006 980F      		add r25,r24
 622 0008 913A      		cpi r25,lo8(-95)
 623 000a 00F4      		brsh .L50
 876:quantum/action.c ****         del_key(code);
 624               		.loc 1 876 9 is_stmt 1 view .LVU138
 625 000c 0E94 0000 		call del_key
 626               	.LVL60:
 877:quantum/action.c ****         send_keyboard_report();
 627               		.loc 1 877 9 view .LVU139
 628               	.L56:
 878:quantum/action.c ****     } else if IS_MOD (code) {
 879:quantum/action.c ****         del_mods(MOD_BIT(code));
 880:quantum/action.c ****         send_keyboard_report();
 629               		.loc 1 880 9 view .LVU140
 630 0010 0C94 0000 		jmp send_keyboard_report
 631               	.LVL61:
 632               	.L50:
 878:quantum/action.c ****     } else if IS_MOD (code) {
 633               		.loc 1 878 12 view .LVU141
 878:quantum/action.c ****     } else if IS_MOD (code) {
 634               		.loc 1 878 15 is_stmt 0 view .LVU142
 635 0014 90E2      		ldi r25,lo8(32)
 636 0016 980F      		add r25,r24
 637 0018 9830      		cpi r25,lo8(8)
 638 001a 00F4      		brsh .L51
 879:quantum/action.c ****         send_keyboard_report();
 639               		.loc 1 879 9 is_stmt 1 view .LVU143
 879:quantum/action.c ****         send_keyboard_report();
 640               		.loc 1 879 18 is_stmt 0 view .LVU144
 641 001c 8770      		andi r24,lo8(7)
 642               	.LVL62:
 879:quantum/action.c ****         send_keyboard_report();
 643               		.loc 1 879 9 view .LVU145
 644 001e 91E0      		ldi r25,lo8(1)
 645 0020 00C0      		rjmp 2f
 646               		1:
 647 0022 990F      		lsl r25
 648               		2:
 649 0024 8A95      		dec r24
 650 0026 02F4      		brpl 1b
 651 0028 892F      		mov r24,r25
 652 002a 0E94 0000 		call del_mods
 653               	.LVL63:
 654 002e 00C0      		rjmp .L56
 655               	.LVL64:
 656               	.L51:
 881:quantum/action.c ****     } else if IS_SYSTEM (code) {
 657               		.loc 1 881 12 is_stmt 1 view .LVU146
 658               		.loc 1 881 15 is_stmt 0 view .LVU147
 659 0030 9BE5      		ldi r25,lo8(91)
 660 0032 980F      		add r25,r24
 661 0034 9330      		cpi r25,lo8(3)
 662 0036 00F4      		brsh .L52
 882:quantum/action.c ****         host_system_send(0);
 663               		.loc 1 882 9 is_stmt 1 view .LVU148
 664 0038 90E0      		ldi r25,0
 665 003a 80E0      		ldi r24,0
 666               	.LVL65:
 667               		.loc 1 882 9 is_stmt 0 view .LVU149
 668 003c 0C94 0000 		jmp host_system_send
 669               	.LVL66:
 670               	.L52:
 883:quantum/action.c ****     } else if IS_CONSUMER (code) {
 671               		.loc 1 883 12 is_stmt 1 view .LVU150
 672               		.loc 1 883 15 is_stmt 0 view .LVU151
 673 0040 885A      		subi r24,lo8(-(88))
 674               	.LVL67:
 675               		.loc 1 883 15 view .LVU152
 676 0042 8731      		cpi r24,lo8(23)
 677 0044 00F4      		brsh .L48
 884:quantum/action.c ****         host_consumer_send(0);
 678               		.loc 1 884 9 is_stmt 1 view .LVU153
 679 0046 90E0      		ldi r25,0
 680 0048 80E0      		ldi r24,0
 681               	.LVL68:
 682               		.loc 1 884 9 is_stmt 0 view .LVU154
 683 004a 0C94 0000 		jmp host_consumer_send
 684               	.LVL69:
 685               	.L48:
 686               	/* epilogue start */
 885:quantum/action.c ****     }
 886:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 887:quantum/action.c ****     else if IS_MOUSEKEY (code) {
 888:quantum/action.c ****         mousekey_off(code);
 889:quantum/action.c ****         mousekey_send();
 890:quantum/action.c ****     }
 891:quantum/action.c **** #endif
 892:quantum/action.c **** }
 687               		.loc 1 892 1 view .LVU155
 688 004e 0895      		ret
 689               		.cfi_endproc
 690               	.LFE30:
 692               		.section	.text.tap_code_delay,"ax",@progbits
 693               	.global	tap_code_delay
 695               	tap_code_delay:
 696               	.LVL70:
 697               	.LFB31:
 893:quantum/action.c **** 
 894:quantum/action.c **** /** \brief Tap a keycode with a delay.
 895:quantum/action.c ****  *
 896:quantum/action.c ****  * \param code The basic keycode to tap.
 897:quantum/action.c ****  * \param delay The amount of time in milliseconds to leave the keycode registered, before unregist
 898:quantum/action.c ****  */
 899:quantum/action.c **** void tap_code_delay(uint8_t code, uint16_t delay) {
 698               		.loc 1 899 51 is_stmt 1 view -0
 699               		.cfi_startproc
 700               		.loc 1 899 51 is_stmt 0 view .LVU157
 701 0000 1F93      		push r17
 702               	.LCFI11:
 703               		.cfi_def_cfa_offset 3
 704               		.cfi_offset 17, -2
 705 0002 CF93      		push r28
 706               	.LCFI12:
 707               		.cfi_def_cfa_offset 4
 708               		.cfi_offset 28, -3
 709 0004 DF93      		push r29
 710               	.LCFI13:
 711               		.cfi_def_cfa_offset 5
 712               		.cfi_offset 29, -4
 713               	/* prologue: function */
 714               	/* frame size = 0 */
 715               	/* stack size = 3 */
 716               	.L__stack_usage = 3
 717 0006 182F      		mov r17,r24
 718 0008 EB01      		movw r28,r22
 900:quantum/action.c ****     register_code(code);
 719               		.loc 1 900 5 is_stmt 1 view .LVU158
 720 000a 0E94 0000 		call register_code
 721               	.LVL71:
 901:quantum/action.c ****     for (uint16_t i = delay; i > 0; i--) {
 722               		.loc 1 901 5 view .LVU159
 723               	.LBB72:
 724               		.loc 1 901 10 view .LVU160
 725               	.L58:
 726               		.loc 1 901 32 discriminator 2 view .LVU161
 727 000e 2097      		sbiw r28,0
 728 0010 01F4      		brne .L59
 729               		.loc 1 901 32 is_stmt 0 discriminator 2 view .LVU162
 730               	.LBE72:
 902:quantum/action.c ****         wait_ms(1);
 903:quantum/action.c ****     }
 904:quantum/action.c ****     unregister_code(code);
 731               		.loc 1 904 5 is_stmt 1 view .LVU163
 732 0012 812F      		mov r24,r17
 733               	/* epilogue start */
 905:quantum/action.c **** }
 734               		.loc 1 905 1 is_stmt 0 view .LVU164
 735 0014 DF91      		pop r29
 736 0016 CF91      		pop r28
 737               	.LVL72:
 738               		.loc 1 905 1 view .LVU165
 739 0018 1F91      		pop r17
 740               	.LVL73:
 904:quantum/action.c **** }
 741               		.loc 1 904 5 view .LVU166
 742 001a 0C94 0000 		jmp unregister_code
 743               	.LVL74:
 744               	.L59:
 745               	.LBB75:
 902:quantum/action.c ****         wait_ms(1);
 746               		.loc 1 902 9 is_stmt 1 view .LVU167
 902:quantum/action.c ****         wait_ms(1);
 747               		.loc 1 902 9 view .LVU168
 902:quantum/action.c ****         wait_ms(1);
 748               		.loc 1 902 9 view .LVU169
 749               	.LBB73:
 750               	.LBI73:
 751               		.file 4 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2551 2020-10-10 20:33:35Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 752               		.loc 4 166 1 view .LVU170
 753               	.LBB74:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 754               		.loc 4 168 2 view .LVU171
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 755               		.loc 4 172 2 view .LVU172
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 756               		.loc 4 173 2 view .LVU173
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 757               		.loc 4 174 2 view .LVU174
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 758               		.loc 4 184 3 view .LVU175
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 759               		.loc 4 187 2 view .LVU176
 760 001e 8FE9      		ldi r24,lo8(3999)
 761 0020 9FE0      		ldi r25,hi8(3999)
 762 0022 0197      	1:	sbiw r24,1
 763 0024 01F4      		brne 1b
 764 0026 00C0      		rjmp .
 765 0028 0000      		nop
 766               	.LVL75:
 767               		.loc 4 187 2 is_stmt 0 view .LVU177
 768               	.LBE74:
 769               	.LBE73:
 902:quantum/action.c ****     }
 770               		.loc 1 902 9 is_stmt 1 view .LVU178
 901:quantum/action.c ****         wait_ms(1);
 771               		.loc 1 901 38 view .LVU179
 772 002a 2197      		sbiw r28,1
 773               	.LVL76:
 901:quantum/action.c ****         wait_ms(1);
 774               		.loc 1 901 38 is_stmt 0 view .LVU180
 775 002c 00C0      		rjmp .L58
 776               	.LBE75:
 777               		.cfi_endproc
 778               	.LFE31:
 780               		.section	.text.tap_code,"ax",@progbits
 781               	.global	tap_code
 783               	tap_code:
 784               	.LVL77:
 785               	.LFB32:
 906:quantum/action.c **** 
 907:quantum/action.c **** /** \brief Tap a keycode with the default delay.
 908:quantum/action.c ****  *
 909:quantum/action.c ****  * \param code The basic keycode to tap. If `code` is `KC_CAPS`, the delay will be `TAP_HOLD_CAPS_D
 910:quantum/action.c ****  */
 911:quantum/action.c **** void tap_code(uint8_t code) { tap_code_delay(code, code == KC_CAPS ? TAP_HOLD_CAPS_DELAY : TAP_CODE
 786               		.loc 1 911 29 is_stmt 1 view -0
 787               		.cfi_startproc
 788               	/* prologue: function */
 789               	/* frame size = 0 */
 790               	/* stack size = 0 */
 791               	.L__stack_usage = 0
 792               		.loc 1 911 31 view .LVU182
 793 0000 6AE0      		ldi r22,lo8(10)
 794 0002 70E0      		ldi r23,0
 795 0004 8933      		cpi r24,lo8(57)
 796 0006 01F4      		brne .L61
 797 0008 60E5      		ldi r22,lo8(80)
 798 000a 70E0      		ldi r23,0
 799               	.L61:
 800               		.loc 1 911 31 is_stmt 0 discriminator 4 view .LVU183
 801 000c 0C94 0000 		jmp tap_code_delay
 802               	.LVL78:
 803               		.loc 1 911 31 discriminator 4 view .LVU184
 804               		.cfi_endproc
 805               	.LFE32:
 807               		.section	.text.register_mods,"ax",@progbits
 808               	.global	register_mods
 810               	register_mods:
 811               	.LVL79:
 812               	.LFB33:
 912:quantum/action.c **** 
 913:quantum/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 914:quantum/action.c ****  *
 915:quantum/action.c ****  * \param mods A bitfield of modifiers to register.
 916:quantum/action.c ****  */
 917:quantum/action.c **** void register_mods(uint8_t mods) {
 813               		.loc 1 917 34 is_stmt 1 view -0
 814               		.cfi_startproc
 815               	/* prologue: function */
 816               	/* frame size = 0 */
 817               	/* stack size = 0 */
 818               	.L__stack_usage = 0
 918:quantum/action.c ****     if (mods) {
 819               		.loc 1 918 5 view .LVU186
 820               		.loc 1 918 8 is_stmt 0 view .LVU187
 821 0000 8823      		tst r24
 822 0002 01F0      		breq .L63
 919:quantum/action.c ****         add_mods(mods);
 823               		.loc 1 919 9 is_stmt 1 view .LVU188
 824 0004 0E94 0000 		call add_mods
 825               	.LVL80:
 920:quantum/action.c ****         send_keyboard_report();
 826               		.loc 1 920 9 view .LVU189
 827 0008 0C94 0000 		jmp send_keyboard_report
 828               	.LVL81:
 829               	.L63:
 830               	/* epilogue start */
 921:quantum/action.c ****     }
 922:quantum/action.c **** }
 831               		.loc 1 922 1 is_stmt 0 view .LVU190
 832 000c 0895      		ret
 833               		.cfi_endproc
 834               	.LFE33:
 836               		.section	.text.unregister_mods,"ax",@progbits
 837               	.global	unregister_mods
 839               	unregister_mods:
 840               	.LVL82:
 841               	.LFB34:
 923:quantum/action.c **** 
 924:quantum/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 925:quantum/action.c ****  *
 926:quantum/action.c ****  * \param mods A bitfield of modifiers to unregister.
 927:quantum/action.c ****  */
 928:quantum/action.c **** void unregister_mods(uint8_t mods) {
 842               		.loc 1 928 36 is_stmt 1 view -0
 843               		.cfi_startproc
 844               	/* prologue: function */
 845               	/* frame size = 0 */
 846               	/* stack size = 0 */
 847               	.L__stack_usage = 0
 929:quantum/action.c ****     if (mods) {
 848               		.loc 1 929 5 view .LVU192
 849               		.loc 1 929 8 is_stmt 0 view .LVU193
 850 0000 8823      		tst r24
 851 0002 01F0      		breq .L65
 930:quantum/action.c ****         del_mods(mods);
 852               		.loc 1 930 9 is_stmt 1 view .LVU194
 853 0004 0E94 0000 		call del_mods
 854               	.LVL83:
 931:quantum/action.c ****         send_keyboard_report();
 855               		.loc 1 931 9 view .LVU195
 856 0008 0C94 0000 		jmp send_keyboard_report
 857               	.LVL84:
 858               	.L65:
 859               	/* epilogue start */
 932:quantum/action.c ****     }
 933:quantum/action.c **** }
 860               		.loc 1 933 1 is_stmt 0 view .LVU196
 861 000c 0895      		ret
 862               		.cfi_endproc
 863               	.LFE34:
 865               		.section	.text.process_action,"ax",@progbits
 866               	.global	process_action
 868               	process_action:
 869               	.LVL85:
 870               	.LFB28:
 249:quantum/action.c ****     keyevent_t event = record->event;
 871               		.loc 1 249 59 is_stmt 1 view -0
 872               		.cfi_startproc
 249:quantum/action.c ****     keyevent_t event = record->event;
 873               		.loc 1 249 59 is_stmt 0 view .LVU198
 874 0000 6F92      		push r6
 875               	.LCFI14:
 876               		.cfi_def_cfa_offset 3
 877               		.cfi_offset 6, -2
 878 0002 7F92      		push r7
 879               	.LCFI15:
 880               		.cfi_def_cfa_offset 4
 881               		.cfi_offset 7, -3
 882 0004 8F92      		push r8
 883               	.LCFI16:
 884               		.cfi_def_cfa_offset 5
 885               		.cfi_offset 8, -4
 886 0006 9F92      		push r9
 887               	.LCFI17:
 888               		.cfi_def_cfa_offset 6
 889               		.cfi_offset 9, -5
 890 0008 AF92      		push r10
 891               	.LCFI18:
 892               		.cfi_def_cfa_offset 7
 893               		.cfi_offset 10, -6
 894 000a BF92      		push r11
 895               	.LCFI19:
 896               		.cfi_def_cfa_offset 8
 897               		.cfi_offset 11, -7
 898 000c CF92      		push r12
 899               	.LCFI20:
 900               		.cfi_def_cfa_offset 9
 901               		.cfi_offset 12, -8
 902 000e DF92      		push r13
 903               	.LCFI21:
 904               		.cfi_def_cfa_offset 10
 905               		.cfi_offset 13, -9
 906 0010 EF92      		push r14
 907               	.LCFI22:
 908               		.cfi_def_cfa_offset 11
 909               		.cfi_offset 14, -10
 910 0012 FF92      		push r15
 911               	.LCFI23:
 912               		.cfi_def_cfa_offset 12
 913               		.cfi_offset 15, -11
 914 0014 0F93      		push r16
 915               	.LCFI24:
 916               		.cfi_def_cfa_offset 13
 917               		.cfi_offset 16, -12
 918 0016 1F93      		push r17
 919               	.LCFI25:
 920               		.cfi_def_cfa_offset 14
 921               		.cfi_offset 17, -13
 922 0018 CF93      		push r28
 923               	.LCFI26:
 924               		.cfi_def_cfa_offset 15
 925               		.cfi_offset 28, -14
 926 001a DF93      		push r29
 927               	.LCFI27:
 928               		.cfi_def_cfa_offset 16
 929               		.cfi_offset 29, -15
 930 001c 00D0      		rcall .
 931 001e 00D0      		rcall .
 932 0020 00D0      		rcall .
 933               	.LCFI28:
 934               		.cfi_def_cfa_offset 22
 935 0022 CDB7      		in r28,__SP_L__
 936 0024 DEB7      		in r29,__SP_H__
 937               	.LCFI29:
 938               		.cfi_def_cfa_register 28
 939               	/* prologue: function */
 940               	/* frame size = 6 */
 941               	/* stack size = 20 */
 942               	.L__stack_usage = 20
 943 0026 6C01      		movw r12,r24
 944 0028 6D83      		std Y+5,r22
 945 002a 7E83      		std Y+6,r23
 250:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 946               		.loc 1 250 5 is_stmt 1 view .LVU199
 250:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 947               		.loc 1 250 16 is_stmt 0 view .LVU200
 948 002c FC01      		movw r30,r24
 949 002e 1281      		ldd r17,Z+2
 950               	.LVL86:
 252:quantum/action.c **** #endif
 951               		.loc 1 252 5 is_stmt 1 view .LVU201
 252:quantum/action.c **** #endif
 952               		.loc 1 252 36 is_stmt 0 view .LVU202
 953 0030 0581      		ldd r16,Z+5
 954 0032 0295      		swap r16
 955 0034 0F70      		andi r16,lo8(15)
 956               	.LVL87:
 256:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 957               		.loc 1 256 5 is_stmt 1 view .LVU203
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 958               		.loc 1 258 5 view .LVU204
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 959               		.loc 1 258 9 is_stmt 0 view .LVU205
 960 0036 0E94 0000 		call is_oneshot_layer_active
 961               	.LVL88:
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 962               		.loc 1 258 9 view .LVU206
 963 003a E82E      		mov r14,r24
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 964               		.loc 1 258 8 view .LVU207
 965 003c 8823      		tst r24
 966 003e 01F0      		breq .L68
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 967               		.loc 1 258 35 discriminator 1 view .LVU208
 968 0040 1123      		tst r17
 969 0042 01F0      		breq .L162
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 970               		.loc 1 258 71 discriminator 2 view .LVU209
 971 0044 8E81      		ldd r24,Y+6
 972 0046 807F      		andi r24,lo8(-16)
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 973               		.loc 1 258 52 discriminator 2 view .LVU210
 974 0048 8034      		cpi r24,lo8(64)
 975 004a 01F0      		breq .L69
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 976               		.loc 1 258 87 discriminator 3 view .LVU211
 977 004c 9D81      		ldd r25,Y+5
 978 004e 905E      		subi r25,lo8(-(32))
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 979               		.loc 1 258 84 discriminator 3 view .LVU212
 980 0050 9830      		cpi r25,lo8(8)
 981 0052 00F0      		brlo .L162
 260:quantum/action.c **** #    endif
 982               		.loc 1 260 9 view .LVU213
 983 0054 8036      		cpi r24,lo8(96)
 984 0056 01F4      		brne .L69
 260:quantum/action.c **** #    endif
 985               		.loc 1 260 12 discriminator 1 view .LVU214
 986 0058 FD81      		ldd r31,Y+5
 987 005a F63F      		cpi r31,lo8(-10)
 988 005c 01F0      		breq .L162
 989               	.L69:
 263:quantum/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 990               		.loc 1 263 9 is_stmt 1 view .LVU215
 991 005e 82E0      		ldi r24,lo8(2)
 992 0060 0E94 0000 		call clear_oneshot_layer_state
 993               	.LVL89:
 264:quantum/action.c ****     }
 994               		.loc 1 264 9 view .LVU216
 264:quantum/action.c ****     }
 995               		.loc 1 264 31 is_stmt 0 view .LVU217
 996 0064 0E94 0000 		call is_oneshot_layer_active
 997               	.LVL90:
 264:quantum/action.c ****     }
 998               		.loc 1 264 9 view .LVU218
 999 0068 91E0      		ldi r25,lo8(1)
 1000 006a E82E      		mov r14,r24
 1001 006c E926      		eor r14,r25
 1002               	.LVL91:
 1003               	.L68:
 268:quantum/action.c ****         /* Key and Mods */
 1004               		.loc 1 268 5 is_stmt 1 view .LVU219
 268:quantum/action.c ****         /* Key and Mods */
 1005               		.loc 1 268 24 is_stmt 0 view .LVU220
 1006 006e 8E81      		ldd r24,Y+6
 1007 0070 8295      		swap r24
 1008 0072 8F70      		andi r24,lo8(15)
 1009 0074 A82E      		mov r10,r24
 1010 0076 B12C      		mov r11,__zero_reg__
 268:quantum/action.c ****         /* Key and Mods */
 1011               		.loc 1 268 5 view .LVU221
 1012 0078 8C30      		cpi r24,lo8(12)
 1013 007a 00F4      		brsh .L70
 1014 007c F501      		movw r30,r10
 1015 007e E050      		subi r30,lo8(-(gs(.L72)))
 1016 0080 F040      		sbci r31,hi8(-(gs(.L72)))
 1017 0082 0C94 0000 		jmp __tablejump2__
 1018               		.section	.jumptables.gcc.process_action,"a",@progbits
 1019               		.p2align	1
 1020               	.L72:
 1021 0000 0000      		.word gs(.L78)
 1022 0002 0000      		.word gs(.L78)
 1023 0004 0000      		.word gs(.L77)
 1024 0006 0000      		.word gs(.L77)
 1025 0008 0000      		.word gs(.L76)
 1026 000a 0000      		.word gs(.L70)
 1027 000c 0000      		.word gs(.L75)
 1028 000e 0000      		.word gs(.L70)
 1029 0010 0000      		.word gs(.L74)
 1030 0012 0000      		.word gs(.L73)
 1031 0014 0000      		.word gs(.L71)
 1032 0016 0000      		.word gs(.L71)
 1033               		.section	.text.process_action
 1034               	.LVL92:
 1035               	.L162:
 256:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 1036               		.loc 1 256 10 view .LVU222
 1037 0086 E12C      		mov r14,__zero_reg__
 1038 0088 00C0      		rjmp .L68
 1039               	.LVL93:
 1040               	.L78:
 1041               	.LBB76:
 272:quantum/action.c ****             if (event.pressed) {
 1042               		.loc 1 272 13 is_stmt 1 view .LVU223
 272:quantum/action.c ****             if (event.pressed) {
 1043               		.loc 1 272 70 is_stmt 0 view .LVU224
 1044 008a 0E81      		ldd r16,Y+6
 1045               	.LVL94:
 272:quantum/action.c ****             if (event.pressed) {
 1046               		.loc 1 272 70 view .LVU225
 1047 008c 0F70      		andi r16,lo8(15)
 272:quantum/action.c ****             if (event.pressed) {
 1048               		.loc 1 272 44 view .LVU226
 1049 008e 8E81      		ldd r24,Y+6
 1050 0090 807F      		andi r24,lo8(-16)
 272:quantum/action.c ****             if (event.pressed) {
 1051               		.loc 1 272 21 view .LVU227
 1052 0092 01F0      		breq .L79
 272:quantum/action.c ****             if (event.pressed) {
 1053               		.loc 1 272 21 discriminator 2 view .LVU228
 1054 0094 0295      		swap r16
 1055 0096 007F      		andi r16,lo8(-16)
 1056               	.L79:
 1057               	.LVL95:
 273:quantum/action.c ****                 if (mods) {
 1058               		.loc 1 273 13 is_stmt 1 discriminator 4 view .LVU229
 273:quantum/action.c ****                 if (mods) {
 1059               		.loc 1 273 16 is_stmt 0 discriminator 4 view .LVU230
 1060 0098 1123      		tst r17
 1061 009a 01F0      		breq .L80
 274:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1062               		.loc 1 274 17 is_stmt 1 view .LVU231
 274:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1063               		.loc 1 274 20 is_stmt 0 view .LVU232
 1064 009c 0023      		tst r16
 1065 009e 01F0      		breq .L212
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1066               		.loc 1 275 21 is_stmt 1 view .LVU233
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1067               		.loc 1 275 25 is_stmt 0 view .LVU234
 1068 00a0 8D81      		ldd r24,Y+5
 1069 00a2 805E      		subi r24,lo8(-(32))
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1070               		.loc 1 275 24 view .LVU235
 1071 00a4 8830      		cpi r24,lo8(8)
 1072 00a6 00F0      		brlo .L82
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1073               		.loc 1 275 49 discriminator 1 view .LVU236
 1074 00a8 6D80      		ldd r6,Y+5
 1075 00aa 6110      		cpse r6,__zero_reg__
 1076 00ac 00C0      		rjmp .L83
 1077               	.L82:
 279:quantum/action.c ****                     } else {
 1078               		.loc 1 279 25 is_stmt 1 view .LVU237
 1079 00ae 802F      		mov r24,r16
 1080 00b0 0E94 0000 		call add_mods
 1081               	.LVL96:
 1082               	.L84:
 283:quantum/action.c ****                 }
 1083               		.loc 1 283 21 view .LVU238
 1084 00b4 0E94 0000 		call send_keyboard_report
 1085               	.LVL97:
 285:quantum/action.c ****             } else {
 1086               		.loc 1 285 17 view .LVU239
 1087               	.L212:
 285:quantum/action.c ****             } else {
 1088               		.loc 1 285 17 is_stmt 0 view .LVU240
 1089               	.LBE76:
 653:quantum/action.c ****                         } else {
 1090               		.loc 1 653 29 is_stmt 1 view .LVU241
 1091 00b8 8D81      		ldd r24,Y+5
 1092 00ba 0E94 0000 		call register_code
 1093               	.LVL98:
 1094 00be 00C0      		rjmp .L70
 1095               	.LVL99:
 1096               	.L83:
 1097               	.LBB77:
 281:quantum/action.c ****                     }
 1098               		.loc 1 281 25 view .LVU242
 1099 00c0 802F      		mov r24,r16
 1100 00c2 0E94 0000 		call add_weak_mods
 1101               	.LVL100:
 1102 00c6 00C0      		rjmp .L84
 1103               	.L80:
 287:quantum/action.c ****                 if (mods) {
 1104               		.loc 1 287 17 view .LVU243
 1105 00c8 8D81      		ldd r24,Y+5
 1106 00ca 0E94 0000 		call unregister_code
 1107               	.LVL101:
 288:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1108               		.loc 1 288 17 view .LVU244
 288:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1109               		.loc 1 288 20 is_stmt 0 view .LVU245
 1110 00ce 0023      		tst r16
 1111 00d0 01F0      		breq .L70
 289:quantum/action.c ****                         del_mods(mods);
 1112               		.loc 1 289 21 is_stmt 1 view .LVU246
 289:quantum/action.c ****                         del_mods(mods);
 1113               		.loc 1 289 25 is_stmt 0 view .LVU247
 1114 00d2 8D81      		ldd r24,Y+5
 1115 00d4 805E      		subi r24,lo8(-(32))
 289:quantum/action.c ****                         del_mods(mods);
 1116               		.loc 1 289 24 view .LVU248
 1117 00d6 8830      		cpi r24,lo8(8)
 1118 00d8 00F0      		brlo .L86
 289:quantum/action.c ****                         del_mods(mods);
 1119               		.loc 1 289 49 discriminator 1 view .LVU249
 1120 00da 7D80      		ldd r7,Y+5
 1121 00dc 7110      		cpse r7,__zero_reg__
 1122 00de 00C0      		rjmp .L87
 1123               	.L86:
 290:quantum/action.c ****                     } else {
 1124               		.loc 1 290 25 is_stmt 1 view .LVU250
 1125 00e0 802F      		mov r24,r16
 1126 00e2 0E94 0000 		call del_mods
 1127               	.LVL102:
 1128               	.L88:
 294:quantum/action.c ****                 }
 1129               		.loc 1 294 21 view .LVU251
 1130 00e6 0E94 0000 		call send_keyboard_report
 1131               	.LVL103:
 1132               	.L70:
 294:quantum/action.c ****                 }
 1133               		.loc 1 294 21 is_stmt 0 view .LVU252
 1134               	.LBE77:
 679:quantum/action.c ****         case ACT_LAYER:
 1135               		.loc 1 679 5 is_stmt 1 view .LVU253
 1136 00ea F8E0      		ldi r31,8
 1137 00ec AF1A      		sub r10,r31
 1138 00ee B108      		sbc r11,__zero_reg__
 1139 00f0 24E0      		ldi r18,4
 1140 00f2 A216      		cp r10,r18
 1141 00f4 B104      		cpc r11,__zero_reg__
 1142 00f6 00F4      		brsh .L154
 686:quantum/action.c ****             break;
 1143               		.loc 1 686 13 view .LVU254
 1144 00f8 0E94 0000 		call host_keyboard_leds
 1145               	.LVL104:
 1146 00fc 0E94 0000 		call led_set
 1147               	.LVL105:
 687:quantum/action.c ****         default:
 1148               		.loc 1 687 13 view .LVU255
 1149               	.L154:
 722:quantum/action.c ****         use_oneshot_swaphands();
 1150               		.loc 1 722 5 view .LVU256
 722:quantum/action.c ****         use_oneshot_swaphands();
 1151               		.loc 1 722 8 is_stmt 0 view .LVU257
 1152 0100 1123      		tst r17
 1153 0102 01F0      		breq .L155
 722:quantum/action.c ****         use_oneshot_swaphands();
 1154               		.loc 1 722 43 discriminator 1 view .LVU258
 1155 0104 8E81      		ldd r24,Y+6
 1156 0106 807F      		andi r24,lo8(-16)
 722:quantum/action.c ****         use_oneshot_swaphands();
 1157               		.loc 1 722 23 discriminator 1 view .LVU259
 1158 0108 8036      		cpi r24,lo8(96)
 1159 010a 01F4      		brne .L156
 722:quantum/action.c ****         use_oneshot_swaphands();
 1160               		.loc 1 722 26 discriminator 2 view .LVU260
 1161 010c 9D81      		ldd r25,Y+5
 1162 010e 963F      		cpi r25,lo8(-10)
 1163 0110 01F0      		breq .L155
 1164               	.L156:
 723:quantum/action.c ****     }
 1165               		.loc 1 723 9 is_stmt 1 view .LVU261
 1166 0112 0E94 0000 		call use_oneshot_swaphands
 1167               	.LVL106:
 1168               	.L155:
 732:quantum/action.c ****         record->event.pressed = false;
 1169               		.loc 1 732 5 view .LVU262
 732:quantum/action.c ****         record->event.pressed = false;
 1170               		.loc 1 732 8 is_stmt 0 view .LVU263
 1171 0116 EE20      		tst r14
 1172 0118 01F4      		brne .+2
 1173 011a 00C0      		rjmp .L67
 732:quantum/action.c ****         record->event.pressed = false;
 1174               		.loc 1 732 33 discriminator 1 view .LVU264
 1175 011c 0E94 0000 		call get_oneshot_layer_state
 1176               	.LVL107:
 732:quantum/action.c ****         record->event.pressed = false;
 1177               		.loc 1 732 28 discriminator 1 view .LVU265
 1178 0120 80FD      		sbrc r24,0
 1179 0122 00C0      		rjmp .L67
 733:quantum/action.c ****         layer_on(get_oneshot_layer());
 1180               		.loc 1 733 9 is_stmt 1 view .LVU266
 733:quantum/action.c ****         layer_on(get_oneshot_layer());
 1181               		.loc 1 733 31 is_stmt 0 view .LVU267
 1182 0124 F601      		movw r30,r12
 1183 0126 1282      		std Z+2,__zero_reg__
 734:quantum/action.c ****         process_record(record);
 1184               		.loc 1 734 9 is_stmt 1 view .LVU268
 1185 0128 0E94 0000 		call get_oneshot_layer
 1186               	.LVL108:
 1187 012c 0E94 0000 		call layer_on
 1188               	.LVL109:
 735:quantum/action.c ****         layer_off(get_oneshot_layer());
 1189               		.loc 1 735 9 view .LVU269
 1190 0130 C601      		movw r24,r12
 1191 0132 0E94 0000 		call process_record
 1192               	.LVL110:
 736:quantum/action.c ****     }
 1193               		.loc 1 736 9 view .LVU270
 1194 0136 0E94 0000 		call get_oneshot_layer
 1195               	.LVL111:
 1196               	/* epilogue start */
 739:quantum/action.c **** 
 1197               		.loc 1 739 1 is_stmt 0 view .LVU271
 1198 013a 2696      		adiw r28,6
 1199 013c 0FB6      		in __tmp_reg__,__SREG__
 1200 013e F894      		cli
 1201 0140 DEBF      		out __SP_H__,r29
 1202 0142 0FBE      		out __SREG__,__tmp_reg__
 1203 0144 CDBF      		out __SP_L__,r28
 1204 0146 DF91      		pop r29
 1205 0148 CF91      		pop r28
 1206 014a 1F91      		pop r17
 1207               	.LVL112:
 739:quantum/action.c **** 
 1208               		.loc 1 739 1 view .LVU272
 1209 014c 0F91      		pop r16
 1210 014e FF90      		pop r15
 1211 0150 EF90      		pop r14
 1212               	.LVL113:
 739:quantum/action.c **** 
 1213               		.loc 1 739 1 view .LVU273
 1214 0152 DF90      		pop r13
 1215 0154 CF90      		pop r12
 1216               	.LVL114:
 739:quantum/action.c **** 
 1217               		.loc 1 739 1 view .LVU274
 1218 0156 BF90      		pop r11
 1219 0158 AF90      		pop r10
 1220 015a 9F90      		pop r9
 1221 015c 8F90      		pop r8
 1222 015e 7F90      		pop r7
 1223 0160 6F90      		pop r6
 736:quantum/action.c ****     }
 1224               		.loc 1 736 9 view .LVU275
 1225 0162 0C94 0000 		jmp layer_off
 1226               	.LVL115:
 1227               	.L87:
 1228               	.LBB78:
 292:quantum/action.c ****                     }
 1229               		.loc 1 292 25 is_stmt 1 view .LVU276
 1230 0166 802F      		mov r24,r16
 1231 0168 0E94 0000 		call del_weak_mods
 1232               	.LVL116:
 1233 016c 00C0      		rjmp .L88
 1234               	.LVL117:
 1235               	.L77:
 292:quantum/action.c ****                     }
 1236               		.loc 1 292 25 is_stmt 0 view .LVU277
 1237               	.LBE78:
 1238               	.LBB79:
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1239               		.loc 1 301 13 is_stmt 1 view .LVU278
 1240               	.LBE79:
 1241               	.LBB84:
 272:quantum/action.c ****             if (event.pressed) {
 1242               		.loc 1 272 70 is_stmt 0 view .LVU279
 1243 016e 2E81      		ldd r18,Y+6
 1244 0170 2F70      		andi r18,lo8(15)
 1245 0172 F22E      		mov r15,r18
 1246               	.LBE84:
 1247               	.LBB85:
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1248               		.loc 1 301 44 view .LVU280
 1249 0174 8E81      		ldd r24,Y+6
 1250 0176 807F      		andi r24,lo8(-16)
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1251               		.loc 1 301 21 view .LVU281
 1252 0178 8032      		cpi r24,lo8(32)
 1253 017a 01F0      		breq .L89
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1254               		.loc 1 301 21 discriminator 2 view .LVU282
 1255 017c F294      		swap r15
 1256 017e 80EF      		ldi r24,lo8(-16)
 1257 0180 F822      		and r15,r24
 1258               	.L89:
 1259               	.LVL118:
 302:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 1260               		.loc 1 302 13 is_stmt 1 discriminator 4 view .LVU283
 1261 0182 6D80      		ldd r6,Y+5
 1262 0184 6620      		tst r6
 1263 0186 01F0      		breq .L90
 1264 0188 262D      		mov r18,r6
 1265 018a 2130      		cpi r18,lo8(1)
 1266 018c 01F0      		breq .L91
 357:quantum/action.c ****                         if (tap_count > 0) {
 1267               		.loc 1 357 21 view .LVU284
 357:quantum/action.c ****                         if (tap_count > 0) {
 1268               		.loc 1 357 24 is_stmt 0 view .LVU285
 1269 018e 1123      		tst r17
 1270 0190 01F0      		breq .L99
 358:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1271               		.loc 1 358 25 is_stmt 1 view .LVU286
 358:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1272               		.loc 1 358 28 is_stmt 0 view .LVU287
 1273 0192 0023      		tst r16
 1274 0194 01F0      		breq .L100
 360:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1275               		.loc 1 360 29 is_stmt 1 view .LVU288
 364:quantum/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1276               		.loc 1 364 33 is_stmt 0 view .LVU289
 1277 0196 F601      		movw r30,r12
 1278 0198 8581      		ldd r24,Z+5
 360:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1279               		.loc 1 360 32 view .LVU290
 1280 019a 80FF      		sbrs r24,0
 1281 019c 00C0      		rjmp .L212
 365:quantum/action.c ****                                 // ad hoc: set 0 to cancel tap
 1282               		.loc 1 365 76 is_stmt 1 view .LVU291
 367:quantum/action.c ****                                 register_mods(mods);
 1283               		.loc 1 367 33 view .LVU292
 367:quantum/action.c ****                                 register_mods(mods);
 1284               		.loc 1 367 51 is_stmt 0 view .LVU293
 1285 019e 8F70      		andi r24,lo8(15)
 1286 01a0 8583      		std Z+5,r24
 368:quantum/action.c ****                             } else
 1287               		.loc 1 368 33 is_stmt 1 view .LVU294
 1288 01a2 00C0      		rjmp .L100
 1289               	.L90:
 306:quantum/action.c ****                         if (tap_count == 0) {
 1290               		.loc 1 306 21 view .LVU295
 306:quantum/action.c ****                         if (tap_count == 0) {
 1291               		.loc 1 306 24 is_stmt 0 view .LVU296
 1292 01a4 1123      		tst r17
 1293 01a6 01F0      		breq .L93
 307:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1294               		.loc 1 307 25 is_stmt 1 view .LVU297
 307:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1295               		.loc 1 307 28 is_stmt 0 view .LVU298
 1296 01a8 0111      		cpse r16,__zero_reg__
 1297 01aa 00C0      		rjmp .L94
 1298               	.L95:
 321:quantum/action.c ****                         }
 1299               		.loc 1 321 29 is_stmt 1 view .LVU299
 321:quantum/action.c ****                         }
 1300               		.loc 1 321 50 is_stmt 0 view .LVU300
 1301 01ac 0E94 0000 		call get_oneshot_mods
 1302               	.LVL119:
 321:quantum/action.c ****                         }
 1303               		.loc 1 321 29 view .LVU301
 1304 01b0 8F29      		or r24,r15
 1305               	.LVL120:
 1306               	.L210:
 321:quantum/action.c ****                         }
 1307               		.loc 1 321 29 view .LVU302
 1308               	.LBE85:
 491:quantum/action.c ****             } else {
 1309               		.loc 1 491 17 view .LVU303
 1310 01b2 0E94 0000 		call register_mods
 1311               	.LVL121:
 1312 01b6 00C0      		rjmp .L70
 1313               	.LVL122:
 1314               	.L94:
 1315               	.LBB86:
 310:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1316               		.loc 1 310 32 is_stmt 1 view .LVU304
 310:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1317               		.loc 1 310 35 is_stmt 0 view .LVU305
 1318 01b8 0130      		cpi r16,lo8(1)
 1319 01ba 01F4      		brne .L95
 311:quantum/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1320               		.loc 1 311 65 is_stmt 1 view .LVU306
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1321               		.loc 1 312 29 view .LVU307
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1322               		.loc 1 312 53 is_stmt 0 view .LVU308
 1323 01bc 0E94 0000 		call get_oneshot_mods
 1324               	.LVL123:
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1325               		.loc 1 312 29 view .LVU309
 1326 01c0 8F29      		or r24,r15
 1327 01c2 0E94 0000 		call set_oneshot_mods
 1328               	.LVL124:
 1329 01c6 00C0      		rjmp .L70
 1330               	.L93:
 324:quantum/action.c ****                             clear_oneshot_mods();
 1331               		.loc 1 324 25 is_stmt 1 view .LVU310
 324:quantum/action.c ****                             clear_oneshot_mods();
 1332               		.loc 1 324 28 is_stmt 0 view .LVU311
 1333 01c8 0111      		cpse r16,__zero_reg__
 1334 01ca 00C0      		rjmp .L96
 1335               	.L216:
 339:quantum/action.c ****                             unregister_mods(mods);
 1336               		.loc 1 339 29 is_stmt 1 view .LVU312
 1337 01cc 0E94 0000 		call clear_oneshot_mods
 1338               	.LVL125:
 340:quantum/action.c ****                         }
 1339               		.loc 1 340 29 view .LVU313
 1340               	.L102:
 389:quantum/action.c ****                             unregister_mods(mods);
 1341               		.loc 1 389 67 view .LVU314
 390:quantum/action.c ****                         }
 1342               		.loc 1 390 29 view .LVU315
 1343 01d0 8F2D      		mov r24,r15
 1344 01d2 0E94 0000 		call unregister_mods
 1345               	.LVL126:
 1346 01d6 00C0      		rjmp .L70
 1347               	.L96:
 327:quantum/action.c ****                             // Retain Oneshot mods
 1348               		.loc 1 327 32 view .LVU316
 327:quantum/action.c ****                             // Retain Oneshot mods
 1349               		.loc 1 327 35 is_stmt 0 view .LVU317
 1350 01d8 0130      		cpi r16,lo8(1)
 1351 01da 01F4      		brne .+2
 1352 01dc 00C0      		rjmp .L70
 1353 01de 00C0      		rjmp .L216
 1354               	.L91:
 346:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1355               		.loc 1 346 21 is_stmt 1 view .LVU318
 346:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1356               		.loc 1 346 24 is_stmt 0 view .LVU319
 1357 01e0 1123      		tst r17
 1358 01e2 01F0      		breq .L98
 347:quantum/action.c ****                             register_mods(mods);
 1359               		.loc 1 347 25 is_stmt 1 view .LVU320
 347:quantum/action.c ****                             register_mods(mods);
 1360               		.loc 1 347 28 is_stmt 0 view .LVU321
 1361 01e4 0630      		cpi r16,lo8(6)
 1362 01e6 00F0      		brlo .+2
 1363 01e8 00C0      		rjmp .L70
 1364               	.L100:
 376:quantum/action.c ****                             register_mods(mods);
 1365               		.loc 1 376 67 is_stmt 1 view .LVU322
 377:quantum/action.c ****                         }
 1366               		.loc 1 377 29 view .LVU323
 1367 01ea 8F2D      		mov r24,r15
 1368 01ec 00C0      		rjmp .L210
 1369               	.L98:
 351:quantum/action.c ****                             unregister_mods(mods);
 1370               		.loc 1 351 25 view .LVU324
 351:quantum/action.c ****                             unregister_mods(mods);
 1371               		.loc 1 351 28 is_stmt 0 view .LVU325
 1372 01ee 0530      		cpi r16,lo8(5)
 1373 01f0 00F0      		brlo .+2
 1374 01f2 00C0      		rjmp .L70
 1375 01f4 00C0      		rjmp .L102
 1376               	.L99:
 380:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1377               		.loc 1 380 25 is_stmt 1 view .LVU326
 380:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1378               		.loc 1 380 28 is_stmt 0 view .LVU327
 1379 01f6 0023      		tst r16
 1380 01f8 01F0      		breq .L102
 381:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1381               		.loc 1 381 71 is_stmt 1 view .LVU328
 382:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1382               		.loc 1 382 29 view .LVU329
 382:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1383               		.loc 1 382 32 is_stmt 0 view .LVU330
 1384 01fa FD81      		ldd r31,Y+5
 1385 01fc F933      		cpi r31,lo8(57)
 1386 01fe 01F4      		brne .L103
 383:quantum/action.c ****                             } else {
 1387               		.loc 1 383 33 is_stmt 1 view .LVU331
 383:quantum/action.c ****                             } else {
 1388               		.loc 1 383 33 view .LVU332
 383:quantum/action.c ****                             } else {
 1389               		.loc 1 383 33 view .LVU333
 1390               	.LVL127:
 1391               	.LBB80:
 1392               	.LBI80:
 166:/usr/avr/include/util/delay.h **** {
 1393               		.loc 4 166 1 view .LVU334
 1394               	.LBB81:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1395               		.loc 4 168 2 view .LVU335
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1396               		.loc 4 172 2 view .LVU336
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1397               		.loc 4 173 2 view .LVU337
 174:/usr/avr/include/util/delay.h **** 
 1398               		.loc 4 174 2 view .LVU338
 184:/usr/avr/include/util/delay.h **** 	#endif
 1399               		.loc 4 184 3 view .LVU339
 1400               		.loc 4 187 2 view .LVU340
 1401 0200 2FEF      		ldi r18,lo8(255999)
 1402 0202 87EE      		ldi r24,hi8(255999)
 1403 0204 93E0      		ldi r25,hlo8(255999)
 1404 0206 2150      	1:	subi r18,1
 1405 0208 8040      		sbci r24,0
 1406 020a 9040      		sbci r25,0
 1407 020c 01F4      		brne 1b
 1408               	.LVL128:
 1409               	.L206:
 1410               		.loc 4 187 2 is_stmt 0 view .LVU341
 1411               	.LBE81:
 1412               	.LBE80:
 1413               	.LBE86:
 1414               	.LBB87:
 1415               	.LBB88:
 1416 020e 00C0      		rjmp .
 1417 0210 0000      		nop
 1418               	.LBE88:
 1419               	.LBE87:
 576:quantum/action.c ****                             }
 1420               		.loc 1 576 33 is_stmt 1 view .LVU342
 578:quantum/action.c ****                         } else {
 1421               		.loc 1 578 29 view .LVU343
 1422 0212 8D81      		ldd r24,Y+5
 1423 0214 0E94 0000 		call unregister_code
 1424               	.LVL129:
 1425 0218 00C0      		rjmp .L70
 1426               	.LVL130:
 1427               	.L103:
 1428               	.LBB90:
 385:quantum/action.c ****                             }
 1429               		.loc 1 385 33 view .LVU344
 385:quantum/action.c ****                             }
 1430               		.loc 1 385 33 view .LVU345
 385:quantum/action.c ****                             }
 1431               		.loc 1 385 33 view .LVU346
 1432               	.LBB82:
 1433               	.LBI82:
 166:/usr/avr/include/util/delay.h **** {
 1434               		.loc 4 166 1 view .LVU347
 1435               	.LBB83:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1436               		.loc 4 168 2 view .LVU348
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1437               		.loc 4 172 2 view .LVU349
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1438               		.loc 4 173 2 view .LVU350
 174:/usr/avr/include/util/delay.h **** 
 1439               		.loc 4 174 2 view .LVU351
 184:/usr/avr/include/util/delay.h **** 	#endif
 1440               		.loc 4 184 3 view .LVU352
 1441               		.loc 4 187 2 view .LVU353
 1442 021a EFE3      		ldi r30,lo8(-25537)
 1443 021c FCE9      		ldi r31,hi8(-25537)
 1444 021e 3197      	1:	sbiw r30,1
 1445 0220 01F4      		brne 1b
 1446 0222 00C0      		rjmp .L206
 1447               	.LVL131:
 1448               	.L76:
 1449               		.loc 4 187 2 is_stmt 0 view .LVU354
 1450               	.LBE83:
 1451               	.LBE82:
 1452               	.LBE90:
 400:quantum/action.c ****                 case PAGE_SYSTEM:
 1453               		.loc 1 400 13 is_stmt 1 view .LVU355
 400:quantum/action.c ****                 case PAGE_SYSTEM:
 1454               		.loc 1 400 33 is_stmt 0 view .LVU356
 1455 0224 8E81      		ldd r24,Y+6
 1456 0226 8695      		lsr r24
 1457 0228 8695      		lsr r24
 1458 022a 8370      		andi r24,lo8(3)
 1459 022c 01F0      		breq .L105
 1460 022e 8130      		cpi r24,lo8(1)
 1461 0230 01F0      		breq .+2
 1462 0232 00C0      		rjmp .L70
 409:quantum/action.c ****                         host_consumer_send(action.usage.code);
 1463               		.loc 1 409 21 is_stmt 1 view .LVU357
 410:quantum/action.c ****                     } else {
 1464               		.loc 1 410 25 is_stmt 0 view .LVU358
 1465 0234 8D81      		ldd r24,Y+5
 1466 0236 9E81      		ldd r25,Y+6
 1467 0238 9370      		andi r25,lo8(3)
 409:quantum/action.c ****                         host_consumer_send(action.usage.code);
 1468               		.loc 1 409 24 view .LVU359
 1469 023a 1111      		cpse r17,__zero_reg__
 1470 023c 00C0      		rjmp .L213
 412:quantum/action.c ****                     }
 1471               		.loc 1 412 25 is_stmt 1 view .LVU360
 1472 023e 90E0      		ldi r25,0
 1473 0240 80E0      		ldi r24,0
 1474               	.L213:
 1475 0242 0E94 0000 		call host_consumer_send
 1476               	.LVL132:
 1477 0246 00C0      		rjmp .L70
 1478               	.L105:
 402:quantum/action.c ****                         host_system_send(action.usage.code);
 1479               		.loc 1 402 21 view .LVU361
 403:quantum/action.c ****                     } else {
 1480               		.loc 1 403 25 is_stmt 0 view .LVU362
 1481 0248 8D81      		ldd r24,Y+5
 1482 024a 9E81      		ldd r25,Y+6
 1483 024c 9370      		andi r25,lo8(3)
 402:quantum/action.c ****                         host_system_send(action.usage.code);
 1484               		.loc 1 402 24 view .LVU363
 1485 024e 1111      		cpse r17,__zero_reg__
 1486 0250 00C0      		rjmp .L207
 405:quantum/action.c ****                     }
 1487               		.loc 1 405 25 is_stmt 1 view .LVU364
 1488 0252 90E0      		ldi r25,0
 1489 0254 80E0      		ldi r24,0
 1490               	.L207:
 1491 0256 0E94 0000 		call host_system_send
 1492               	.LVL133:
 1493 025a 00C0      		rjmp .L70
 1494               	.L74:
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1495               		.loc 1 444 13 view .LVU365
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1496               		.loc 1 444 39 is_stmt 0 view .LVU366
 1497 025c 8E81      		ldd r24,Y+6
 1498 025e 8370      		andi r24,lo8(3)
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1499               		.loc 1 444 16 view .LVU367
 1500 0260 01F0      		breq .+2
 1501 0262 00C0      		rjmp .L109
 446:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1502               		.loc 1 446 17 is_stmt 1 view .LVU368
 446:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1503               		.loc 1 446 20 is_stmt 0 view .LVU369
 1504 0264 1111      		cpse r17,__zero_reg__
 1505 0266 00C0      		rjmp .L70
 1506               	.LBB91:
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1507               		.loc 1 447 21 is_stmt 1 view .LVU370
 1508               	.LVL134:
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1509               		.loc 1 448 21 view .LVU371
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1510               		.loc 1 447 61 is_stmt 0 view .LVU372
 1511 0268 2D81      		ldd r18,Y+5
 1512 026a 2295      		swap r18
 1513 026c 2695      		lsr r18
 1514 026e 2770      		andi r18,lo8(7)
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1515               		.loc 1 447 35 view .LVU373
 1516 0270 220F      		lsl r18
 1517 0272 220F      		lsl r18
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1518               		.loc 1 448 77 view .LVU374
 1519 0274 4D81      		ldd r20,Y+5
 1520 0276 4F70      		andi r20,lo8(15)
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1521               		.loc 1 448 44 view .LVU375
 1522 0278 50E0      		ldi r21,0
 1523 027a 70E0      		ldi r23,0
 1524 027c 60E0      		ldi r22,0
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1525               		.loc 1 448 35 view .LVU376
 1526 027e 022E      		mov r0,r18
 1527 0280 00C0      		rjmp 2f
 1528               		1:
 1529 0282 440F      		lsl r20
 1530 0284 551F      		rol r21
 1531 0286 661F      		rol r22
 1532 0288 771F      		rol r23
 1533               		2:
 1534 028a 0A94      		dec r0
 1535 028c 02F4      		brpl 1b
 1536               	.LVL135:
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1537               		.loc 1 449 21 is_stmt 1 view .LVU377
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1538               		.loc 1 449 104 is_stmt 0 view .LVU378
 1539 028e 6D80      		ldd r6,Y+5
 1540 0290 80E0      		ldi r24,0
 1541 0292 90E0      		ldi r25,0
 1542 0294 DC01      		movw r26,r24
 1543 0296 64FE      		sbrs r6,4
 1544 0298 00C0      		rjmp .L110
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1545               		.loc 1 449 94 discriminator 1 view .LVU379
 1546 029a 8FE0      		ldi r24,lo8(15)
 1547 029c 90E0      		ldi r25,0
 1548 029e A0E0      		ldi r26,0
 1549 02a0 B0E0      		ldi r27,0
 1550 02a2 00C0      		rjmp 2f
 1551               		1:
 1552 02a4 880F      		lsl r24
 1553 02a6 991F      		rol r25
 1554 02a8 AA1F      		rol r26
 1555 02aa BB1F      		rol r27
 1556               		2:
 1557 02ac 2A95      		dec r18
 1558 02ae 02F4      		brpl 1b
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1559               		.loc 1 449 104 discriminator 1 view .LVU380
 1560 02b0 8095      		com r24
 1561 02b2 9095      		com r25
 1562 02b4 A095      		com r26
 1563 02b6 B095      		com r27
 1564               	.L110:
 1565               	.LVL136:
 450:quantum/action.c ****                         case OP_BIT_AND:
 1566               		.loc 1 450 21 is_stmt 1 discriminator 4 view .LVU381
 450:quantum/action.c ****                         case OP_BIT_AND:
 1567               		.loc 1 450 47 is_stmt 0 discriminator 4 view .LVU382
 1568 02b8 2E81      		ldd r18,Y+6
 1569 02ba 2695      		lsr r18
 1570 02bc 2695      		lsr r18
 1571 02be 2370      		andi r18,lo8(3)
 452:quantum/action.c ****                             break;
 1572               		.loc 1 452 29 discriminator 4 view .LVU383
 1573 02c0 3C01      		movw r6,r24
 1574 02c2 4D01      		movw r8,r26
 1575 02c4 642A      		or r6,r20
 1576 02c6 752A      		or r7,r21
 1577 02c8 862A      		or r8,r22
 1578 02ca 972A      		or r9,r23
 1579 02cc 6982      		std Y+1,r6
 1580 02ce 7A82      		std Y+2,r7
 1581 02d0 8B82      		std Y+3,r8
 1582 02d2 9C82      		std Y+4,r9
 1583 02d4 2230      		cpi r18,lo8(2)
 1584 02d6 01F0      		breq .L111
 1585 02d8 2330      		cpi r18,lo8(3)
 1586 02da 01F0      		breq .L112
 1587 02dc 2130      		cpi r18,lo8(1)
 1588 02de 01F0      		breq .L113
 452:quantum/action.c ****                             break;
 1589               		.loc 1 452 29 is_stmt 1 view .LVU384
 1590 02e0 C401      		movw r24,r8
 1591               	.LVL137:
 452:quantum/action.c ****                             break;
 1592               		.loc 1 452 29 is_stmt 0 view .LVU385
 1593 02e2 B301      		movw r22,r6
 1594 02e4 0E94 0000 		call default_layer_and
 1595               	.LVL138:
 453:quantum/action.c ****                         case OP_BIT_OR:
 1596               		.loc 1 453 29 is_stmt 1 view .LVU386
 1597 02e8 00C0      		rjmp .L70
 1598               	.LVL139:
 1599               	.L113:
 455:quantum/action.c ****                             break;
 1600               		.loc 1 455 29 view .LVU387
 1601 02ea 6981      		ldd r22,Y+1
 1602 02ec 7A81      		ldd r23,Y+2
 1603 02ee 8B81      		ldd r24,Y+3
 1604 02f0 9C81      		ldd r25,Y+4
 1605 02f2 0E94 0000 		call default_layer_or
 1606               	.LVL140:
 456:quantum/action.c ****                         case OP_BIT_XOR:
 1607               		.loc 1 456 29 view .LVU388
 1608 02f6 00C0      		rjmp .L70
 1609               	.LVL141:
 1610               	.L111:
 458:quantum/action.c ****                             break;
 1611               		.loc 1 458 29 view .LVU389
 1612 02f8 6981      		ldd r22,Y+1
 1613 02fa 7A81      		ldd r23,Y+2
 1614 02fc 8B81      		ldd r24,Y+3
 1615 02fe 9C81      		ldd r25,Y+4
 1616 0300 0E94 0000 		call default_layer_xor
 1617               	.LVL142:
 459:quantum/action.c ****                         case OP_BIT_SET:
 1618               		.loc 1 459 29 view .LVU390
 1619 0304 00C0      		rjmp .L70
 1620               	.LVL143:
 1621               	.L112:
 461:quantum/action.c ****                             break;
 1622               		.loc 1 461 29 view .LVU391
 1623 0306 6981      		ldd r22,Y+1
 1624 0308 7A81      		ldd r23,Y+2
 1625 030a 8B81      		ldd r24,Y+3
 1626 030c 9C81      		ldd r25,Y+4
 1627 030e 0E94 0000 		call default_layer_set
 1628               	.LVL144:
 462:quantum/action.c ****                     }
 1629               		.loc 1 462 29 view .LVU392
 1630 0312 00C0      		rjmp .L70
 1631               	.LVL145:
 1632               	.L109:
 462:quantum/action.c ****                     }
 1633               		.loc 1 462 29 is_stmt 0 view .LVU393
 1634               	.LBE91:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1635               		.loc 1 467 17 is_stmt 1 view .LVU394
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1636               		.loc 1 467 21 is_stmt 0 view .LVU395
 1637 0314 1123      		tst r17
 1638 0316 01F4      		brne .+2
 1639 0318 00C0      		rjmp .L114
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1640               		.loc 1 467 20 discriminator 1 view .LVU396
 1641 031a 7E80      		ldd r7,Y+6
 1642 031c 70FE      		sbrs r7,0
 1643 031e 00C0      		rjmp .L70
 1644               	.L115:
 1645               	.LBB92:
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1646               		.loc 1 468 21 is_stmt 1 view .LVU397
 1647               	.LVL146:
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1648               		.loc 1 469 21 view .LVU398
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1649               		.loc 1 468 61 is_stmt 0 view .LVU399
 1650 0320 2D81      		ldd r18,Y+5
 1651 0322 2295      		swap r18
 1652 0324 2695      		lsr r18
 1653 0326 2770      		andi r18,lo8(7)
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1654               		.loc 1 468 35 view .LVU400
 1655 0328 220F      		lsl r18
 1656 032a 220F      		lsl r18
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1657               		.loc 1 469 77 view .LVU401
 1658 032c 4D81      		ldd r20,Y+5
 1659 032e 4F70      		andi r20,lo8(15)
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1660               		.loc 1 469 44 view .LVU402
 1661 0330 50E0      		ldi r21,0
 1662 0332 70E0      		ldi r23,0
 1663 0334 60E0      		ldi r22,0
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1664               		.loc 1 469 35 view .LVU403
 1665 0336 022E      		mov r0,r18
 1666 0338 00C0      		rjmp 2f
 1667               		1:
 1668 033a 440F      		lsl r20
 1669 033c 551F      		rol r21
 1670 033e 661F      		rol r22
 1671 0340 771F      		rol r23
 1672               		2:
 1673 0342 0A94      		dec r0
 1674 0344 02F4      		brpl 1b
 1675               	.LVL147:
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1676               		.loc 1 470 21 is_stmt 1 view .LVU404
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1677               		.loc 1 470 104 is_stmt 0 view .LVU405
 1678 0346 9D80      		ldd r9,Y+5
 1679 0348 80E0      		ldi r24,0
 1680 034a 90E0      		ldi r25,0
 1681 034c DC01      		movw r26,r24
 1682 034e 94FE      		sbrs r9,4
 1683 0350 00C0      		rjmp .L116
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1684               		.loc 1 470 94 discriminator 1 view .LVU406
 1685 0352 8FE0      		ldi r24,lo8(15)
 1686 0354 90E0      		ldi r25,0
 1687 0356 A0E0      		ldi r26,0
 1688 0358 B0E0      		ldi r27,0
 1689 035a 00C0      		rjmp 2f
 1690               		1:
 1691 035c 880F      		lsl r24
 1692 035e 991F      		rol r25
 1693 0360 AA1F      		rol r26
 1694 0362 BB1F      		rol r27
 1695               		2:
 1696 0364 2A95      		dec r18
 1697 0366 02F4      		brpl 1b
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1698               		.loc 1 470 104 discriminator 1 view .LVU407
 1699 0368 8095      		com r24
 1700 036a 9095      		com r25
 1701 036c A095      		com r26
 1702 036e B095      		com r27
 1703               	.L116:
 1704               	.LVL148:
 471:quantum/action.c ****                         case OP_BIT_AND:
 1705               		.loc 1 471 21 is_stmt 1 discriminator 4 view .LVU408
 471:quantum/action.c ****                         case OP_BIT_AND:
 1706               		.loc 1 471 47 is_stmt 0 discriminator 4 view .LVU409
 1707 0370 2E81      		ldd r18,Y+6
 1708 0372 2695      		lsr r18
 1709 0374 2695      		lsr r18
 1710 0376 2370      		andi r18,lo8(3)
 473:quantum/action.c ****                             break;
 1711               		.loc 1 473 29 discriminator 4 view .LVU410
 1712 0378 3C01      		movw r6,r24
 1713 037a 4D01      		movw r8,r26
 1714 037c 642A      		or r6,r20
 1715 037e 752A      		or r7,r21
 1716 0380 862A      		or r8,r22
 1717 0382 972A      		or r9,r23
 1718 0384 6982      		std Y+1,r6
 1719 0386 7A82      		std Y+2,r7
 1720 0388 8B82      		std Y+3,r8
 1721 038a 9C82      		std Y+4,r9
 1722 038c 2230      		cpi r18,lo8(2)
 1723 038e 01F0      		breq .L117
 1724 0390 2330      		cpi r18,lo8(3)
 1725 0392 01F0      		breq .L118
 1726 0394 2130      		cpi r18,lo8(1)
 1727 0396 01F0      		breq .L119
 473:quantum/action.c ****                             break;
 1728               		.loc 1 473 29 is_stmt 1 view .LVU411
 1729 0398 C401      		movw r24,r8
 1730               	.LVL149:
 473:quantum/action.c ****                             break;
 1731               		.loc 1 473 29 is_stmt 0 view .LVU412
 1732 039a B301      		movw r22,r6
 1733 039c 0E94 0000 		call layer_and
 1734               	.LVL150:
 474:quantum/action.c ****                         case OP_BIT_OR:
 1735               		.loc 1 474 29 is_stmt 1 view .LVU413
 1736 03a0 00C0      		rjmp .L70
 1737               	.LVL151:
 1738               	.L114:
 474:quantum/action.c ****                         case OP_BIT_OR:
 1739               		.loc 1 474 29 is_stmt 0 view .LVU414
 1740               	.LBE92:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1741               		.loc 1 467 20 discriminator 2 view .LVU415
 1742 03a2 8E80      		ldd r8,Y+6
 1743 03a4 81FE      		sbrs r8,1
 1744 03a6 00C0      		rjmp .L70
 1745 03a8 00C0      		rjmp .L115
 1746               	.LVL152:
 1747               	.L119:
 1748               	.LBB93:
 476:quantum/action.c ****                             break;
 1749               		.loc 1 476 29 is_stmt 1 view .LVU416
 1750 03aa 6981      		ldd r22,Y+1
 1751 03ac 7A81      		ldd r23,Y+2
 1752 03ae 8B81      		ldd r24,Y+3
 1753 03b0 9C81      		ldd r25,Y+4
 1754 03b2 0E94 0000 		call layer_or
 1755               	.LVL153:
 477:quantum/action.c ****                         case OP_BIT_XOR:
 1756               		.loc 1 477 29 view .LVU417
 1757 03b6 00C0      		rjmp .L70
 1758               	.LVL154:
 1759               	.L117:
 479:quantum/action.c ****                             break;
 1760               		.loc 1 479 29 view .LVU418
 1761 03b8 6981      		ldd r22,Y+1
 1762 03ba 7A81      		ldd r23,Y+2
 1763 03bc 8B81      		ldd r24,Y+3
 1764 03be 9C81      		ldd r25,Y+4
 1765 03c0 0E94 0000 		call layer_xor
 1766               	.LVL155:
 480:quantum/action.c ****                         case OP_BIT_SET:
 1767               		.loc 1 480 29 view .LVU419
 1768 03c4 00C0      		rjmp .L70
 1769               	.LVL156:
 1770               	.L118:
 482:quantum/action.c ****                             break;
 1771               		.loc 1 482 29 view .LVU420
 1772 03c6 6981      		ldd r22,Y+1
 1773 03c8 7A81      		ldd r23,Y+2
 1774 03ca 8B81      		ldd r24,Y+3
 1775 03cc 9C81      		ldd r25,Y+4
 1776 03ce 0E94 0000 		call layer_state_set
 1777               	.LVL157:
 483:quantum/action.c ****                     }
 1778               		.loc 1 483 29 view .LVU421
 1779 03d2 00C0      		rjmp .L70
 1780               	.LVL158:
 1781               	.L73:
 483:quantum/action.c ****                     }
 1782               		.loc 1 483 29 is_stmt 0 view .LVU422
 1783               	.LBE93:
 489:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1784               		.loc 1 489 13 is_stmt 1 view .LVU423
 1785               	.LBB94:
 272:quantum/action.c ****             if (event.pressed) {
 1786               		.loc 1 272 70 is_stmt 0 view .LVU424
 1787 03d4 0E81      		ldd r16,Y+6
 1788               	.LVL159:
 272:quantum/action.c ****             if (event.pressed) {
 1789               		.loc 1 272 70 view .LVU425
 1790 03d6 0F70      		andi r16,lo8(15)
 1791               	.LBE94:
 489:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1792               		.loc 1 489 16 view .LVU426
 1793 03d8 1123      		tst r17
 1794 03da 01F0      		breq .L120
 490:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 1795               		.loc 1 490 17 is_stmt 1 view .LVU427
 1796 03dc 802F      		mov r24,r16
 1797 03de 0E94 0000 		call layer_on
 1798               	.LVL160:
 491:quantum/action.c ****             } else {
 1799               		.loc 1 491 17 view .LVU428
 1800 03e2 8D81      		ldd r24,Y+5
 1801 03e4 00C0      		rjmp .L210
 1802               	.L120:
 493:quantum/action.c ****                 layer_off(action.layer_mods.layer);
 1803               		.loc 1 493 17 view .LVU429
 1804 03e6 8D81      		ldd r24,Y+5
 1805 03e8 0E94 0000 		call unregister_mods
 1806               	.LVL161:
 494:quantum/action.c ****             }
 1807               		.loc 1 494 17 view .LVU430
 1808 03ec 802F      		mov r24,r16
 1809               	.L215:
 581:quantum/action.c ****                         }
 1810               		.loc 1 581 29 is_stmt 0 view .LVU431
 1811 03ee 0E94 0000 		call layer_off
 1812               	.LVL162:
 1813 03f2 00C0      		rjmp .L70
 1814               	.LVL163:
 1815               	.L71:
 500:quantum/action.c ****                 case OP_TAP_TOGGLE:
 1816               		.loc 1 500 13 is_stmt 1 view .LVU432
 1817 03f4 2D81      		ldd r18,Y+5
 1818 03f6 223F      		cpi r18,lo8(-14)
 1819 03f8 01F0      		breq .L121
 1820 03fa 00F4      		brsh .L122
 1821 03fc 203F      		cpi r18,lo8(-16)
 1822 03fe 01F0      		breq .L123
 1823 0400 213F      		cpi r18,lo8(-15)
 1824 0402 01F0      		breq .L124
 1825               	.L125:
 562:quantum/action.c ****                         if (tap_count > 0) {
 1826               		.loc 1 562 21 view .LVU433
 562:quantum/action.c ****                         if (tap_count > 0) {
 1827               		.loc 1 562 24 is_stmt 0 view .LVU434
 1828 0404 1123      		tst r17
 1829 0406 01F4      		brne .+2
 1830 0408 00C0      		rjmp .L134
 563:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1831               		.loc 1 563 25 is_stmt 1 view .LVU435
 563:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1832               		.loc 1 563 28 is_stmt 0 view .LVU436
 1833 040a 0111      		cpse r16,__zero_reg__
 1834 040c 00C0      		rjmp .L212
 567:quantum/action.c ****                             layer_on(action.layer_tap.val);
 1835               		.loc 1 567 76 is_stmt 1 view .LVU437
 568:quantum/action.c ****                         }
 1836               		.loc 1 568 29 view .LVU438
 1837 040e 8E81      		ldd r24,Y+6
 1838 0410 8F71      		andi r24,lo8(31)
 1839 0412 00C0      		rjmp .L214
 1840               	.L122:
 1841 0414 8D81      		ldd r24,Y+5
 1842 0416 833F      		cpi r24,lo8(-13)
 1843 0418 01F0      		breq .L126
 1844 041a 843F      		cpi r24,lo8(-12)
 1845 041c 01F4      		brne .L125
 548:quantum/action.c ****                         layer_on(action.layer_tap.val);
 1846               		.loc 1 548 21 view .LVU439
 548:quantum/action.c ****                         layer_on(action.layer_tap.val);
 1847               		.loc 1 548 24 is_stmt 0 view .LVU440
 1848 041e 1123      		tst r17
 1849 0420 01F0      		breq .L133
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1850               		.loc 1 549 25 is_stmt 1 view .LVU441
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1851               		.loc 1 549 50 is_stmt 0 view .LVU442
 1852 0422 0E81      		ldd r16,Y+6
 1853               	.LVL164:
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1854               		.loc 1 549 50 view .LVU443
 1855 0424 0F71      		andi r16,lo8(31)
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1856               		.loc 1 549 25 view .LVU444
 1857 0426 802F      		mov r24,r16
 1858 0428 0E94 0000 		call layer_on
 1859               	.LVL165:
 550:quantum/action.c ****                     } else {
 1860               		.loc 1 550 25 is_stmt 1 view .LVU445
 1861 042c 63E0      		ldi r22,lo8(3)
 1862 042e 802F      		mov r24,r16
 1863 0430 0E94 0000 		call set_oneshot_layer
 1864               	.LVL166:
 1865 0434 00C0      		rjmp .L70
 1866               	.LVL167:
 1867               	.L123:
 503:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1868               		.loc 1 503 21 view .LVU446
 503:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1869               		.loc 1 503 24 is_stmt 0 view .LVU447
 1870 0436 1123      		tst r17
 1871 0438 01F0      		breq .L128
 504:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1872               		.loc 1 504 25 is_stmt 1 view .LVU448
 504:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1873               		.loc 1 504 28 is_stmt 0 view .LVU449
 1874 043a 0530      		cpi r16,lo8(5)
 1875 043c 00F0      		brlo .+2
 1876 043e 00C0      		rjmp .L70
 1877               	.L129:
 505:quantum/action.c ****                         }
 1878               		.loc 1 505 29 is_stmt 1 view .LVU450
 1879 0440 8E81      		ldd r24,Y+6
 1880 0442 8F71      		andi r24,lo8(31)
 1881 0444 0E94 0000 		call layer_invert
 1882               	.LVL168:
 1883 0448 00C0      		rjmp .L70
 1884               	.L128:
 508:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1885               		.loc 1 508 25 view .LVU451
 508:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1886               		.loc 1 508 28 is_stmt 0 view .LVU452
 1887 044a 0630      		cpi r16,lo8(6)
 1888 044c 00F0      		brlo .+2
 1889 044e 00C0      		rjmp .L70
 1890 0450 00C0      		rjmp .L129
 1891               	.L124:
 514:quantum/action.c ****                     break;
 1892               		.loc 1 514 21 is_stmt 1 view .LVU453
 505:quantum/action.c ****                         }
 1893               		.loc 1 505 58 is_stmt 0 view .LVU454
 1894 0452 8E81      		ldd r24,Y+6
 1895 0454 8F71      		andi r24,lo8(31)
 514:quantum/action.c ****                     break;
 1896               		.loc 1 514 68 view .LVU455
 1897 0456 1123      		tst r17
 1898 0458 01F0      		breq .L215
 1899               	.L214:
 568:quantum/action.c ****                         }
 1900               		.loc 1 568 29 view .LVU456
 1901 045a 0E94 0000 		call layer_on
 1902               	.LVL169:
 1903 045e 00C0      		rjmp .L70
 1904               	.L121:
 517:quantum/action.c ****                     break;
 1905               		.loc 1 517 21 is_stmt 1 view .LVU457
 505:quantum/action.c ****                         }
 1906               		.loc 1 505 58 is_stmt 0 view .LVU458
 1907 0460 8E81      		ldd r24,Y+6
 1908 0462 8F71      		andi r24,lo8(31)
 517:quantum/action.c ****                     break;
 1909               		.loc 1 517 69 view .LVU459
 1910 0464 1123      		tst r17
 1911 0466 01F0      		breq .L214
 1912 0468 00C0      		rjmp .L215
 1913               	.L126:
 520:quantum/action.c ****                     break;
 1914               		.loc 1 520 21 is_stmt 1 view .LVU460
 520:quantum/action.c ****                     break;
 1915               		.loc 1 520 70 is_stmt 0 view .LVU461
 1916 046a 1123      		tst r17
 1917 046c 01F0      		breq .L132
 520:quantum/action.c ****                     break;
 1918               		.loc 1 520 37 discriminator 1 view .LVU462
 1919 046e 8E81      		ldd r24,Y+6
 1920 0470 8F71      		andi r24,lo8(31)
 1921 0472 0E94 0000 		call layer_move
 1922               	.LVL170:
 1923 0476 00C0      		rjmp .L70
 1924               	.L132:
 520:quantum/action.c ****                     break;
 1925               		.loc 1 520 72 discriminator 2 view .LVU463
 1926 0478 0E94 0000 		call layer_clear
 1927               	.LVL171:
 1928 047c 00C0      		rjmp .L70
 1929               	.L133:
 552:quantum/action.c ****                         if (tap_count > 1) {
 1930               		.loc 1 552 25 is_stmt 1 view .LVU464
 1931 047e 81E0      		ldi r24,lo8(1)
 1932 0480 0E94 0000 		call clear_oneshot_layer_state
 1933               	.LVL172:
 553:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1934               		.loc 1 553 25 view .LVU465
 553:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1935               		.loc 1 553 28 is_stmt 0 view .LVU466
 1936 0484 0230      		cpi r16,lo8(2)
 1937 0486 00F4      		brsh .+2
 1938 0488 00C0      		rjmp .L70
 554:quantum/action.c ****                         }
 1939               		.loc 1 554 29 is_stmt 1 view .LVU467
 1940 048a 82E0      		ldi r24,lo8(2)
 1941 048c 0E94 0000 		call clear_oneshot_layer_state
 1942               	.LVL173:
 1943 0490 00C0      		rjmp .L70
 1944               	.L134:
 571:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1945               		.loc 1 571 25 view .LVU468
 571:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1946               		.loc 1 571 28 is_stmt 0 view .LVU469
 1947 0492 0023      		tst r16
 1948 0494 01F0      		breq .L136
 572:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1949               		.loc 1 572 77 is_stmt 1 view .LVU470
 573:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1950               		.loc 1 573 29 view .LVU471
 573:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1951               		.loc 1 573 32 is_stmt 0 view .LVU472
 1952 0496 9D81      		ldd r25,Y+5
 1953 0498 9933      		cpi r25,lo8(57)
 1954 049a 01F4      		brne .L137
 574:quantum/action.c ****                             } else {
 1955               		.loc 1 574 33 is_stmt 1 view .LVU473
 574:quantum/action.c ****                             } else {
 1956               		.loc 1 574 33 view .LVU474
 574:quantum/action.c ****                             } else {
 1957               		.loc 1 574 33 view .LVU475
 1958               	.LVL174:
 1959               	.LBB95:
 1960               	.LBI95:
 166:/usr/avr/include/util/delay.h **** {
 1961               		.loc 4 166 1 view .LVU476
 1962               	.LBB96:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1963               		.loc 4 168 2 view .LVU477
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1964               		.loc 4 172 2 view .LVU478
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1965               		.loc 4 173 2 view .LVU479
 174:/usr/avr/include/util/delay.h **** 
 1966               		.loc 4 174 2 view .LVU480
 184:/usr/avr/include/util/delay.h **** 	#endif
 1967               		.loc 4 184 3 view .LVU481
 1968               		.loc 4 187 2 view .LVU482
 1969 049c EFEF      		ldi r30,lo8(255999)
 1970 049e F7EE      		ldi r31,hi8(255999)
 1971 04a0 23E0      		ldi r18,hlo8(255999)
 1972 04a2 E150      	1:	subi r30,1
 1973 04a4 F040      		sbci r31,0
 1974 04a6 2040      		sbci r18,0
 1975 04a8 01F4      		brne 1b
 1976 04aa 00C0      		rjmp .L206
 1977               	.LVL175:
 1978               	.L137:
 1979               		.loc 4 187 2 is_stmt 0 view .LVU483
 1980               	.LBE96:
 1981               	.LBE95:
 576:quantum/action.c ****                             }
 1982               		.loc 1 576 33 is_stmt 1 view .LVU484
 576:quantum/action.c ****                             }
 1983               		.loc 1 576 33 view .LVU485
 576:quantum/action.c ****                             }
 1984               		.loc 1 576 33 view .LVU486
 1985               	.LBB97:
 1986               	.LBI87:
 166:/usr/avr/include/util/delay.h **** {
 1987               		.loc 4 166 1 view .LVU487
 1988               	.LBB89:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1989               		.loc 4 168 2 view .LVU488
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1990               		.loc 4 172 2 view .LVU489
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1991               		.loc 4 173 2 view .LVU490
 174:/usr/avr/include/util/delay.h **** 
 1992               		.loc 4 174 2 view .LVU491
 184:/usr/avr/include/util/delay.h **** 	#endif
 1993               		.loc 4 184 3 view .LVU492
 1994               		.loc 4 187 2 view .LVU493
 1995 04ac 8FE3      		ldi r24,lo8(-25537)
 1996 04ae 9CE9      		ldi r25,hi8(-25537)
 1997 04b0 0197      	1:	sbiw r24,1
 1998 04b2 01F4      		brne 1b
 1999 04b4 00C0      		rjmp .L206
 2000               	.LVL176:
 2001               	.L136:
 2002               		.loc 4 187 2 is_stmt 0 view .LVU494
 2003               	.LBE89:
 2004               	.LBE97:
 580:quantum/action.c ****                             layer_off(action.layer_tap.val);
 2005               		.loc 1 580 79 is_stmt 1 view .LVU495
 581:quantum/action.c ****                         }
 2006               		.loc 1 581 29 view .LVU496
 2007 04b6 8E81      		ldd r24,Y+6
 2008 04b8 8F71      		andi r24,lo8(31)
 2009 04ba 00C0      		rjmp .L215
 2010               	.L75:
 597:quantum/action.c ****                 case OP_SH_TOGGLE:
 2011               		.loc 1 597 13 view .LVU497
 2012 04bc ED81      		ldd r30,Y+5
 2013 04be E05F      		subi r30,lo8(-(16))
 2014 04c0 E730      		cpi r30,lo8(7)
 2015 04c2 00F4      		brsh .L139
 2016 04c4 F0E0      		ldi r31,0
 2017 04c6 E050      		subi r30,lo8(-(gs(.L141)))
 2018 04c8 F040      		sbci r31,hi8(-(gs(.L141)))
 2019 04ca 0C94 0000 		jmp __tablejump2__
 2020               		.section	.jumptables.gcc.process_action,"a",@progbits
 2021               		.p2align	1
 2022               	.L141:
 2023 0018 0000      		.word gs(.L147)
 2024 001a 0000      		.word gs(.L146)
 2025 001c 0000      		.word gs(.L145)
 2026 001e 0000      		.word gs(.L144)
 2027 0020 0000      		.word gs(.L143)
 2028 0022 0000      		.word gs(.L142)
 2029 0024 0000      		.word gs(.L140)
 2030               		.section	.text.process_action
 2031               	.L147:
 599:quantum/action.c ****                         swap_hands = !swap_hands;
 2032               		.loc 1 599 21 view .LVU498
 599:quantum/action.c ****                         swap_hands = !swap_hands;
 2033               		.loc 1 599 24 is_stmt 0 view .LVU499
 2034 04ce 1123      		tst r17
 2035 04d0 01F4      		brne .+2
 2036 04d2 00C0      		rjmp .L70
 2037               	.L150:
 600:quantum/action.c ****                     }
 2038               		.loc 1 600 25 is_stmt 1 view .LVU500
 2039 04d4 8091 0000 		lds r24,swap_hands
 2040 04d8 91E0      		ldi r25,lo8(1)
 2041 04da 8927      		eor r24,r25
 2042               	.L208:
 611:quantum/action.c ****                     }
 2043               		.loc 1 611 36 is_stmt 0 view .LVU501
 2044 04dc 8093 0000 		sts swap_hands,r24
 2045 04e0 00C0      		rjmp .L70
 2046               	.L145:
 604:quantum/action.c ****                     break;
 2047               		.loc 1 604 21 is_stmt 1 view .LVU502
 604:quantum/action.c ****                     break;
 2048               		.loc 1 604 32 is_stmt 0 view .LVU503
 2049 04e2 1093 0000 		sts swap_hands,r17
 605:quantum/action.c ****                 case OP_SH_OFF_ON:
 2050               		.loc 1 605 21 is_stmt 1 view .LVU504
 2051 04e6 00C0      		rjmp .L70
 2052               	.L144:
 607:quantum/action.c ****                     break;
 2053               		.loc 1 607 21 view .LVU505
 2054 04e8 81E0      		ldi r24,lo8(1)
 2055 04ea 8127      		eor r24,r17
 2056 04ec 00C0      		rjmp .L208
 2057               	.L142:
 610:quantum/action.c ****                         swap_hands = true;
 2058               		.loc 1 610 21 view .LVU506
 610:quantum/action.c ****                         swap_hands = true;
 2059               		.loc 1 610 24 is_stmt 0 view .LVU507
 2060 04ee 1111      		cpse r17,__zero_reg__
 2061 04f0 00C0      		rjmp .L70
 611:quantum/action.c ****                     }
 2062               		.loc 1 611 25 is_stmt 1 view .LVU508
 611:quantum/action.c ****                     }
 2063               		.loc 1 611 36 is_stmt 0 view .LVU509
 2064 04f2 81E0      		ldi r24,lo8(1)
 2065 04f4 00C0      		rjmp .L208
 2066               	.L143:
 615:quantum/action.c ****                         swap_hands = false;
 2067               		.loc 1 615 21 is_stmt 1 view .LVU510
 615:quantum/action.c ****                         swap_hands = false;
 2068               		.loc 1 615 24 is_stmt 0 view .LVU511
 2069 04f6 1111      		cpse r17,__zero_reg__
 2070 04f8 00C0      		rjmp .L70
 616:quantum/action.c ****                     }
 2071               		.loc 1 616 25 is_stmt 1 view .LVU512
 616:quantum/action.c ****                     }
 2072               		.loc 1 616 36 is_stmt 0 view .LVU513
 2073 04fa 1092 0000 		sts swap_hands,__zero_reg__
 2074 04fe 00C0      		rjmp .L70
 2075               	.L140:
 621:quantum/action.c ****                         set_oneshot_swaphands();
 2076               		.loc 1 621 21 is_stmt 1 view .LVU514
 621:quantum/action.c ****                         set_oneshot_swaphands();
 2077               		.loc 1 621 24 is_stmt 0 view .LVU515
 2078 0500 1123      		tst r17
 2079 0502 01F0      		breq .L148
 622:quantum/action.c ****                     } else {
 2080               		.loc 1 622 25 is_stmt 1 view .LVU516
 2081 0504 0E94 0000 		call set_oneshot_swaphands
 2082               	.LVL177:
 2083 0508 00C0      		rjmp .L70
 2084               	.L148:
 624:quantum/action.c ****                     }
 2085               		.loc 1 624 25 view .LVU517
 2086 050a 0E94 0000 		call release_oneshot_swaphands
 2087               	.LVL178:
 2088 050e 00C0      		rjmp .L70
 2089               	.L146:
 633:quantum/action.c ****                         if (swap_held) {
 2090               		.loc 1 633 21 view .LVU518
 633:quantum/action.c ****                         if (swap_held) {
 2091               		.loc 1 633 24 is_stmt 0 view .LVU519
 2092 0510 1123      		tst r17
 2093 0512 01F0      		breq .L149
 634:quantum/action.c ****                             swap_held = false;
 2094               		.loc 1 634 25 is_stmt 1 view .LVU520
 634:quantum/action.c ****                             swap_held = false;
 2095               		.loc 1 634 28 is_stmt 0 view .LVU521
 2096 0514 8091 0000 		lds r24,swap_held
 2097 0518 8823      		tst r24
 2098 051a 01F0      		breq .L150
 2099               	.L209:
 662:quantum/action.c ****                         }
 2100               		.loc 1 662 29 is_stmt 1 view .LVU522
 662:quantum/action.c ****                         }
 2101               		.loc 1 662 40 is_stmt 0 view .LVU523
 2102 051c 1092 0000 		sts swap_held,__zero_reg__
 2103 0520 00C0      		rjmp .L70
 2104               	.L149:
 640:quantum/action.c ****                             swap_hands = !swap_hands;
 2105               		.loc 1 640 25 is_stmt 1 view .LVU524
 640:quantum/action.c ****                             swap_hands = !swap_hands;
 2106               		.loc 1 640 28 is_stmt 0 view .LVU525
 2107 0522 0530      		cpi r16,lo8(5)
 2108 0524 00F0      		brlo .L150
 2109 0526 00C0      		rjmp .L70
 2110               	.L139:
 647:quantum/action.c ****                         if (swap_held) {
 2111               		.loc 1 647 21 is_stmt 1 view .LVU526
 634:quantum/action.c ****                             swap_held = false;
 2112               		.loc 1 634 29 is_stmt 0 view .LVU527
 2113 0528 8091 0000 		lds r24,swap_held
 647:quantum/action.c ****                         if (swap_held) {
 2114               		.loc 1 647 24 view .LVU528
 2115 052c 0023      		tst r16
 2116 052e 01F0      		breq .L151
 648:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2117               		.loc 1 648 25 is_stmt 1 view .LVU529
 648:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2118               		.loc 1 648 28 is_stmt 0 view .LVU530
 2119 0530 8823      		tst r24
 2120 0532 01F0      		breq .L152
 649:quantum/action.c ****                             swap_held  = false;
 2121               		.loc 1 649 29 is_stmt 1 view .LVU531
 2122 0534 8091 0000 		lds r24,swap_hands
 2123 0538 91E0      		ldi r25,lo8(1)
 2124 053a 8927      		eor r24,r25
 649:quantum/action.c ****                             swap_held  = false;
 2125               		.loc 1 649 40 is_stmt 0 view .LVU532
 2126 053c 8093 0000 		sts swap_hands,r24
 650:quantum/action.c ****                         }
 2127               		.loc 1 650 29 is_stmt 1 view .LVU533
 650:quantum/action.c ****                         }
 2128               		.loc 1 650 40 is_stmt 0 view .LVU534
 2129 0540 1092 0000 		sts swap_held,__zero_reg__
 2130               	.L152:
 652:quantum/action.c ****                             register_code(action.swap.code);
 2131               		.loc 1 652 25 is_stmt 1 view .LVU535
 652:quantum/action.c ****                             register_code(action.swap.code);
 2132               		.loc 1 652 28 is_stmt 0 view .LVU536
 2133 0544 1111      		cpse r17,__zero_reg__
 2134 0546 00C0      		rjmp .L212
 2135               	.LBB98:
 655:quantum/action.c ****                             unregister_code(action.swap.code);
 2136               		.loc 1 655 29 is_stmt 1 view .LVU537
 655:quantum/action.c ****                             unregister_code(action.swap.code);
 2137               		.loc 1 655 29 view .LVU538
 655:quantum/action.c ****                             unregister_code(action.swap.code);
 2138               		.loc 1 655 29 view .LVU539
 2139               	.LVL179:
 2140               	.LBB99:
 2141               	.LBI99:
 166:/usr/avr/include/util/delay.h **** {
 2142               		.loc 4 166 1 view .LVU540
 2143               	.LBB100:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2144               		.loc 4 168 2 view .LVU541
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2145               		.loc 4 172 2 view .LVU542
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2146               		.loc 4 173 2 view .LVU543
 174:/usr/avr/include/util/delay.h **** 
 2147               		.loc 4 174 2 view .LVU544
 184:/usr/avr/include/util/delay.h **** 	#endif
 2148               		.loc 4 184 3 view .LVU545
 2149               		.loc 4 187 2 view .LVU546
 2150 0548 EFE3      		ldi r30,lo8(-25537)
 2151 054a FCE9      		ldi r31,hi8(-25537)
 2152 054c 3197      	1:	sbiw r30,1
 2153 054e 01F4      		brne 1b
 2154 0550 00C0      		rjmp .
 2155 0552 0000      		nop
 2156               	.LVL180:
 2157               		.loc 4 187 2 is_stmt 0 view .LVU547
 2158               	.LBE100:
 2159               	.LBE99:
 655:quantum/action.c ****                             unregister_code(action.swap.code);
 2160               		.loc 1 655 29 is_stmt 1 view .LVU548
 656:quantum/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 2161               		.loc 1 656 29 view .LVU549
 2162 0554 8D81      		ldd r24,Y+5
 2163 0556 0E94 0000 		call unregister_code
 2164               	.LVL181:
 657:quantum/action.c ****                         }
 2165               		.loc 1 657 29 view .LVU550
 657:quantum/action.c ****                         }
 2166               		.loc 1 657 37 is_stmt 0 view .LVU551
 2167 055a 86E0      		ldi r24,lo8(6)
 2168 055c F601      		movw r30,r12
 2169               		0:
 2170 055e 1192      		st Z+,__zero_reg__
 2171 0560 8A95      		dec r24
 2172 0562 01F4      		brne 0b
 2173 0564 00C0      		rjmp .L70
 2174               	.L151:
 657:quantum/action.c ****                         }
 2175               		.loc 1 657 37 view .LVU552
 2176               	.LBE98:
 660:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2177               		.loc 1 660 25 is_stmt 1 view .LVU553
 660:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2178               		.loc 1 660 28 is_stmt 0 view .LVU554
 2179 0566 8823      		tst r24
 2180 0568 01F4      		brne .+2
 2181 056a 00C0      		rjmp .L70
 660:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2182               		.loc 1 660 39 discriminator 1 view .LVU555
 2183 056c 1111      		cpse r17,__zero_reg__
 2184 056e 00C0      		rjmp .L70
 661:quantum/action.c ****                             swap_held  = false;
 2185               		.loc 1 661 29 is_stmt 1 view .LVU556
 2186 0570 8091 0000 		lds r24,swap_hands
 2187 0574 91E0      		ldi r25,lo8(1)
 2188 0576 8927      		eor r24,r25
 661:quantum/action.c ****                             swap_held  = false;
 2189               		.loc 1 661 40 is_stmt 0 view .LVU557
 2190 0578 8093 0000 		sts swap_hands,r24
 2191 057c 00C0      		rjmp .L209
 2192               	.LVL182:
 2193               	.L67:
 2194               	/* epilogue start */
 739:quantum/action.c **** 
 2195               		.loc 1 739 1 view .LVU558
 2196 057e 2696      		adiw r28,6
 2197 0580 0FB6      		in __tmp_reg__,__SREG__
 2198 0582 F894      		cli
 2199 0584 DEBF      		out __SP_H__,r29
 2200 0586 0FBE      		out __SREG__,__tmp_reg__
 2201 0588 CDBF      		out __SP_L__,r28
 2202 058a DF91      		pop r29
 2203 058c CF91      		pop r28
 2204 058e 1F91      		pop r17
 2205               	.LVL183:
 739:quantum/action.c **** 
 2206               		.loc 1 739 1 view .LVU559
 2207 0590 0F91      		pop r16
 2208 0592 FF90      		pop r15
 2209 0594 EF90      		pop r14
 2210               	.LVL184:
 739:quantum/action.c **** 
 2211               		.loc 1 739 1 view .LVU560
 2212 0596 DF90      		pop r13
 2213 0598 CF90      		pop r12
 2214               	.LVL185:
 739:quantum/action.c **** 
 2215               		.loc 1 739 1 view .LVU561
 2216 059a BF90      		pop r11
 2217 059c AF90      		pop r10
 2218 059e 9F90      		pop r9
 2219 05a0 8F90      		pop r8
 2220 05a2 7F90      		pop r7
 2221 05a4 6F90      		pop r6
 2222 05a6 0895      		ret
 2223               		.cfi_endproc
 2224               	.LFE28:
 2226               		.section	.text.process_record_handler,"ax",@progbits
 2227               	.global	process_record_handler
 2229               	process_record_handler:
 2230               	.LVL186:
 2231               	.LFB27:
 208:quantum/action.c **** #ifdef COMBO_ENABLE
 2232               		.loc 1 208 50 is_stmt 1 view -0
 2233               		.cfi_startproc
 208:quantum/action.c **** #ifdef COMBO_ENABLE
 2234               		.loc 1 208 50 is_stmt 0 view .LVU563
 2235 0000 0F93      		push r16
 2236               	.LCFI30:
 2237               		.cfi_def_cfa_offset 3
 2238               		.cfi_offset 16, -2
 2239 0002 1F93      		push r17
 2240               	.LCFI31:
 2241               		.cfi_def_cfa_offset 4
 2242               		.cfi_offset 17, -3
 2243 0004 CF93      		push r28
 2244               	.LCFI32:
 2245               		.cfi_def_cfa_offset 5
 2246               		.cfi_offset 28, -4
 2247 0006 DF93      		push r29
 2248               	.LCFI33:
 2249               		.cfi_def_cfa_offset 6
 2250               		.cfi_offset 29, -5
 2251               	/* prologue: function */
 2252               	/* frame size = 0 */
 2253               	/* stack size = 4 */
 2254               	.L__stack_usage = 4
 2255 0008 EC01      		movw r28,r24
 217:quantum/action.c **** #endif
 2256               		.loc 1 217 5 is_stmt 1 view .LVU564
 217:quantum/action.c **** #endif
 2257               		.loc 1 217 23 is_stmt 0 view .LVU565
 2258 000a 6881      		ld r22,Y
 2259 000c 7981      		ldd r23,Y+1
 2260 000e 8A81      		ldd r24,Y+2
 2261               	.LVL187:
 217:quantum/action.c **** #endif
 2262               		.loc 1 217 23 view .LVU566
 2263 0010 0E94 0000 		call store_or_get_action
 2264               	.LVL188:
 2265 0014 8C01      		movw r16,r24
 219:quantum/action.c ****     debug_action(action);
 2266               		.loc 1 219 23 is_stmt 1 view .LVU567
 220:quantum/action.c **** #ifndef NO_ACTION_LAYER
 2267               		.loc 1 220 5 view .LVU568
 222:quantum/action.c ****     layer_debug();
 2268               		.loc 1 222 29 view .LVU569
 223:quantum/action.c ****     dprint(" default_layer_state: ");
 2269               		.loc 1 223 5 view .LVU570
 2270 0016 0E94 0000 		call layer_debug
 2271               	.LVL189:
 224:quantum/action.c ****     default_layer_debug();
 2272               		.loc 1 224 37 view .LVU571
 225:quantum/action.c **** #endif
 2273               		.loc 1 225 5 view .LVU572
 2274 001a 0E94 0000 		call default_layer_debug
 2275               	.LVL190:
 227:quantum/action.c **** 
 2276               		.loc 1 227 15 view .LVU573
 229:quantum/action.c **** }
 2277               		.loc 1 229 5 view .LVU574
 2278 001e B801      		movw r22,r16
 2279 0020 CE01      		movw r24,r28
 2280               	/* epilogue start */
 230:quantum/action.c **** 
 2281               		.loc 1 230 1 is_stmt 0 view .LVU575
 2282 0022 DF91      		pop r29
 2283 0024 CF91      		pop r28
 2284               	.LVL191:
 230:quantum/action.c **** 
 2285               		.loc 1 230 1 view .LVU576
 2286 0026 1F91      		pop r17
 2287 0028 0F91      		pop r16
 229:quantum/action.c **** }
 2288               		.loc 1 229 5 view .LVU577
 2289 002a 0C94 0000 		jmp process_action
 2290               	.LVL192:
 229:quantum/action.c **** }
 2291               		.loc 1 229 5 view .LVU578
 2292               		.cfi_endproc
 2293               	.LFE27:
 2295               		.section	.text.process_record,"ax",@progbits
 2296               	.global	process_record
 2298               	process_record:
 2299               	.LVL193:
 2300               	.LFB26:
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 2301               		.loc 1 190 42 is_stmt 1 view -0
 2302               		.cfi_startproc
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 2303               		.loc 1 190 42 is_stmt 0 view .LVU580
 2304 0000 CF93      		push r28
 2305               	.LCFI34:
 2306               		.cfi_def_cfa_offset 3
 2307               		.cfi_offset 28, -2
 2308 0002 DF93      		push r29
 2309               	.LCFI35:
 2310               		.cfi_def_cfa_offset 4
 2311               		.cfi_offset 29, -3
 2312               	/* prologue: function */
 2313               	/* frame size = 0 */
 2314               	/* stack size = 2 */
 2315               	.L__stack_usage = 2
 2316 0004 EC01      		movw r28,r24
 191:quantum/action.c ****         return;
 2317               		.loc 1 191 5 is_stmt 1 view .LVU581
 2318 0006 9881      		ld r25,Y
 2319               	.LVL194:
 191:quantum/action.c ****         return;
 2320               		.loc 1 191 5 is_stmt 0 view .LVU582
 2321 0008 8981      		ldd r24,Y+1
 2322               	.LVL195:
 2323               	.LBB101:
 2324               	.LBI101:
 2325               		.loc 2 47 20 is_stmt 1 view .LVU583
 2326               	.LBB102:
 2327               		.loc 2 47 51 view .LVU584
 2328               		.loc 2 47 74 is_stmt 0 view .LVU585
 2329 000a 2B81      		ldd r18,Y+3
 2330 000c 3C81      		ldd r19,Y+4
 2331 000e 232B      		or r18,r19
 2332 0010 01F0      		breq .L218
 2333 0012 8923      		and r24,r25
 2334               	.LVL196:
 2335               		.loc 2 47 74 view .LVU586
 2336 0014 8F3F      		cpi r24,lo8(-1)
 2337 0016 01F4      		brne .L234
 2338               	.LVL197:
 2339               	.L218:
 2340               	/* epilogue start */
 2341               		.loc 2 47 74 view .LVU587
 2342               	.LBE102:
 2343               	.LBE101:
 206:quantum/action.c **** 
 2344               		.loc 1 206 1 view .LVU588
 2345 0018 DF91      		pop r29
 2346 001a CF91      		pop r28
 2347               	.LVL198:
 206:quantum/action.c **** 
 2348               		.loc 1 206 1 view .LVU589
 2349 001c 0895      		ret
 2350               	.LVL199:
 2351               	.L223:
 204:quantum/action.c ****     post_process_record_quantum(record);
 2352               		.loc 1 204 5 is_stmt 1 view .LVU590
 2353 001e CE01      		movw r24,r28
 2354 0020 0E94 0000 		call process_record_handler
 2355               	.LVL200:
 205:quantum/action.c **** }
 2356               		.loc 1 205 5 view .LVU591
 2357 0024 CE01      		movw r24,r28
 2358               	/* epilogue start */
 206:quantum/action.c **** 
 2359               		.loc 1 206 1 is_stmt 0 view .LVU592
 2360 0026 DF91      		pop r29
 2361 0028 CF91      		pop r28
 2362               	.LVL201:
 205:quantum/action.c **** }
 2363               		.loc 1 205 5 view .LVU593
 2364 002a 0C94 0000 		jmp post_process_record_quantum
 2365               	.LVL202:
 2366               	.L234:
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 2367               		.loc 1 195 5 is_stmt 1 view .LVU594
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 2368               		.loc 1 195 10 is_stmt 0 view .LVU595
 2369 002e CE01      		movw r24,r28
 2370 0030 0E94 0000 		call process_record_quantum
 2371               	.LVL203:
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 2372               		.loc 1 195 8 view .LVU596
 2373 0034 8111      		cpse r24,__zero_reg__
 2374 0036 00C0      		rjmp .L223
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2375               		.loc 1 197 9 is_stmt 1 view .LVU597
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2376               		.loc 1 197 13 is_stmt 0 view .LVU598
 2377 0038 0E94 0000 		call is_oneshot_layer_active
 2378               	.LVL204:
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2379               		.loc 1 197 12 view .LVU599
 2380 003c 8823      		tst r24
 2381 003e 01F0      		breq .L218
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2382               		.loc 1 197 39 discriminator 1 view .LVU600
 2383 0040 8A81      		ldd r24,Y+2
 2384 0042 8823      		tst r24
 2385 0044 01F0      		breq .L218
 198:quantum/action.c ****         }
 2386               		.loc 1 198 13 is_stmt 1 view .LVU601
 2387 0046 82E0      		ldi r24,lo8(2)
 2388               	/* epilogue start */
 206:quantum/action.c **** 
 2389               		.loc 1 206 1 is_stmt 0 view .LVU602
 2390 0048 DF91      		pop r29
 2391 004a CF91      		pop r28
 2392               	.LVL205:
 198:quantum/action.c ****         }
 2393               		.loc 1 198 13 view .LVU603
 2394 004c 0C94 0000 		jmp clear_oneshot_layer_state
 2395               	.LVL206:
 2396               		.cfi_endproc
 2397               	.LFE26:
 2399               		.section	.text.process_record_nocache,"ax",@progbits
 2400               	.global	process_record_nocache
 2402               	process_record_nocache:
 2403               	.LVL207:
 2404               	.LFB22:
 148:quantum/action.c ****     disable_action_cache = true;
 2405               		.loc 1 148 50 is_stmt 1 view -0
 2406               		.cfi_startproc
 2407               	/* prologue: function */
 2408               	/* frame size = 0 */
 2409               	/* stack size = 0 */
 2410               	.L__stack_usage = 0
 149:quantum/action.c ****     process_record(record);
 2411               		.loc 1 149 5 view .LVU605
 149:quantum/action.c ****     process_record(record);
 2412               		.loc 1 149 26 is_stmt 0 view .LVU606
 2413 0000 21E0      		ldi r18,lo8(1)
 2414 0002 2093 0000 		sts disable_action_cache,r18
 150:quantum/action.c ****     disable_action_cache = false;
 2415               		.loc 1 150 5 is_stmt 1 view .LVU607
 2416 0006 0E94 0000 		call process_record
 2417               	.LVL208:
 151:quantum/action.c **** }
 2418               		.loc 1 151 5 view .LVU608
 151:quantum/action.c **** }
 2419               		.loc 1 151 26 is_stmt 0 view .LVU609
 2420 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 2421               	/* epilogue start */
 152:quantum/action.c **** #else
 2422               		.loc 1 152 1 view .LVU610
 2423 000e 0895      		ret
 2424               		.cfi_endproc
 2425               	.LFE22:
 2427               		.section	.text.register_weak_mods,"ax",@progbits
 2428               	.global	register_weak_mods
 2430               	register_weak_mods:
 2431               	.LVL209:
 2432               	.LFB35:
 934:quantum/action.c **** 
 935:quantum/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 936:quantum/action.c ****  *
 937:quantum/action.c ****  * \param mods A bitfield of modifiers to register.
 938:quantum/action.c ****  */
 939:quantum/action.c **** void register_weak_mods(uint8_t mods) {
 2433               		.loc 1 939 39 is_stmt 1 view -0
 2434               		.cfi_startproc
 2435               	/* prologue: function */
 2436               	/* frame size = 0 */
 2437               	/* stack size = 0 */
 2438               	.L__stack_usage = 0
 940:quantum/action.c ****     if (mods) {
 2439               		.loc 1 940 5 view .LVU612
 2440               		.loc 1 940 8 is_stmt 0 view .LVU613
 2441 0000 8823      		tst r24
 2442 0002 01F0      		breq .L237
 941:quantum/action.c ****         add_weak_mods(mods);
 2443               		.loc 1 941 9 is_stmt 1 view .LVU614
 2444 0004 0E94 0000 		call add_weak_mods
 2445               	.LVL210:
 942:quantum/action.c ****         send_keyboard_report();
 2446               		.loc 1 942 9 view .LVU615
 2447 0008 0C94 0000 		jmp send_keyboard_report
 2448               	.LVL211:
 2449               	.L237:
 2450               	/* epilogue start */
 943:quantum/action.c ****     }
 944:quantum/action.c **** }
 2451               		.loc 1 944 1 is_stmt 0 view .LVU616
 2452 000c 0895      		ret
 2453               		.cfi_endproc
 2454               	.LFE35:
 2456               		.section	.text.unregister_weak_mods,"ax",@progbits
 2457               	.global	unregister_weak_mods
 2459               	unregister_weak_mods:
 2460               	.LVL212:
 2461               	.LFB36:
 945:quantum/action.c **** 
 946:quantum/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 947:quantum/action.c ****  *
 948:quantum/action.c ****  * \param mods A bitfield of modifiers to unregister.
 949:quantum/action.c ****  */
 950:quantum/action.c **** void unregister_weak_mods(uint8_t mods) {
 2462               		.loc 1 950 41 is_stmt 1 view -0
 2463               		.cfi_startproc
 2464               	/* prologue: function */
 2465               	/* frame size = 0 */
 2466               	/* stack size = 0 */
 2467               	.L__stack_usage = 0
 951:quantum/action.c ****     if (mods) {
 2468               		.loc 1 951 5 view .LVU618
 2469               		.loc 1 951 8 is_stmt 0 view .LVU619
 2470 0000 8823      		tst r24
 2471 0002 01F0      		breq .L239
 952:quantum/action.c ****         del_weak_mods(mods);
 2472               		.loc 1 952 9 is_stmt 1 view .LVU620
 2473 0004 0E94 0000 		call del_weak_mods
 2474               	.LVL213:
 953:quantum/action.c ****         send_keyboard_report();
 2475               		.loc 1 953 9 view .LVU621
 2476 0008 0C94 0000 		jmp send_keyboard_report
 2477               	.LVL214:
 2478               	.L239:
 2479               	/* epilogue start */
 954:quantum/action.c ****     }
 955:quantum/action.c **** }
 2480               		.loc 1 955 1 is_stmt 0 view .LVU622
 2481 000c 0895      		ret
 2482               		.cfi_endproc
 2483               	.LFE36:
 2485               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2486               	.global	clear_keyboard_but_mods_and_keys
 2488               	clear_keyboard_but_mods_and_keys:
 2489               	.LFB39:
 956:quantum/action.c **** 
 957:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:quantum/action.c ****  *
 959:quantum/action.c ****  * FIXME: Needs documentation.
 960:quantum/action.c ****  */
 961:quantum/action.c **** void clear_keyboard(void) {
 962:quantum/action.c ****     clear_mods();
 963:quantum/action.c ****     clear_keyboard_but_mods();
 964:quantum/action.c **** }
 965:quantum/action.c **** 
 966:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:quantum/action.c ****  *
 968:quantum/action.c ****  * FIXME: Needs documentation.
 969:quantum/action.c ****  */
 970:quantum/action.c **** void clear_keyboard_but_mods(void) {
 971:quantum/action.c ****     clear_keys();
 972:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 973:quantum/action.c **** }
 974:quantum/action.c **** 
 975:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 976:quantum/action.c ****  *
 977:quantum/action.c ****  * FIXME: Needs documentation.
 978:quantum/action.c ****  */
 979:quantum/action.c **** void clear_keyboard_but_mods_and_keys() {
 2490               		.loc 1 979 41 is_stmt 1 view -0
 2491               		.cfi_startproc
 2492               	/* prologue: function */
 2493               	/* frame size = 0 */
 2494               	/* stack size = 0 */
 2495               	.L__stack_usage = 0
 980:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 981:quantum/action.c ****     host_system_send(0);
 2496               		.loc 1 981 5 view .LVU624
 2497 0000 90E0      		ldi r25,0
 2498 0002 80E0      		ldi r24,0
 2499 0004 0E94 0000 		call host_system_send
 2500               	.LVL215:
 982:quantum/action.c ****     host_consumer_send(0);
 2501               		.loc 1 982 5 view .LVU625
 2502 0008 90E0      		ldi r25,0
 2503 000a 80E0      		ldi r24,0
 2504 000c 0E94 0000 		call host_consumer_send
 2505               	.LVL216:
 983:quantum/action.c **** #endif
 984:quantum/action.c ****     clear_weak_mods();
 2506               		.loc 1 984 5 view .LVU626
 2507 0010 0E94 0000 		call clear_weak_mods
 2508               	.LVL217:
 985:quantum/action.c ****     clear_macro_mods();
 2509               		.loc 1 985 5 view .LVU627
 2510 0014 0E94 0000 		call clear_macro_mods
 2511               	.LVL218:
 986:quantum/action.c ****     send_keyboard_report();
 2512               		.loc 1 986 5 view .LVU628
 2513 0018 0C94 0000 		jmp send_keyboard_report
 2514               	.LVL219:
 2515               		.cfi_endproc
 2516               	.LFE39:
 2518               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2519               	.global	clear_keyboard_but_mods
 2521               	clear_keyboard_but_mods:
 2522               	.LFB38:
 970:quantum/action.c ****     clear_keys();
 2523               		.loc 1 970 36 view -0
 2524               		.cfi_startproc
 2525               	/* prologue: function */
 2526               	/* frame size = 0 */
 2527               	/* stack size = 0 */
 2528               	.L__stack_usage = 0
 971:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 2529               		.loc 1 971 5 view .LVU630
 2530 0000 0E94 0000 		call clear_keys
 2531               	.LVL220:
 972:quantum/action.c **** }
 2532               		.loc 1 972 5 view .LVU631
 2533 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2534               	.LVL221:
 2535               		.cfi_endproc
 2536               	.LFE38:
 2538               		.section	.text.clear_keyboard,"ax",@progbits
 2539               	.global	clear_keyboard
 2541               	clear_keyboard:
 2542               	.LFB37:
 961:quantum/action.c ****     clear_mods();
 2543               		.loc 1 961 27 view -0
 2544               		.cfi_startproc
 2545               	/* prologue: function */
 2546               	/* frame size = 0 */
 2547               	/* stack size = 0 */
 2548               	.L__stack_usage = 0
 962:quantum/action.c ****     clear_keyboard_but_mods();
 2549               		.loc 1 962 5 view .LVU633
 2550 0000 0E94 0000 		call clear_mods
 2551               	.LVL222:
 963:quantum/action.c **** }
 2552               		.loc 1 963 5 view .LVU634
 2553 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2554               	.LVL223:
 2555               		.cfi_endproc
 2556               	.LFE37:
 2558               		.section	.text.is_tap_action,"ax",@progbits
 2559               	.global	is_tap_action
 2561               	is_tap_action:
 2562               	.LVL224:
 2563               	.LFB42:
 987:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 988:quantum/action.c ****     mousekey_clear();
 989:quantum/action.c ****     mousekey_send();
 990:quantum/action.c **** #endif
 991:quantum/action.c **** }
 992:quantum/action.c **** 
 993:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:quantum/action.c ****  *
 995:quantum/action.c ****  * FIXME: Needs documentation.
 996:quantum/action.c ****  */
 997:quantum/action.c **** bool is_tap_key(keypos_t key) {
 998:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 999:quantum/action.c ****     return is_tap_action(action);
1000:quantum/action.c **** }
1001:quantum/action.c **** 
1002:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1003:quantum/action.c ****  *
1004:quantum/action.c ****  * FIXME: Needs documentation.
1005:quantum/action.c ****  */
1006:quantum/action.c **** bool is_tap_record(keyrecord_t *record) {
1007:quantum/action.c **** #ifdef COMBO_ENABLE
1008:quantum/action.c ****     action_t action;
1009:quantum/action.c ****     if (record->keycode) {
1010:quantum/action.c ****         action = action_for_keycode(record->keycode);
1011:quantum/action.c ****     } else {
1012:quantum/action.c ****         action = layer_switch_get_action(record->event.key);
1013:quantum/action.c ****     }
1014:quantum/action.c **** #else
1015:quantum/action.c ****     action_t action = layer_switch_get_action(record->event.key);
1016:quantum/action.c **** #endif
1017:quantum/action.c ****     return is_tap_action(action);
1018:quantum/action.c **** }
1019:quantum/action.c **** 
1020:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1021:quantum/action.c ****  *
1022:quantum/action.c ****  * FIXME: Needs documentation.
1023:quantum/action.c ****  */
1024:quantum/action.c **** bool is_tap_action(action_t action) {
 2564               		.loc 1 1024 37 view -0
 2565               		.cfi_startproc
 2566               	/* prologue: function */
 2567               	/* frame size = 0 */
 2568               	/* stack size = 0 */
 2569               	.L__stack_usage = 0
 2570               		.loc 1 1024 37 is_stmt 0 view .LVU636
 2571 0000 282F      		mov r18,r24
 2572               	.LVL225:
1025:quantum/action.c ****     switch (action.kind.id) {
 2573               		.loc 1 1025 5 is_stmt 1 view .LVU637
 2574               		.loc 1 1025 24 is_stmt 0 view .LVU638
 2575 0002 892F      		mov r24,r25
 2576 0004 8295      		swap r24
 2577 0006 8F70      		andi r24,lo8(15)
 2578               		.loc 1 1025 5 view .LVU639
 2579 0008 903C      		cpi r25,lo8(-64)
 2580 000a 00F4      		brsh .L245
 2581 000c 8A30      		cpi r24,lo8(10)
 2582 000e 00F4      		brsh .L246
 2583 0010 8430      		cpi r24,lo8(4)
 2584 0012 00F4      		brsh .L247
 2585 0014 8230      		cpi r24,lo8(2)
 2586 0016 00F4      		brsh .L246
 2587               	.L272:
 2588 0018 80E0      		ldi r24,0
 2589 001a 0895      		ret
 2590               	.L247:
 2591 001c 8630      		cpi r24,lo8(6)
 2592 001e 01F4      		brne .L272
1026:quantum/action.c ****         case ACT_LMODS_TAP:
1027:quantum/action.c ****         case ACT_RMODS_TAP:
1028:quantum/action.c ****         case ACT_LAYER_TAP:
1029:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
1030:quantum/action.c ****             switch (action.layer_tap.code) {
1031:quantum/action.c ****                 case KC_NO ... KC_RGUI:
1032:quantum/action.c ****                 case OP_TAP_TOGGLE:
1033:quantum/action.c ****                 case OP_ONESHOT:
1034:quantum/action.c ****                     return true;
1035:quantum/action.c ****             }
1036:quantum/action.c ****             return false;
1037:quantum/action.c ****         case ACT_SWAP_HANDS:
1038:quantum/action.c ****             switch (action.swap.code) {
 2593               		.loc 1 1038 13 is_stmt 1 view .LVU640
1034:quantum/action.c ****             }
 2594               		.loc 1 1034 28 is_stmt 0 view .LVU641
 2595 0020 81E0      		ldi r24,lo8(1)
 2596 0022 283E      		cpi r18,lo8(-24)
 2597 0024 00F0      		brlo .L244
 2598 0026 213F      		cpi r18,lo8(-15)
 2599 0028 01F4      		brne .L272
 2600 002a 00C0      		rjmp .L244
 2601               	.L245:
1025:quantum/action.c ****     switch (action.kind.id) {
 2602               		.loc 1 1025 5 view .LVU642
 2603 002c 8C30      		cpi r24,lo8(12)
 2604 002e 01F0      		breq .L250
 2605 0030 8F30      		cpi r24,lo8(15)
 2606 0032 01F4      		brne .L272
 2607               	.L250:
1039:quantum/action.c ****                 case KC_NO ... KC_RGUI:
1040:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
1041:quantum/action.c ****                     return true;
1042:quantum/action.c ****             }
1043:quantum/action.c ****             return false;
1044:quantum/action.c ****         case ACT_MACRO:
1045:quantum/action.c ****         case ACT_FUNCTION:
1046:quantum/action.c ****             if (action.func.opt & FUNC_TAP) {
 2608               		.loc 1 1046 13 is_stmt 1 view .LVU643
 2609               		.loc 1 1046 16 is_stmt 0 view .LVU644
 2610 0034 93FB      		bst r25,3
 2611 0036 8827      		clr r24
 2612 0038 80F9      		bld r24,0
 2613 003a 0895      		ret
 2614               	.L246:
1030:quantum/action.c ****                 case KC_NO ... KC_RGUI:
 2615               		.loc 1 1030 13 is_stmt 1 view .LVU645
 2616 003c 81E0      		ldi r24,lo8(1)
 2617 003e 203F      		cpi r18,lo8(-16)
 2618 0040 01F0      		breq .L255
 2619 0042 00F4      		brsh .L251
 2620 0044 283E      		cpi r18,lo8(-24)
 2621 0046 00F4      		brsh .L272
 2622               	.L244:
 2623               	/* epilogue start */
1047:quantum/action.c ****                 return true;
1048:quantum/action.c ****             }
1049:quantum/action.c ****             return false;
1050:quantum/action.c ****     }
1051:quantum/action.c ****     return false;
1052:quantum/action.c **** }
 2624               		.loc 1 1052 1 is_stmt 0 view .LVU646
 2625 0048 0895      		ret
 2626               	.L251:
 2627 004a 243F      		cpi r18,lo8(-12)
 2628 004c 01F4      		brne .L272
 2629 004e 00C0      		rjmp .L244
 2630               	.L255:
 2631 0050 0895      		ret
 2632               		.cfi_endproc
 2633               	.LFE42:
 2635               		.section	.text.is_tap_key,"ax",@progbits
 2636               	.global	is_tap_key
 2638               	is_tap_key:
 2639               	.LVL226:
 2640               	.LFB40:
 997:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 2641               		.loc 1 997 31 is_stmt 1 view -0
 2642               		.cfi_startproc
 2643               	/* prologue: function */
 2644               	/* frame size = 0 */
 2645               	/* stack size = 0 */
 2646               	.L__stack_usage = 0
 998:quantum/action.c ****     return is_tap_action(action);
 2647               		.loc 1 998 5 view .LVU648
 998:quantum/action.c ****     return is_tap_action(action);
 2648               		.loc 1 998 23 is_stmt 0 view .LVU649
 2649 0000 0E94 0000 		call layer_switch_get_action
 2650               	.LVL227:
 999:quantum/action.c **** }
 2651               		.loc 1 999 5 is_stmt 1 view .LVU650
 999:quantum/action.c **** }
 2652               		.loc 1 999 12 is_stmt 0 view .LVU651
 2653 0004 0C94 0000 		jmp is_tap_action
 2654               	.LVL228:
 2655               		.cfi_endproc
 2656               	.LFE40:
 2658               		.section	.text.is_tap_record,"ax",@progbits
 2659               	.global	is_tap_record
 2661               	is_tap_record:
 2662               	.LVL229:
 2663               	.LFB41:
1006:quantum/action.c **** #ifdef COMBO_ENABLE
 2664               		.loc 1 1006 41 is_stmt 1 view -0
 2665               		.cfi_startproc
 2666               	/* prologue: function */
 2667               	/* frame size = 0 */
 2668               	/* stack size = 0 */
 2669               	.L__stack_usage = 0
1015:quantum/action.c **** #endif
 2670               		.loc 1 1015 5 view .LVU653
1015:quantum/action.c **** #endif
 2671               		.loc 1 1015 23 is_stmt 0 view .LVU654
 2672 0000 FC01      		movw r30,r24
 2673 0002 8081      		ld r24,Z
 2674 0004 9181      		ldd r25,Z+1
 2675               	.LVL230:
1015:quantum/action.c **** #endif
 2676               		.loc 1 1015 23 view .LVU655
 2677 0006 0E94 0000 		call layer_switch_get_action
 2678               	.LVL231:
1017:quantum/action.c **** }
 2679               		.loc 1 1017 5 is_stmt 1 view .LVU656
1017:quantum/action.c **** }
 2680               		.loc 1 1017 12 is_stmt 0 view .LVU657
 2681 000a 0C94 0000 		jmp is_tap_action
 2682               	.LVL232:
 2683               		.cfi_endproc
 2684               	.LFE41:
 2686               		.section	.text.debug_event,"ax",@progbits
 2687               	.global	debug_event
 2689               	debug_event:
 2690               	.LFB43:
1053:quantum/action.c **** 
1054:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1055:quantum/action.c ****  *
1056:quantum/action.c ****  * FIXME: Needs documentation.
1057:quantum/action.c ****  */
1058:quantum/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2691               		.loc 1 1058 36 is_stmt 1 view -0
 2692               		.cfi_startproc
 2693 0000 CF93      		push r28
 2694               	.LCFI36:
 2695               		.cfi_def_cfa_offset 3
 2696               		.cfi_offset 28, -2
 2697 0002 DF93      		push r29
 2698               	.LCFI37:
 2699               		.cfi_def_cfa_offset 4
 2700               		.cfi_offset 29, -3
 2701 0004 00D0      		rcall .
 2702 0006 00D0      		rcall .
 2703 0008 0F92      		push __tmp_reg__
 2704               	.LCFI38:
 2705               		.cfi_def_cfa_offset 9
 2706 000a CDB7      		in r28,__SP_L__
 2707 000c DEB7      		in r29,__SP_H__
 2708               	.LCFI39:
 2709               		.cfi_def_cfa_register 28
 2710               	/* prologue: function */
 2711               	/* frame size = 5 */
 2712               	/* stack size = 7 */
 2713               	.L__stack_usage = 7
 2714               		.loc 1 1058 138 view .LVU659
 2715               	/* epilogue start */
 2716               		.loc 1 1058 140 is_stmt 0 view .LVU660
 2717 000e 0F90      		pop __tmp_reg__
 2718 0010 0F90      		pop __tmp_reg__
 2719 0012 0F90      		pop __tmp_reg__
 2720 0014 0F90      		pop __tmp_reg__
 2721 0016 0F90      		pop __tmp_reg__
 2722 0018 DF91      		pop r29
 2723 001a CF91      		pop r28
 2724 001c 0895      		ret
 2725               		.cfi_endproc
 2726               	.LFE43:
 2728               		.section	.text.debug_record,"ax",@progbits
 2729               	.global	debug_record
 2731               	debug_record:
 2732               	.LFB44:
1059:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1060:quantum/action.c ****  *
1061:quantum/action.c ****  * FIXME: Needs documentation.
1062:quantum/action.c ****  */
1063:quantum/action.c **** void debug_record(keyrecord_t record) {
 2733               		.loc 1 1063 39 is_stmt 1 view -0
 2734               		.cfi_startproc
 2735 0000 CF93      		push r28
 2736               	.LCFI40:
 2737               		.cfi_def_cfa_offset 3
 2738               		.cfi_offset 28, -2
 2739 0002 DF93      		push r29
 2740               	.LCFI41:
 2741               		.cfi_def_cfa_offset 4
 2742               		.cfi_offset 29, -3
 2743 0004 00D0      		rcall .
 2744 0006 00D0      		rcall .
 2745 0008 00D0      		rcall .
 2746               	.LCFI42:
 2747               		.cfi_def_cfa_offset 10
 2748 000a CDB7      		in r28,__SP_L__
 2749 000c DEB7      		in r29,__SP_H__
 2750               	.LCFI43:
 2751               		.cfi_def_cfa_register 28
 2752               	/* prologue: function */
 2753               	/* frame size = 6 */
 2754               	/* stack size = 8 */
 2755               	.L__stack_usage = 8
1064:quantum/action.c ****     debug_event(record.event);
 2756               		.loc 1 1064 5 view .LVU662
1065:quantum/action.c **** #ifndef NO_ACTION_TAPPING
1066:quantum/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2757               		.loc 1 1066 77 view .LVU663
 2758               	/* epilogue start */
1067:quantum/action.c **** #endif
1068:quantum/action.c **** }
 2759               		.loc 1 1068 1 is_stmt 0 view .LVU664
 2760 000e 2696      		adiw r28,6
 2761 0010 0FB6      		in __tmp_reg__,__SREG__
 2762 0012 F894      		cli
 2763 0014 DEBF      		out __SP_H__,r29
 2764 0016 0FBE      		out __SREG__,__tmp_reg__
 2765 0018 CDBF      		out __SP_L__,r28
 2766 001a DF91      		pop r29
 2767 001c CF91      		pop r28
 2768 001e 0895      		ret
 2769               		.cfi_endproc
 2770               	.LFE44:
 2772               		.section	.text.debug_action,"ax",@progbits
 2773               	.global	debug_action
 2775               	debug_action:
 2776               	.LVL233:
 2777               	.LFB45:
1069:quantum/action.c **** 
1070:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1071:quantum/action.c ****  *
1072:quantum/action.c ****  * FIXME: Needs documentation.
1073:quantum/action.c ****  */
1074:quantum/action.c **** void debug_action(action_t action) {
 2778               		.loc 1 1074 36 is_stmt 1 view -0
 2779               		.cfi_startproc
 2780               	/* prologue: function */
 2781               	/* frame size = 0 */
 2782               	/* stack size = 0 */
 2783               	.L__stack_usage = 0
1075:quantum/action.c ****     switch (action.kind.id) {
 2784               		.loc 1 1075 5 view .LVU666
1076:quantum/action.c ****         case ACT_LMODS:
1077:quantum/action.c ****             dprint("ACT_LMODS");
1078:quantum/action.c ****             break;
1079:quantum/action.c ****         case ACT_RMODS:
1080:quantum/action.c ****             dprint("ACT_RMODS");
1081:quantum/action.c ****             break;
1082:quantum/action.c ****         case ACT_LMODS_TAP:
1083:quantum/action.c ****             dprint("ACT_LMODS_TAP");
1084:quantum/action.c ****             break;
1085:quantum/action.c ****         case ACT_RMODS_TAP:
1086:quantum/action.c ****             dprint("ACT_RMODS_TAP");
1087:quantum/action.c ****             break;
1088:quantum/action.c ****         case ACT_USAGE:
1089:quantum/action.c ****             dprint("ACT_USAGE");
1090:quantum/action.c ****             break;
1091:quantum/action.c ****         case ACT_MOUSEKEY:
1092:quantum/action.c ****             dprint("ACT_MOUSEKEY");
1093:quantum/action.c ****             break;
1094:quantum/action.c ****         case ACT_LAYER:
1095:quantum/action.c ****             dprint("ACT_LAYER");
1096:quantum/action.c ****             break;
1097:quantum/action.c ****         case ACT_LAYER_MODS:
1098:quantum/action.c ****             dprint("ACT_LAYER_MODS");
1099:quantum/action.c ****             break;
1100:quantum/action.c ****         case ACT_LAYER_TAP:
1101:quantum/action.c ****             dprint("ACT_LAYER_TAP");
1102:quantum/action.c ****             break;
1103:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
1104:quantum/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1105:quantum/action.c ****             break;
1106:quantum/action.c ****         case ACT_MACRO:
1107:quantum/action.c ****             dprint("ACT_MACRO");
1108:quantum/action.c ****             break;
1109:quantum/action.c ****         case ACT_FUNCTION:
1110:quantum/action.c ****             dprint("ACT_FUNCTION");
1111:quantum/action.c ****             break;
1112:quantum/action.c ****         case ACT_SWAP_HANDS:
1113:quantum/action.c ****             dprint("ACT_SWAP_HANDS");
1114:quantum/action.c ****             break;
1115:quantum/action.c ****         default:
1116:quantum/action.c ****             dprint("UNKNOWN");
1117:quantum/action.c ****             break;
1118:quantum/action.c ****     }
1119:quantum/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2785               		.loc 1 1119 75 view .LVU667
 2786               	/* epilogue start */
1120:quantum/action.c **** }
 2787               		.loc 1 1120 1 is_stmt 0 view .LVU668
 2788 0000 0895      		ret
 2789               		.cfi_endproc
 2790               	.LFE45:
 2792               		.section	.rodata.CSWTCH.25,"a"
 2795               	CSWTCH.25:
 2796 0000 E200      		.word	226
 2797 0002 E900      		.word	233
 2798 0004 EA00      		.word	234
 2799 0006 B500      		.word	181
 2800 0008 B600      		.word	182
 2801 000a B700      		.word	183
 2802 000c CD00      		.word	205
 2803 000e 8301      		.word	387
 2804 0010 CC00      		.word	204
 2805 0012 8A01      		.word	394
 2806 0014 9201      		.word	402
 2807 0016 9401      		.word	404
 2808 0018 2102      		.word	545
 2809 001a 2302      		.word	547
 2810 001c 2402      		.word	548
 2811 001e 2502      		.word	549
 2812 0020 2602      		.word	550
 2813 0022 2702      		.word	551
 2814 0024 2A02      		.word	554
 2815 0026 B300      		.word	179
 2816 0028 B400      		.word	180
 2817 002a 6F00      		.word	111
 2818 002c 7000      		.word	112
 2819               		.section	.bss.swap_state.0,"aw",@nobits
 2822               	swap_state.0:
 2823 0000 0000 0000 		.zero	10
 2823      0000 0000 
 2823      0000 
 2824               	.global	disable_action_cache
 2825               		.section	.bss.disable_action_cache,"aw",@nobits
 2828               	disable_action_cache:
 2829 0000 00        		.zero	1
 2830               	.global	swap_held
 2831               		.section	.bss.swap_held,"aw",@nobits
 2834               	swap_held:
 2835 0000 00        		.zero	1
 2836               	.global	swap_hands
 2837               		.section	.bss.swap_hands,"aw",@nobits
 2840               	swap_hands:
 2841 0000 00        		.zero	1
 2842               		.comm	tp_buttons,2,1
 2843               		.text
 2844               	.Letext0:
 2845               		.file 5 "/usr/avr/include/stdint.h"
 2846               		.file 6 "quantum/keycode.h"
 2847               		.file 7 "quantum/action_code.h"
 2848               		.file 8 "quantum/action.h"
 2849               		.file 9 "quantum/action_layer.h"
 2850               		.file 10 "quantum/action_util.h"
 2851               		.file 11 "quantum/led.h"
 2852               		.file 12 "tmk_core/common/host.h"
 2853               		.file 13 "quantum/action_tapping.h"
 2854               		.file 14 "/usr/avr/include/math.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/cc0HW0kI.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc0HW0kI.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc0HW0kI.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc0HW0kI.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc0HW0kI.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc0HW0kI.s:13     .text.process_hand_swap:0000000000000000 process_hand_swap
     /tmp/cc0HW0kI.s:2822   .bss.swap_state.0:0000000000000000 swap_state.0
     /tmp/cc0HW0kI.s:2840   .bss.swap_hands:0000000000000000 swap_hands
     /tmp/cc0HW0kI.s:168    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/cc0HW0kI.s:168    .text.process_record_quantum:0000000000000000 process_record_quantum.localalias
     /tmp/cc0HW0kI.s:191    .text.pre_process_record_quantum:0000000000000000 pre_process_record_quantum
     /tmp/cc0HW0kI.s:205    .text.action_exec:0000000000000000 action_exec
     /tmp/cc0HW0kI.s:392    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
     /tmp/cc0HW0kI.s:410    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/cc0HW0kI.s:2834   .bss.swap_held:0000000000000000 swap_held
     /tmp/cc0HW0kI.s:460    .text.register_code:0000000000000000 register_code
     /tmp/cc0HW0kI.s:2795   .rodata.CSWTCH.25:0000000000000000 CSWTCH.25
     /tmp/cc0HW0kI.s:605    .text.unregister_code:0000000000000000 unregister_code
     /tmp/cc0HW0kI.s:695    .text.tap_code_delay:0000000000000000 tap_code_delay
     /tmp/cc0HW0kI.s:783    .text.tap_code:0000000000000000 tap_code
     /tmp/cc0HW0kI.s:810    .text.register_mods:0000000000000000 register_mods
     /tmp/cc0HW0kI.s:839    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/cc0HW0kI.s:868    .text.process_action:0000000000000000 process_action
     /tmp/cc0HW0kI.s:2298   .text.process_record:0000000000000000 process_record
     /tmp/cc0HW0kI.s:2229   .text.process_record_handler:0000000000000000 process_record_handler
     /tmp/cc0HW0kI.s:2402   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/cc0HW0kI.s:2828   .bss.disable_action_cache:0000000000000000 disable_action_cache
     /tmp/cc0HW0kI.s:2430   .text.register_weak_mods:0000000000000000 register_weak_mods
     /tmp/cc0HW0kI.s:2459   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
     /tmp/cc0HW0kI.s:2488   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
     /tmp/cc0HW0kI.s:2521   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/cc0HW0kI.s:2541   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/cc0HW0kI.s:2561   .text.is_tap_action:0000000000000000 is_tap_action
     /tmp/cc0HW0kI.s:2638   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/cc0HW0kI.s:2661   .text.is_tap_record:0000000000000000 is_tap_record
     /tmp/cc0HW0kI.s:2689   .text.debug_event:0000000000000000 debug_event
     /tmp/cc0HW0kI.s:2731   .text.debug_record:0000000000000000 debug_record
     /tmp/cc0HW0kI.s:2775   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
hand_swap_config
clear_weak_mods
action_tapping_process
layer_switch_get_action
keyboard_report
is_key_pressed
del_key
send_keyboard_report
add_key
add_mods
host_system_send
host_consumer_send
del_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
host_keyboard_leds
led_set
use_oneshot_swaphands
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
set_oneshot_swaphands
release_oneshot_swaphands
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
