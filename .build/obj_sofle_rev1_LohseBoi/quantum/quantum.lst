   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.extract_mod_bits,"ax",@progbits
  11               	.global	extract_mod_bits
  13               	extract_mod_bits:
  14               	.LVL0:
  15               	.LFB26:
  16               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #include "magic.h"
  19:quantum/quantum.c **** 
  20:quantum/quantum.c **** #ifdef BLUETOOTH_ENABLE
  21:quantum/quantum.c **** #    include "outputselect.h"
  22:quantum/quantum.c **** #endif
  23:quantum/quantum.c **** 
  24:quantum/quantum.c **** #ifdef BACKLIGHT_ENABLE
  25:quantum/quantum.c **** #    include "backlight.h"
  26:quantum/quantum.c **** #endif
  27:quantum/quantum.c **** 
  28:quantum/quantum.c **** #ifdef API_ENABLE
  29:quantum/quantum.c **** #    include "api.h"
  30:quantum/quantum.c **** #endif
  31:quantum/quantum.c **** 
  32:quantum/quantum.c **** #ifdef MIDI_ENABLE
  33:quantum/quantum.c **** #    include "process_midi.h"
  34:quantum/quantum.c **** #endif
  35:quantum/quantum.c **** 
  36:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
  37:quantum/quantum.c **** #    include "velocikey.h"
  38:quantum/quantum.c **** #endif
  39:quantum/quantum.c **** 
  40:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
  41:quantum/quantum.c **** #    include "haptic.h"
  42:quantum/quantum.c **** #endif
  43:quantum/quantum.c **** 
  44:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  45:quantum/quantum.c **** #    ifndef GOODBYE_SONG
  46:quantum/quantum.c **** #        define GOODBYE_SONG SONG(GOODBYE_SOUND)
  47:quantum/quantum.c **** #    endif
  48:quantum/quantum.c **** float goodbye_song[][2] = GOODBYE_SONG;
  49:quantum/quantum.c **** #    ifdef DEFAULT_LAYER_SONGS
  50:quantum/quantum.c **** float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  51:quantum/quantum.c **** #    endif
  52:quantum/quantum.c **** #endif
  53:quantum/quantum.c **** 
  54:quantum/quantum.c **** #ifdef AUTO_SHIFT_ENABLE
  55:quantum/quantum.c **** #    include "process_auto_shift.h"
  56:quantum/quantum.c **** #endif
  57:quantum/quantum.c **** 
  58:quantum/quantum.c **** uint8_t extract_mod_bits(uint16_t code) {
  17               		.loc 1 58 41 view -0
  18               		.cfi_startproc
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  23               		.loc 1 58 41 is_stmt 0 view .LVU1
  24 0000 9C01      		movw r18,r24
  59:quantum/quantum.c ****     switch (code) {
  25               		.loc 1 59 5 is_stmt 1 view .LVU2
  26 0002 9A95      		dec r25
  27               	.LVL1:
  28               		.loc 1 59 5 is_stmt 0 view .LVU3
  29 0004 8115      		cp r24,__zero_reg__
  30 0006 9F41      		sbci r25,31
  31 0008 00F4      		brsh .L8
  60:quantum/quantum.c ****         case QK_MODS ... QK_MODS_MAX:
  61:quantum/quantum.c ****             break;
  32               		.loc 1 61 13 is_stmt 1 view .LVU4
  62:quantum/quantum.c ****         default:
  63:quantum/quantum.c ****             return 0;
  64:quantum/quantum.c ****     }
  65:quantum/quantum.c **** 
  66:quantum/quantum.c ****     uint8_t mods_to_send = 0;
  33               		.loc 1 66 5 view .LVU5
  34               	.LVL2:
  67:quantum/quantum.c **** 
  68:quantum/quantum.c ****     if (code & QK_RMODS_MIN) {  // Right mod flag is set
  35               		.loc 1 68 5 view .LVU6
  69:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_RCTL);
  70:quantum/quantum.c ****         if (code & QK_LSFT) mods_to_send |= MOD_BIT(KC_RSFT);
  36               		.loc 1 70 18 is_stmt 0 view .LVU7
  37 000a F901      		movw r30,r18
  38 000c EE27      		clr r30
  39 000e F270      		andi r31,2
  69:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_RCTL);
  40               		.loc 1 69 12 view .LVU8
  41 0010 832F      		mov r24,r19
  42 0012 8170      		andi r24,lo8(1)
  43 0014 B901      		movw r22,r18
  44 0016 6627      		clr r22
  45 0018 7470      		andi r23,4
  46 001a A901      		movw r20,r18
  47 001c 4427      		clr r20
  48 001e 5870      		andi r21,8
  68:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_RCTL);
  49               		.loc 1 68 8 view .LVU9
  50 0020 34FF      		sbrs r19,4
  51 0022 00C0      		rjmp .L3
  69:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_RCTL);
  52               		.loc 1 69 9 is_stmt 1 view .LVU10
  69:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_RCTL);
  53               		.loc 1 69 12 is_stmt 0 view .LVU11
  54 0024 8295      		swap r24
  55 0026 807F      		andi r24,lo8(-16)
  56               	.LVL3:
  57               		.loc 1 70 9 is_stmt 1 view .LVU12
  58               		.loc 1 70 12 is_stmt 0 view .LVU13
  59 0028 EF2B      		or r30,r31
  60 002a 01F0      		breq .L4
  61               		.loc 1 70 29 is_stmt 1 discriminator 1 view .LVU14
  62               		.loc 1 70 42 is_stmt 0 discriminator 1 view .LVU15
  63 002c 8062      		ori r24,lo8(32)
  64               	.LVL4:
  65               	.L4:
  71:quantum/quantum.c ****         if (code & QK_LALT) mods_to_send |= MOD_BIT(KC_RALT);
  66               		.loc 1 71 9 is_stmt 1 view .LVU16
  67               		.loc 1 71 12 is_stmt 0 view .LVU17
  68 002e 672B      		or r22,r23
  69 0030 01F0      		breq .L5
  70               		.loc 1 71 29 is_stmt 1 discriminator 1 view .LVU18
  71               		.loc 1 71 42 is_stmt 0 discriminator 1 view .LVU19
  72 0032 8064      		ori r24,lo8(64)
  73               	.LVL5:
  74               	.L5:
  72:quantum/quantum.c ****         if (code & QK_LGUI) mods_to_send |= MOD_BIT(KC_RGUI);
  75               		.loc 1 72 9 is_stmt 1 view .LVU20
  76               		.loc 1 72 12 is_stmt 0 view .LVU21
  77 0034 452B      		or r20,r21
  78 0036 01F0      		breq .L1
  79               		.loc 1 72 29 is_stmt 1 discriminator 1 view .LVU22
  80               		.loc 1 72 42 is_stmt 0 discriminator 1 view .LVU23
  81 0038 8068      		ori r24,lo8(-128)
  82               	.LVL6:
  83               		.loc 1 72 42 discriminator 1 view .LVU24
  84 003a 0895      		ret
  85               	.LVL7:
  86               	.L3:
  73:quantum/quantum.c ****     } else {
  74:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_LCTL);
  87               		.loc 1 74 9 is_stmt 1 view .LVU25
  75:quantum/quantum.c ****         if (code & QK_LSFT) mods_to_send |= MOD_BIT(KC_LSFT);
  88               		.loc 1 75 9 view .LVU26
  89               		.loc 1 75 12 is_stmt 0 view .LVU27
  90 003c EF2B      		or r30,r31
  91 003e 01F0      		breq .L6
  92               		.loc 1 75 29 is_stmt 1 discriminator 1 view .LVU28
  93               		.loc 1 75 42 is_stmt 0 discriminator 1 view .LVU29
  94 0040 8260      		ori r24,lo8(2)
  95               	.LVL8:
  96               	.L6:
  76:quantum/quantum.c ****         if (code & QK_LALT) mods_to_send |= MOD_BIT(KC_LALT);
  97               		.loc 1 76 9 is_stmt 1 view .LVU30
  98               		.loc 1 76 12 is_stmt 0 view .LVU31
  99 0042 672B      		or r22,r23
 100 0044 01F0      		breq .L7
 101               		.loc 1 76 29 is_stmt 1 discriminator 1 view .LVU32
 102               		.loc 1 76 42 is_stmt 0 discriminator 1 view .LVU33
 103 0046 8460      		ori r24,lo8(4)
 104               	.LVL9:
 105               	.L7:
  77:quantum/quantum.c ****         if (code & QK_LGUI) mods_to_send |= MOD_BIT(KC_LGUI);
 106               		.loc 1 77 9 is_stmt 1 view .LVU34
 107               		.loc 1 77 12 is_stmt 0 view .LVU35
 108 0048 452B      		or r20,r21
 109 004a 01F0      		breq .L1
 110               		.loc 1 77 29 is_stmt 1 discriminator 1 view .LVU36
 111               		.loc 1 77 42 is_stmt 0 discriminator 1 view .LVU37
 112 004c 8860      		ori r24,lo8(8)
 113               	.LVL10:
 114               		.loc 1 77 42 discriminator 1 view .LVU38
 115 004e 0895      		ret
 116               	.LVL11:
 117               	.L8:
  63:quantum/quantum.c ****     }
 118               		.loc 1 63 20 view .LVU39
 119 0050 80E0      		ldi r24,0
 120               	.L1:
 121               	/* epilogue start */
  78:quantum/quantum.c ****     }
  79:quantum/quantum.c **** 
  80:quantum/quantum.c ****     return mods_to_send;
  81:quantum/quantum.c **** }
 122               		.loc 1 81 1 view .LVU40
 123 0052 0895      		ret
 124               		.cfi_endproc
 125               	.LFE26:
 127               		.section	.text.do_code16,"ax",@progbits
 129               	do_code16:
 130               	.LVL12:
 131               	.LFB27:
  82:quantum/quantum.c **** 
  83:quantum/quantum.c **** static void do_code16(uint16_t code, void (*f)(uint8_t)) { f(extract_mod_bits(code)); }
 132               		.loc 1 83 58 is_stmt 1 view -0
 133               		.cfi_startproc
 134               		.loc 1 83 58 is_stmt 0 view .LVU42
 135 0000 CF93      		push r28
 136               	.LCFI0:
 137               		.cfi_def_cfa_offset 3
 138               		.cfi_offset 28, -2
 139 0002 DF93      		push r29
 140               	.LCFI1:
 141               		.cfi_def_cfa_offset 4
 142               		.cfi_offset 29, -3
 143               	/* prologue: function */
 144               	/* frame size = 0 */
 145               	/* stack size = 2 */
 146               	.L__stack_usage = 2
 147 0004 EB01      		movw r28,r22
 148               		.loc 1 83 60 is_stmt 1 view .LVU43
 149 0006 0E94 0000 		call extract_mod_bits
 150               	.LVL13:
 151               		.loc 1 83 60 is_stmt 0 view .LVU44
 152 000a FE01      		movw r30,r28
 153               	/* epilogue start */
 154               		.loc 1 83 87 view .LVU45
 155 000c DF91      		pop r29
 156 000e CF91      		pop r28
 157               	.LVL14:
 158               		.loc 1 83 60 view .LVU46
 159 0010 0994      		ijmp
 160               	.LVL15:
 161               		.loc 1 83 60 view .LVU47
 162               		.cfi_endproc
 163               	.LFE27:
 165               		.section	.text.register_code16,"ax",@progbits
 166               	.global	register_code16
 168               	register_code16:
 169               	.LVL16:
 170               	.LFB28:
  84:quantum/quantum.c **** 
  85:quantum/quantum.c **** void register_code16(uint16_t code) {
 171               		.loc 1 85 37 is_stmt 1 view -0
 172               		.cfi_startproc
 173               		.loc 1 85 37 is_stmt 0 view .LVU49
 174 0000 CF93      		push r28
 175               	.LCFI2:
 176               		.cfi_def_cfa_offset 3
 177               		.cfi_offset 28, -2
 178 0002 DF93      		push r29
 179               	.LCFI3:
 180               		.cfi_def_cfa_offset 4
 181               		.cfi_offset 29, -3
 182               	/* prologue: function */
 183               	/* frame size = 0 */
 184               	/* stack size = 2 */
 185               	.L__stack_usage = 2
 186 0004 EC01      		movw r28,r24
  86:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 187               		.loc 1 86 5 is_stmt 1 view .LVU50
 188               		.loc 1 86 9 is_stmt 0 view .LVU51
 189 0006 805E      		subi r24,-32
 190 0008 9109      		sbc r25,__zero_reg__
 191               	.LVL17:
 192               		.loc 1 86 8 view .LVU52
 193 000a 0897      		sbiw r24,8
 194 000c 00F0      		brlo .L29
  87:quantum/quantum.c ****         do_code16(code, register_mods);
  88:quantum/quantum.c ****     } else {
  89:quantum/quantum.c ****         do_code16(code, register_weak_mods);
 195               		.loc 1 89 9 discriminator 1 view .LVU53
 196 000e 60E0      		ldi r22,lo8(gs(register_weak_mods))
 197 0010 70E0      		ldi r23,hi8(gs(register_weak_mods))
  86:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 198               		.loc 1 86 22 discriminator 1 view .LVU54
 199 0012 2097      		sbiw r28,0
 200 0014 01F4      		brne .L32
 201               	.L29:
  87:quantum/quantum.c ****         do_code16(code, register_mods);
 202               		.loc 1 87 9 is_stmt 1 view .LVU55
 203 0016 60E0      		ldi r22,lo8(gs(register_mods))
 204 0018 70E0      		ldi r23,hi8(gs(register_mods))
 205               	.L32:
 206               		.loc 1 89 9 is_stmt 0 view .LVU56
 207 001a CE01      		movw r24,r28
 208 001c 0E94 0000 		call do_code16
 209               	.LVL18:
  90:quantum/quantum.c ****     }
  91:quantum/quantum.c ****     register_code(code);
 210               		.loc 1 91 5 is_stmt 1 view .LVU57
 211 0020 8C2F      		mov r24,r28
 212               	/* epilogue start */
  92:quantum/quantum.c **** }
 213               		.loc 1 92 1 is_stmt 0 view .LVU58
 214 0022 DF91      		pop r29
 215 0024 CF91      		pop r28
 216               	.LVL19:
  91:quantum/quantum.c **** }
 217               		.loc 1 91 5 view .LVU59
 218 0026 0C94 0000 		jmp register_code
 219               	.LVL20:
 220               		.cfi_endproc
 221               	.LFE28:
 223               		.section	.text.unregister_code16,"ax",@progbits
 224               	.global	unregister_code16
 226               	unregister_code16:
 227               	.LVL21:
 228               	.LFB29:
  93:quantum/quantum.c **** 
  94:quantum/quantum.c **** void unregister_code16(uint16_t code) {
 229               		.loc 1 94 39 is_stmt 1 view -0
 230               		.cfi_startproc
 231               		.loc 1 94 39 is_stmt 0 view .LVU61
 232 0000 CF93      		push r28
 233               	.LCFI4:
 234               		.cfi_def_cfa_offset 3
 235               		.cfi_offset 28, -2
 236 0002 DF93      		push r29
 237               	.LCFI5:
 238               		.cfi_def_cfa_offset 4
 239               		.cfi_offset 29, -3
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 242               	/* stack size = 2 */
 243               	.L__stack_usage = 2
 244 0004 EC01      		movw r28,r24
  95:quantum/quantum.c ****     unregister_code(code);
 245               		.loc 1 95 5 is_stmt 1 view .LVU62
 246 0006 0E94 0000 		call unregister_code
 247               	.LVL22:
  96:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 248               		.loc 1 96 5 view .LVU63
 249               		.loc 1 96 9 is_stmt 0 view .LVU64
 250 000a CE01      		movw r24,r28
 251 000c 805E      		subi r24,-32
 252 000e 9109      		sbc r25,__zero_reg__
 253               		.loc 1 96 8 view .LVU65
 254 0010 0897      		sbiw r24,8
 255 0012 00F0      		brlo .L34
  97:quantum/quantum.c ****         do_code16(code, unregister_mods);
  98:quantum/quantum.c ****     } else {
  99:quantum/quantum.c ****         do_code16(code, unregister_weak_mods);
 256               		.loc 1 99 9 discriminator 1 view .LVU66
 257 0014 60E0      		ldi r22,lo8(gs(unregister_weak_mods))
 258 0016 70E0      		ldi r23,hi8(gs(unregister_weak_mods))
  96:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 259               		.loc 1 96 22 discriminator 1 view .LVU67
 260 0018 2097      		sbiw r28,0
 261 001a 01F4      		brne .L36
 262               	.L34:
  97:quantum/quantum.c ****         do_code16(code, unregister_mods);
 263               		.loc 1 97 9 is_stmt 1 view .LVU68
 264 001c 60E0      		ldi r22,lo8(gs(unregister_mods))
 265 001e 70E0      		ldi r23,hi8(gs(unregister_mods))
 266               	.L36:
 267               		.loc 1 99 9 is_stmt 0 view .LVU69
 268 0020 CE01      		movw r24,r28
 269               	/* epilogue start */
 100:quantum/quantum.c ****     }
 101:quantum/quantum.c **** }
 270               		.loc 1 101 1 view .LVU70
 271 0022 DF91      		pop r29
 272 0024 CF91      		pop r28
 273               	.LVL23:
  99:quantum/quantum.c ****     }
 274               		.loc 1 99 9 view .LVU71
 275 0026 0C94 0000 		jmp do_code16
 276               	.LVL24:
  99:quantum/quantum.c ****     }
 277               		.loc 1 99 9 view .LVU72
 278               		.cfi_endproc
 279               	.LFE29:
 281               		.section	.text.tap_code16,"ax",@progbits
 282               	.global	tap_code16
 284               	tap_code16:
 285               	.LVL25:
 286               	.LFB30:
 102:quantum/quantum.c **** 
 103:quantum/quantum.c **** void tap_code16(uint16_t code) {
 287               		.loc 1 103 32 is_stmt 1 view -0
 288               		.cfi_startproc
 289               		.loc 1 103 32 is_stmt 0 view .LVU74
 290 0000 CF93      		push r28
 291               	.LCFI6:
 292               		.cfi_def_cfa_offset 3
 293               		.cfi_offset 28, -2
 294 0002 DF93      		push r29
 295               	.LCFI7:
 296               		.cfi_def_cfa_offset 4
 297               		.cfi_offset 29, -3
 298               	/* prologue: function */
 299               	/* frame size = 0 */
 300               	/* stack size = 2 */
 301               	.L__stack_usage = 2
 302 0004 D82F      		mov r29,r24
 303 0006 C92F      		mov r28,r25
 104:quantum/quantum.c ****     register_code16(code);
 304               		.loc 1 104 5 is_stmt 1 view .LVU75
 305 0008 0E94 0000 		call register_code16
 306               	.LVL26:
 105:quantum/quantum.c **** #if TAP_CODE_DELAY > 0
 106:quantum/quantum.c ****     wait_ms(TAP_CODE_DELAY);
 307               		.loc 1 106 5 view .LVU76
 308               		.loc 1 106 5 view .LVU77
 309               		.loc 1 106 5 view .LVU78
 310               	.LBB6:
 311               	.LBI6:
 312               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 313               		.loc 2 166 1 view .LVU79
 314               	.LBB7:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 315               		.loc 2 168 2 view .LVU80
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 316               		.loc 2 172 2 view .LVU81
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 317               		.loc 2 173 2 view .LVU82
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 318               		.loc 2 174 2 view .LVU83
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 319               		.loc 2 184 3 view .LVU84
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 320               		.loc 2 187 2 view .LVU85
 321 000c 8FE3      		ldi r24,lo8(-25537)
 322 000e 9CE9      		ldi r25,hi8(-25537)
 323 0010 0197      	1:	sbiw r24,1
 324 0012 01F4      		brne 1b
 325 0014 00C0      		rjmp .
 326 0016 0000      		nop
 327               	.LVL27:
 328               		.loc 2 187 2 is_stmt 0 view .LVU86
 329               	.LBE7:
 330               	.LBE6:
 331               		.loc 1 106 5 is_stmt 1 view .LVU87
 107:quantum/quantum.c **** #endif
 108:quantum/quantum.c ****     unregister_code16(code);
 332               		.loc 1 108 5 view .LVU88
 333 0018 8D2F      		mov r24,r29
 334 001a 9C2F      		mov r25,r28
 335               	/* epilogue start */
 109:quantum/quantum.c **** }
 336               		.loc 1 109 1 is_stmt 0 view .LVU89
 337 001c DF91      		pop r29
 338 001e CF91      		pop r28
 108:quantum/quantum.c **** }
 339               		.loc 1 108 5 view .LVU90
 340 0020 0C94 0000 		jmp unregister_code16
 341               	.LVL28:
 342               		.cfi_endproc
 343               	.LFE30:
 345               		.section	.text.process_action_kb,"ax",@progbits
 346               		.weak	process_action_kb
 348               	process_action_kb:
 349               	.LVL29:
 350               	.LFB31:
 110:quantum/quantum.c **** 
 111:quantum/quantum.c **** __attribute__((weak)) bool process_action_kb(keyrecord_t *record) { return true; }
 351               		.loc 1 111 67 is_stmt 1 view -0
 352               		.cfi_startproc
 353               	/* prologue: function */
 354               	/* frame size = 0 */
 355               	/* stack size = 0 */
 356               	.L__stack_usage = 0
 357               		.loc 1 111 69 view .LVU92
 358               		.loc 1 111 82 is_stmt 0 view .LVU93
 359 0000 81E0      		ldi r24,lo8(1)
 360               	.LVL30:
 361               	/* epilogue start */
 362               		.loc 1 111 82 view .LVU94
 363 0002 0895      		ret
 364               		.cfi_endproc
 365               	.LFE31:
 367               		.section	.text.process_record_user,"ax",@progbits
 368               		.weak	process_record_user
 370               	process_record_user:
 371               	.LVL31:
 372               	.LFB33:
 112:quantum/quantum.c **** 
 113:quantum/quantum.c **** __attribute__((weak)) bool process_record_kb(uint16_t keycode, keyrecord_t *record) { return proces
 114:quantum/quantum.c **** 
 115:quantum/quantum.c **** __attribute__((weak)) bool process_record_user(uint16_t keycode, keyrecord_t *record) { return true
 373               		.loc 1 115 87 is_stmt 1 view -0
 374               		.cfi_startproc
 375               	/* prologue: function */
 376               	/* frame size = 0 */
 377               	/* stack size = 0 */
 378               	.L__stack_usage = 0
 379               		.loc 1 115 89 view .LVU96
 380               		.loc 1 115 102 is_stmt 0 view .LVU97
 381 0000 81E0      		ldi r24,lo8(1)
 382               	.LVL32:
 383               	/* epilogue start */
 384               		.loc 1 115 102 view .LVU98
 385 0002 0895      		ret
 386               		.cfi_endproc
 387               	.LFE33:
 389               		.section	.text.process_record_kb,"ax",@progbits
 390               		.weak	process_record_kb
 392               	process_record_kb:
 393               	.LVL33:
 394               	.LFB32:
 113:quantum/quantum.c **** 
 395               		.loc 1 113 85 is_stmt 1 view -0
 396               		.cfi_startproc
 397               	/* prologue: function */
 398               	/* frame size = 0 */
 399               	/* stack size = 0 */
 400               	.L__stack_usage = 0
 113:quantum/quantum.c **** 
 401               		.loc 1 113 87 view .LVU100
 113:quantum/quantum.c **** 
 402               		.loc 1 113 94 is_stmt 0 view .LVU101
 403 0000 0C94 0000 		jmp process_record_user
 404               	.LVL34:
 113:quantum/quantum.c **** 
 405               		.loc 1 113 94 view .LVU102
 406               		.cfi_endproc
 407               	.LFE32:
 409               		.section	.text.post_process_record_user,"ax",@progbits
 410               		.weak	post_process_record_user
 412               	post_process_record_user:
 413               	.LVL35:
 414               	.LFB35:
 116:quantum/quantum.c **** 
 117:quantum/quantum.c **** __attribute__((weak)) void post_process_record_kb(uint16_t keycode, keyrecord_t *record) { post_pro
 118:quantum/quantum.c **** 
 119:quantum/quantum.c **** __attribute__((weak)) void post_process_record_user(uint16_t keycode, keyrecord_t *record) {}
 415               		.loc 1 119 92 is_stmt 1 view -0
 416               		.cfi_startproc
 417               	/* prologue: function */
 418               	/* frame size = 0 */
 419               	/* stack size = 0 */
 420               	.L__stack_usage = 0
 421               		.loc 1 119 93 view .LVU104
 422               	/* epilogue start */
 423 0000 0895      		ret
 424               		.cfi_endproc
 425               	.LFE35:
 427               		.section	.text.post_process_record_kb,"ax",@progbits
 428               		.weak	post_process_record_kb
 430               	post_process_record_kb:
 431               	.LVL36:
 432               	.LFB34:
 117:quantum/quantum.c **** 
 433               		.loc 1 117 90 view -0
 434               		.cfi_startproc
 435               	/* prologue: function */
 436               	/* frame size = 0 */
 437               	/* stack size = 0 */
 438               	.L__stack_usage = 0
 117:quantum/quantum.c **** 
 439               		.loc 1 117 92 view .LVU106
 440 0000 0C94 0000 		jmp post_process_record_user
 441               	.LVL37:
 117:quantum/quantum.c **** 
 442               		.loc 1 117 92 is_stmt 0 view .LVU107
 443               		.cfi_endproc
 444               	.LFE34:
 446               		.section	.text.get_event_keycode,"ax",@progbits
 447               	.global	get_event_keycode
 449               	get_event_keycode:
 450               	.LVL38:
 451               	.LFB38:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void reset_keyboard(void) {
 122:quantum/quantum.c ****     clear_keyboard();
 123:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 124:quantum/quantum.c ****     process_midi_all_notes_off();
 125:quantum/quantum.c **** #endif
 126:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 127:quantum/quantum.c **** #    ifndef NO_MUSIC_MODE
 128:quantum/quantum.c ****     music_all_notes_off();
 129:quantum/quantum.c **** #    endif
 130:quantum/quantum.c ****     uint16_t timer_start = timer_read();
 131:quantum/quantum.c ****     PLAY_SONG(goodbye_song);
 132:quantum/quantum.c ****     shutdown_user();
 133:quantum/quantum.c ****     while (timer_elapsed(timer_start) < 250) wait_ms(1);
 134:quantum/quantum.c ****     stop_all_notes();
 135:quantum/quantum.c **** #else
 136:quantum/quantum.c ****     shutdown_user();
 137:quantum/quantum.c ****     wait_ms(250);
 138:quantum/quantum.c **** #endif
 139:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 140:quantum/quantum.c ****     haptic_shutdown();
 141:quantum/quantum.c **** #endif
 142:quantum/quantum.c ****     bootloader_jump();
 143:quantum/quantum.c **** }
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** /* Convert record into usable keycode via the contained event. */
 146:quantum/quantum.c **** uint16_t get_record_keycode(keyrecord_t *record, bool update_layer_cache) {
 147:quantum/quantum.c **** #ifdef COMBO_ENABLE
 148:quantum/quantum.c ****     if (record->keycode) { return record->keycode; }
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c ****     return get_event_keycode(record->event, update_layer_cache);
 151:quantum/quantum.c **** }
 152:quantum/quantum.c **** 
 153:quantum/quantum.c **** 
 154:quantum/quantum.c **** /* Convert event into usable keycode. Checks the layer cache to ensure that it
 155:quantum/quantum.c ****  * retains the correct keycode after a layer change, if the key is still pressed.
 156:quantum/quantum.c ****  * "update_layer_cache" is to ensure that it only updates the layer cache when
 157:quantum/quantum.c ****  * appropriate, otherwise, it will update it and cause layer tap (and other keys)
 158:quantum/quantum.c ****  * from triggering properly.
 159:quantum/quantum.c ****  */
 160:quantum/quantum.c **** uint16_t get_event_keycode(keyevent_t event, bool update_layer_cache) {
 452               		.loc 1 160 71 is_stmt 1 view -0
 453               		.cfi_startproc
 454               		.loc 1 160 71 is_stmt 0 view .LVU109
 455 0000 1F93      		push r17
 456               	.LCFI8:
 457               		.cfi_def_cfa_offset 3
 458               		.cfi_offset 17, -2
 459 0002 CF93      		push r28
 460               	.LCFI9:
 461               		.cfi_def_cfa_offset 4
 462               		.cfi_offset 28, -3
 463 0004 DF93      		push r29
 464               	.LCFI10:
 465               		.cfi_def_cfa_offset 5
 466               		.cfi_offset 29, -4
 467 0006 00D0      		rcall .
 468 0008 00D0      		rcall .
 469 000a 0F92      		push __tmp_reg__
 470               	.LCFI11:
 471               		.cfi_def_cfa_offset 10
 472 000c CDB7      		in r28,__SP_L__
 473 000e DEB7      		in r29,__SP_H__
 474               	.LCFI12:
 475               		.cfi_def_cfa_register 28
 476               	/* prologue: function */
 477               	/* frame size = 5 */
 478               	/* stack size = 8 */
 479               	.L__stack_usage = 8
 480 0010 4983      		std Y+1,r20
 481 0012 5A83      		std Y+2,r21
 482 0014 6B83      		std Y+3,r22
 161:quantum/quantum.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 162:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 163:quantum/quantum.c ****     if (!disable_action_cache) {
 483               		.loc 1 163 5 is_stmt 1 view .LVU110
 484               		.loc 1 163 8 is_stmt 0 view .LVU111
 485 0016 3091 0000 		lds r19,disable_action_cache
 486 001a 8981      		ldd r24,Y+1
 487 001c 9A81      		ldd r25,Y+2
 488 001e 3111      		cpse r19,__zero_reg__
 489 0020 00C0      		rjmp .L44
 490               	.LBB8:
 164:quantum/quantum.c ****         uint8_t layer;
 491               		.loc 1 164 9 is_stmt 1 view .LVU112
 165:quantum/quantum.c **** 
 166:quantum/quantum.c ****         if (event.pressed && update_layer_cache) {
 492               		.loc 1 166 9 view .LVU113
 493               		.loc 1 166 12 is_stmt 0 view .LVU114
 494 0022 6623      		tst r22
 495 0024 01F0      		breq .L45
 496               		.loc 1 166 27 discriminator 1 view .LVU115
 497 0026 2223      		tst r18
 498 0028 01F0      		breq .L45
 167:quantum/quantum.c ****             layer = layer_switch_get_layer(event.key);
 499               		.loc 1 167 13 is_stmt 1 view .LVU116
 500               		.loc 1 167 21 is_stmt 0 view .LVU117
 501 002a 0E94 0000 		call layer_switch_get_layer
 502               	.LVL39:
 503               		.loc 1 167 21 view .LVU118
 504 002e 182F      		mov r17,r24
 505               	.LVL40:
 168:quantum/quantum.c ****             update_source_layers_cache(event.key, layer);
 506               		.loc 1 168 13 is_stmt 1 view .LVU119
 507 0030 682F      		mov r22,r24
 508 0032 8981      		ldd r24,Y+1
 509 0034 9A81      		ldd r25,Y+2
 510 0036 0E94 0000 		call update_source_layers_cache
 511               	.LVL41:
 512               	.L46:
 169:quantum/quantum.c ****         } else {
 170:quantum/quantum.c ****             layer = read_source_layers_cache(event.key);
 171:quantum/quantum.c ****         }
 172:quantum/quantum.c ****         return keymap_key_to_keycode(layer, event.key);
 513               		.loc 1 172 9 view .LVU120
 514               		.loc 1 172 16 is_stmt 0 view .LVU121
 515 003a 6981      		ldd r22,Y+1
 516 003c 7A81      		ldd r23,Y+2
 517 003e 812F      		mov r24,r17
 518               	.LVL42:
 519               	.L53:
 520               	/* epilogue start */
 521               		.loc 1 172 16 view .LVU122
 522               	.LBE8:
 173:quantum/quantum.c ****     } else
 174:quantum/quantum.c **** #endif
 175:quantum/quantum.c ****         return keymap_key_to_keycode(layer_switch_get_layer(event.key), event.key);
 176:quantum/quantum.c **** }
 523               		.loc 1 176 1 view .LVU123
 524 0040 0F90      		pop __tmp_reg__
 525 0042 0F90      		pop __tmp_reg__
 526 0044 0F90      		pop __tmp_reg__
 527 0046 0F90      		pop __tmp_reg__
 528 0048 0F90      		pop __tmp_reg__
 529 004a DF91      		pop r29
 530 004c CF91      		pop r28
 531 004e 1F91      		pop r17
 175:quantum/quantum.c **** }
 532               		.loc 1 175 16 view .LVU124
 533 0050 0C94 0000 		jmp keymap_key_to_keycode
 534               	.LVL43:
 535               	.L45:
 536               	.LBB9:
 170:quantum/quantum.c ****         }
 537               		.loc 1 170 13 is_stmt 1 view .LVU125
 170:quantum/quantum.c ****         }
 538               		.loc 1 170 21 is_stmt 0 view .LVU126
 539 0054 0E94 0000 		call read_source_layers_cache
 540               	.LVL44:
 170:quantum/quantum.c ****         }
 541               		.loc 1 170 21 view .LVU127
 542 0058 182F      		mov r17,r24
 543               	.LVL45:
 170:quantum/quantum.c ****         }
 544               		.loc 1 170 21 view .LVU128
 545 005a 00C0      		rjmp .L46
 546               	.LVL46:
 547               	.L44:
 170:quantum/quantum.c ****         }
 548               		.loc 1 170 21 view .LVU129
 549               	.LBE9:
 175:quantum/quantum.c **** }
 550               		.loc 1 175 9 is_stmt 1 view .LVU130
 175:quantum/quantum.c **** }
 551               		.loc 1 175 16 is_stmt 0 view .LVU131
 552 005c 0E94 0000 		call layer_switch_get_layer
 553               	.LVL47:
 175:quantum/quantum.c **** }
 554               		.loc 1 175 16 view .LVU132
 555 0060 6981      		ldd r22,Y+1
 556 0062 7A81      		ldd r23,Y+2
 557 0064 00C0      		rjmp .L53
 558               		.cfi_endproc
 559               	.LFE38:
 561               		.section	.text.get_record_keycode,"ax",@progbits
 562               	.global	get_record_keycode
 564               	get_record_keycode:
 565               	.LVL48:
 566               	.LFB37:
 146:quantum/quantum.c **** #ifdef COMBO_ENABLE
 567               		.loc 1 146 75 is_stmt 1 view -0
 568               		.cfi_startproc
 569               	/* prologue: function */
 570               	/* frame size = 0 */
 571               	/* stack size = 0 */
 572               	.L__stack_usage = 0
 146:quantum/quantum.c **** #ifdef COMBO_ENABLE
 573               		.loc 1 146 75 is_stmt 0 view .LVU134
 574 0000 FC01      		movw r30,r24
 575 0002 262F      		mov r18,r22
 150:quantum/quantum.c **** }
 576               		.loc 1 150 5 is_stmt 1 view .LVU135
 150:quantum/quantum.c **** }
 577               		.loc 1 150 12 is_stmt 0 view .LVU136
 578 0004 4081      		ld r20,Z
 579 0006 5181      		ldd r21,Z+1
 580 0008 6281      		ldd r22,Z+2
 581               	.LVL49:
 150:quantum/quantum.c **** }
 582               		.loc 1 150 12 view .LVU137
 583 000a 7381      		ldd r23,Z+3
 584 000c 8481      		ldd r24,Z+4
 585               	.LVL50:
 150:quantum/quantum.c **** }
 586               		.loc 1 150 12 view .LVU138
 587 000e 0C94 0000 		jmp get_event_keycode
 588               	.LVL51:
 150:quantum/quantum.c **** }
 589               		.loc 1 150 12 view .LVU139
 590               		.cfi_endproc
 591               	.LFE37:
 593               		.section	.text.pre_process_record_quantum,"ax",@progbits
 594               	.global	pre_process_record_quantum
 596               	pre_process_record_quantum:
 597               	.LVL52:
 598               	.LFB39:
 177:quantum/quantum.c **** 
 178:quantum/quantum.c **** /* Get keycode, and then process pre tapping functionality */
 179:quantum/quantum.c **** bool pre_process_record_quantum(keyrecord_t *record) {
 599               		.loc 1 179 54 is_stmt 1 view -0
 600               		.cfi_startproc
 601               	/* prologue: function */
 602               	/* frame size = 0 */
 603               	/* stack size = 0 */
 604               	.L__stack_usage = 0
 180:quantum/quantum.c ****     if (!(
 605               		.loc 1 180 5 view .LVU141
 181:quantum/quantum.c **** #ifdef COMBO_ENABLE
 182:quantum/quantum.c ****         process_combo(get_record_keycode(record, true), record) &&
 183:quantum/quantum.c **** #endif
 184:quantum/quantum.c ****         true)) {
 185:quantum/quantum.c ****         return false;
 186:quantum/quantum.c ****     }
 187:quantum/quantum.c ****     return true; // continue processing
 606               		.loc 1 187 5 view .LVU142
 188:quantum/quantum.c **** }
 607               		.loc 1 188 1 is_stmt 0 view .LVU143
 608 0000 81E0      		ldi r24,lo8(1)
 609               	.LVL53:
 610               	/* epilogue start */
 611               		.loc 1 188 1 view .LVU144
 612 0002 0895      		ret
 613               		.cfi_endproc
 614               	.LFE39:
 616               		.section	.text.post_process_record_quantum,"ax",@progbits
 617               	.global	post_process_record_quantum
 619               	post_process_record_quantum:
 620               	.LVL54:
 621               	.LFB40:
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** /* Get keycode, and then call keyboard function */
 191:quantum/quantum.c **** void post_process_record_quantum(keyrecord_t *record) {
 622               		.loc 1 191 55 is_stmt 1 view -0
 623               		.cfi_startproc
 624               		.loc 1 191 55 is_stmt 0 view .LVU146
 625 0000 CF93      		push r28
 626               	.LCFI13:
 627               		.cfi_def_cfa_offset 3
 628               		.cfi_offset 28, -2
 629 0002 DF93      		push r29
 630               	.LCFI14:
 631               		.cfi_def_cfa_offset 4
 632               		.cfi_offset 29, -3
 633               	/* prologue: function */
 634               	/* frame size = 0 */
 635               	/* stack size = 2 */
 636               	.L__stack_usage = 2
 637 0004 D82F      		mov r29,r24
 638 0006 C92F      		mov r28,r25
 192:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record, false);
 639               		.loc 1 192 5 is_stmt 1 view .LVU147
 640               		.loc 1 192 24 is_stmt 0 view .LVU148
 641 0008 60E0      		ldi r22,0
 642 000a 0E94 0000 		call get_record_keycode
 643               	.LVL55:
 193:quantum/quantum.c ****     post_process_record_kb(keycode, record);
 644               		.loc 1 193 5 is_stmt 1 view .LVU149
 645 000e 6D2F      		mov r22,r29
 646 0010 7C2F      		mov r23,r28
 647               	/* epilogue start */
 194:quantum/quantum.c **** }
 648               		.loc 1 194 1 is_stmt 0 view .LVU150
 649 0012 DF91      		pop r29
 650 0014 CF91      		pop r28
 193:quantum/quantum.c ****     post_process_record_kb(keycode, record);
 651               		.loc 1 193 5 view .LVU151
 652 0016 0C94 0000 		jmp post_process_record_kb
 653               	.LVL56:
 193:quantum/quantum.c ****     post_process_record_kb(keycode, record);
 654               		.loc 1 193 5 view .LVU152
 655               		.cfi_endproc
 656               	.LFE40:
 658               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 659               	.global	set_single_persistent_default_layer
 661               	set_single_persistent_default_layer:
 662               	.LVL57:
 663               	.LFB42:
 195:quantum/quantum.c **** 
 196:quantum/quantum.c **** /* Core keycode function, hands off handling to other functions,
 197:quantum/quantum.c ****     then processes internal quantum keycodes, and then processes
 198:quantum/quantum.c ****     ACTIONs.                                                      */
 199:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 200:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record, true);
 201:quantum/quantum.c **** 
 202:quantum/quantum.c ****     // This is how you use actions here
 203:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 204:quantum/quantum.c ****     //   action_t action;
 205:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 206:quantum/quantum.c ****     //   process_action(record, action);
 207:quantum/quantum.c ****     //   return false;
 208:quantum/quantum.c ****     // }
 209:quantum/quantum.c **** 
 210:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 211:quantum/quantum.c ****     if (velocikey_enabled() && record->event.pressed) {
 212:quantum/quantum.c ****         velocikey_accelerate();
 213:quantum/quantum.c ****     }
 214:quantum/quantum.c **** #endif
 215:quantum/quantum.c **** 
 216:quantum/quantum.c **** #ifdef WPM_ENABLE
 217:quantum/quantum.c ****     if (record->event.pressed) {
 218:quantum/quantum.c ****         update_wpm(keycode);
 219:quantum/quantum.c ****     }
 220:quantum/quantum.c **** #endif
 221:quantum/quantum.c **** 
 222:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 223:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 224:quantum/quantum.c **** #endif
 225:quantum/quantum.c **** 
 226:quantum/quantum.c ****     if (!(
 227:quantum/quantum.c **** #if defined(KEY_LOCK_ENABLE)
 228:quantum/quantum.c ****             // Must run first to be able to mask key_up events.
 229:quantum/quantum.c ****             process_key_lock(&keycode, record) &&
 230:quantum/quantum.c **** #endif
 231:quantum/quantum.c **** #if defined(DYNAMIC_MACRO_ENABLE) && !defined(DYNAMIC_MACRO_USER_CALL)
 232:quantum/quantum.c ****             // Must run asap to ensure all keypresses are recorded.
 233:quantum/quantum.c ****             process_dynamic_macro(keycode, record) &&
 234:quantum/quantum.c **** #endif
 235:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 236:quantum/quantum.c ****             process_clicky(keycode, record) &&
 237:quantum/quantum.c **** #endif
 238:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 239:quantum/quantum.c ****             process_haptic(keycode, record) &&
 240:quantum/quantum.c **** #endif
 241:quantum/quantum.c **** #if defined(VIA_ENABLE)
 242:quantum/quantum.c ****             process_record_via(keycode, record) &&
 243:quantum/quantum.c **** #endif
 244:quantum/quantum.c ****             process_record_kb(keycode, record) &&
 245:quantum/quantum.c **** #if defined(SEQUENCER_ENABLE)
 246:quantum/quantum.c ****             process_sequencer(keycode, record) &&
 247:quantum/quantum.c **** #endif
 248:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 249:quantum/quantum.c ****             process_midi(keycode, record) &&
 250:quantum/quantum.c **** #endif
 251:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 252:quantum/quantum.c ****             process_audio(keycode, record) &&
 253:quantum/quantum.c **** #endif
 254:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) || defined(LED_MATRIX_ENABLE)
 255:quantum/quantum.c ****             process_backlight(keycode, record) &&
 256:quantum/quantum.c **** #endif
 257:quantum/quantum.c **** #ifdef STENO_ENABLE
 258:quantum/quantum.c ****             process_steno(keycode, record) &&
 259:quantum/quantum.c **** #endif
 260:quantum/quantum.c **** #if (defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSIC_M
 261:quantum/quantum.c ****             process_music(keycode, record) &&
 262:quantum/quantum.c **** #endif
 263:quantum/quantum.c **** #ifdef KEY_OVERRIDE_ENABLE
 264:quantum/quantum.c ****             process_key_override(keycode, record) &&
 265:quantum/quantum.c **** #endif
 266:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 267:quantum/quantum.c ****             process_tap_dance(keycode, record) &&
 268:quantum/quantum.c **** #endif
 269:quantum/quantum.c **** #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 270:quantum/quantum.c ****             process_unicode_common(keycode, record) &&
 271:quantum/quantum.c **** #endif
 272:quantum/quantum.c **** #ifdef LEADER_ENABLE
 273:quantum/quantum.c ****             process_leader(keycode, record) &&
 274:quantum/quantum.c **** #endif
 275:quantum/quantum.c **** #ifdef PRINTING_ENABLE
 276:quantum/quantum.c ****             process_printer(keycode, record) &&
 277:quantum/quantum.c **** #endif
 278:quantum/quantum.c **** #ifdef AUTO_SHIFT_ENABLE
 279:quantum/quantum.c ****             process_auto_shift(keycode, record) &&
 280:quantum/quantum.c **** #endif
 281:quantum/quantum.c **** #ifdef TERMINAL_ENABLE
 282:quantum/quantum.c ****             process_terminal(keycode, record) &&
 283:quantum/quantum.c **** #endif
 284:quantum/quantum.c **** #ifdef SPACE_CADET_ENABLE
 285:quantum/quantum.c ****             process_space_cadet(keycode, record) &&
 286:quantum/quantum.c **** #endif
 287:quantum/quantum.c **** #ifdef MAGIC_KEYCODE_ENABLE
 288:quantum/quantum.c ****             process_magic(keycode, record) &&
 289:quantum/quantum.c **** #endif
 290:quantum/quantum.c **** #ifdef GRAVE_ESC_ENABLE
 291:quantum/quantum.c ****             process_grave_esc(keycode, record) &&
 292:quantum/quantum.c **** #endif
 293:quantum/quantum.c **** #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 294:quantum/quantum.c ****             process_rgb(keycode, record) &&
 295:quantum/quantum.c **** #endif
 296:quantum/quantum.c **** #ifdef JOYSTICK_ENABLE
 297:quantum/quantum.c ****             process_joystick(keycode, record) &&
 298:quantum/quantum.c **** #endif
 299:quantum/quantum.c ****             true)) {
 300:quantum/quantum.c ****         return false;
 301:quantum/quantum.c ****     }
 302:quantum/quantum.c **** 
 303:quantum/quantum.c ****     if (record->event.pressed) {
 304:quantum/quantum.c ****         switch (keycode) {
 305:quantum/quantum.c **** #ifndef NO_RESET
 306:quantum/quantum.c ****             case RESET:
 307:quantum/quantum.c ****                 reset_keyboard();
 308:quantum/quantum.c ****                 return false;
 309:quantum/quantum.c **** #endif
 310:quantum/quantum.c **** #ifndef NO_DEBUG
 311:quantum/quantum.c ****             case DEBUG:
 312:quantum/quantum.c ****                 debug_enable ^= 1;
 313:quantum/quantum.c ****                 if (debug_enable) {
 314:quantum/quantum.c ****                     print("DEBUG: enabled.\n");
 315:quantum/quantum.c ****                 } else {
 316:quantum/quantum.c ****                     print("DEBUG: disabled.\n");
 317:quantum/quantum.c ****                 }
 318:quantum/quantum.c **** #endif
 319:quantum/quantum.c ****                 return false;
 320:quantum/quantum.c ****             case EEPROM_RESET:
 321:quantum/quantum.c ****                 eeconfig_init();
 322:quantum/quantum.c ****                 return false;
 323:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 324:quantum/quantum.c ****             case VLK_TOG:
 325:quantum/quantum.c ****                 velocikey_toggle();
 326:quantum/quantum.c ****                 return false;
 327:quantum/quantum.c **** #endif
 328:quantum/quantum.c **** #ifdef BLUETOOTH_ENABLE
 329:quantum/quantum.c ****             case OUT_AUTO:
 330:quantum/quantum.c ****                 set_output(OUTPUT_AUTO);
 331:quantum/quantum.c ****                 return false;
 332:quantum/quantum.c ****             case OUT_USB:
 333:quantum/quantum.c ****                 set_output(OUTPUT_USB);
 334:quantum/quantum.c ****                 return false;
 335:quantum/quantum.c ****             case OUT_BT:
 336:quantum/quantum.c ****                 set_output(OUTPUT_BLUETOOTH);
 337:quantum/quantum.c ****                 return false;
 338:quantum/quantum.c **** #endif
 339:quantum/quantum.c **** #ifndef NO_ACTION_ONESHOT
 340:quantum/quantum.c ****             case ONESHOT_TOGGLE:
 341:quantum/quantum.c ****                 oneshot_toggle();
 342:quantum/quantum.c ****                 break;
 343:quantum/quantum.c ****             case ONESHOT_ENABLE:
 344:quantum/quantum.c ****                 oneshot_enable();
 345:quantum/quantum.c ****                 break;
 346:quantum/quantum.c ****             case ONESHOT_DISABLE:
 347:quantum/quantum.c ****                 oneshot_disable();
 348:quantum/quantum.c ****                 break;
 349:quantum/quantum.c **** #endif
 350:quantum/quantum.c ****         }
 351:quantum/quantum.c ****     }
 352:quantum/quantum.c **** 
 353:quantum/quantum.c ****     return process_action_kb(record);
 354:quantum/quantum.c **** }
 355:quantum/quantum.c **** 
 356:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 664               		.loc 1 356 65 is_stmt 1 view -0
 665               		.cfi_startproc
 666               		.loc 1 356 65 is_stmt 0 view .LVU154
 667 0000 0F93      		push r16
 668               	.LCFI15:
 669               		.cfi_def_cfa_offset 3
 670               		.cfi_offset 16, -2
 671 0002 1F93      		push r17
 672               	.LCFI16:
 673               		.cfi_def_cfa_offset 4
 674               		.cfi_offset 17, -3
 675 0004 CF93      		push r28
 676               	.LCFI17:
 677               		.cfi_def_cfa_offset 5
 678               		.cfi_offset 28, -4
 679 0006 DF93      		push r29
 680               	.LCFI18:
 681               		.cfi_def_cfa_offset 6
 682               		.cfi_offset 29, -5
 683 0008 00D0      		rcall .
 684 000a 00D0      		rcall .
 685               	.LCFI19:
 686               		.cfi_def_cfa_offset 10
 687 000c CDB7      		in r28,__SP_L__
 688 000e DEB7      		in r29,__SP_H__
 689               	.LCFI20:
 690               		.cfi_def_cfa_register 28
 691               	/* prologue: function */
 692               	/* frame size = 4 */
 693               	/* stack size = 8 */
 694               	.L__stack_usage = 8
 357:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 358:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 359:quantum/quantum.c **** #endif
 360:quantum/quantum.c ****     eeconfig_update_default_layer((layer_state_t)1 << default_layer);
 695               		.loc 1 360 5 is_stmt 1 view .LVU155
 696               		.loc 1 360 52 is_stmt 0 view .LVU156
 697 0010 41E0      		ldi r20,lo8(1)
 698 0012 50E0      		ldi r21,0
 699 0014 60E0      		ldi r22,0
 700 0016 70E0      		ldi r23,0
 701 0018 8A01      		movw r16,r20
 702 001a 9B01      		movw r18,r22
 703 001c 00C0      		rjmp 2f
 704               		1:
 705 001e 000F      		lsl r16
 706 0020 111F      		rol r17
 707 0022 221F      		rol r18
 708 0024 331F      		rol r19
 709               		2:
 710 0026 8A95      		dec r24
 711 0028 02F4      		brpl 1b
 712 002a 0983      		std Y+1,r16
 713 002c 1A83      		std Y+2,r17
 714 002e 2B83      		std Y+3,r18
 715 0030 3C83      		std Y+4,r19
 716               		.loc 1 360 5 view .LVU157
 717 0032 8981      		ldd r24,Y+1
 718               	.LVL58:
 719               		.loc 1 360 5 view .LVU158
 720 0034 0E94 0000 		call eeconfig_update_default_layer
 721               	.LVL59:
 361:quantum/quantum.c ****     default_layer_set((layer_state_t)1 << default_layer);
 722               		.loc 1 361 5 is_stmt 1 view .LVU159
 723 0038 6981      		ldd r22,Y+1
 724 003a 7A81      		ldd r23,Y+2
 725 003c 8B81      		ldd r24,Y+3
 726 003e 9C81      		ldd r25,Y+4
 727               	/* epilogue start */
 362:quantum/quantum.c **** }
 728               		.loc 1 362 1 is_stmt 0 view .LVU160
 729 0040 0F90      		pop __tmp_reg__
 730 0042 0F90      		pop __tmp_reg__
 731 0044 0F90      		pop __tmp_reg__
 732 0046 0F90      		pop __tmp_reg__
 733 0048 DF91      		pop r29
 734 004a CF91      		pop r28
 735 004c 1F91      		pop r17
 736 004e 0F91      		pop r16
 361:quantum/quantum.c ****     default_layer_set((layer_state_t)1 << default_layer);
 737               		.loc 1 361 5 view .LVU161
 738 0050 0C94 0000 		jmp default_layer_set
 739               	.LVL60:
 740               		.cfi_endproc
 741               	.LFE42:
 743               		.section	.text.update_tri_layer_state,"ax",@progbits
 744               	.global	update_tri_layer_state
 746               	update_tri_layer_state:
 747               	.LVL61:
 748               	.LFB43:
 363:quantum/quantum.c **** 
 364:quantum/quantum.c **** layer_state_t update_tri_layer_state(layer_state_t state, uint8_t layer1, uint8_t layer2, uint8_t l
 749               		.loc 1 364 107 is_stmt 1 view -0
 750               		.cfi_startproc
 751               		.loc 1 364 107 is_stmt 0 view .LVU163
 752 0000 8F92      		push r8
 753               	.LCFI21:
 754               		.cfi_def_cfa_offset 3
 755               		.cfi_offset 8, -2
 756 0002 9F92      		push r9
 757               	.LCFI22:
 758               		.cfi_def_cfa_offset 4
 759               		.cfi_offset 9, -3
 760 0004 AF92      		push r10
 761               	.LCFI23:
 762               		.cfi_def_cfa_offset 5
 763               		.cfi_offset 10, -4
 764 0006 BF92      		push r11
 765               	.LCFI24:
 766               		.cfi_def_cfa_offset 6
 767               		.cfi_offset 11, -5
 768 0008 CF92      		push r12
 769               	.LCFI25:
 770               		.cfi_def_cfa_offset 7
 771               		.cfi_offset 12, -6
 772 000a DF92      		push r13
 773               	.LCFI26:
 774               		.cfi_def_cfa_offset 8
 775               		.cfi_offset 13, -7
 776 000c EF92      		push r14
 777               	.LCFI27:
 778               		.cfi_def_cfa_offset 9
 779               		.cfi_offset 14, -8
 780 000e FF92      		push r15
 781               	.LCFI28:
 782               		.cfi_def_cfa_offset 10
 783               		.cfi_offset 15, -9
 784 0010 0F93      		push r16
 785               	.LCFI29:
 786               		.cfi_def_cfa_offset 11
 787               		.cfi_offset 16, -10
 788 0012 1F93      		push r17
 789               	.LCFI30:
 790               		.cfi_def_cfa_offset 12
 791               		.cfi_offset 17, -11
 792 0014 CF93      		push r28
 793               	.LCFI31:
 794               		.cfi_def_cfa_offset 13
 795               		.cfi_offset 28, -12
 796 0016 DF93      		push r29
 797               	.LCFI32:
 798               		.cfi_def_cfa_offset 14
 799               		.cfi_offset 29, -13
 800 0018 00D0      		rcall .
 801 001a 00D0      		rcall .
 802               	.LCFI33:
 803               		.cfi_def_cfa_offset 18
 804 001c CDB7      		in r28,__SP_L__
 805 001e DEB7      		in r29,__SP_H__
 806               	.LCFI34:
 807               		.cfi_def_cfa_register 28
 808               	/* prologue: function */
 809               	/* frame size = 4 */
 810               	/* stack size = 16 */
 811               	.L__stack_usage = 16
 812 0020 6B01      		movw r12,r22
 813 0022 7C01      		movw r14,r24
 365:quantum/quantum.c ****     layer_state_t mask12 = ((layer_state_t)1 << layer1) | ((layer_state_t)1 << layer2);
 814               		.loc 1 365 5 is_stmt 1 view .LVU164
 815               		.loc 1 365 46 is_stmt 0 view .LVU165
 816 0024 81E0      		ldi r24,lo8(1)
 817 0026 90E0      		ldi r25,0
 818 0028 A0E0      		ldi r26,0
 819 002a B0E0      		ldi r27,0
 820 002c 4C01      		movw r8,r24
 821 002e 5D01      		movw r10,r26
 822 0030 00C0      		rjmp 2f
 823               		1:
 824 0032 880C      		lsl r8
 825 0034 991C      		rol r9
 826 0036 AA1C      		rol r10
 827 0038 BB1C      		rol r11
 828               		2:
 829 003a 4A95      		dec r20
 830 003c 02F4      		brpl 1b
 831 003e B501      		movw r22,r10
 832               	.LVL62:
 833               		.loc 1 365 46 view .LVU166
 834 0040 A401      		movw r20,r8
 835               	.LVL63:
 836               		.loc 1 365 77 view .LVU167
 837 0042 4C01      		movw r8,r24
 838 0044 5D01      		movw r10,r26
 839 0046 00C0      		rjmp 2f
 840               		1:
 841 0048 880C      		lsl r8
 842 004a 991C      		rol r9
 843 004c AA1C      		rol r10
 844 004e BB1C      		rol r11
 845               		2:
 846 0050 2A95      		dec r18
 847 0052 02F4      		brpl 1b
 848               		.loc 1 365 19 view .LVU168
 849 0054 4829      		or r20,r8
 850 0056 5929      		or r21,r9
 851 0058 6A29      		or r22,r10
 852 005a 7B29      		or r23,r11
 853               	.LVL64:
 366:quantum/quantum.c ****     layer_state_t mask3  = (layer_state_t)1 << layer3;
 854               		.loc 1 366 5 is_stmt 1 view .LVU169
 855               		.loc 1 366 19 is_stmt 0 view .LVU170
 856 005c 00C0      		rjmp 2f
 857               		1:
 858 005e 880F      		lsl r24
 859 0060 991F      		rol r25
 860 0062 AA1F      		rol r26
 861 0064 BB1F      		rol r27
 862               		2:
 863 0066 0A95      		dec r16
 864 0068 02F4      		brpl 1b
 865               	.LVL65:
 367:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 866               		.loc 1 367 5 is_stmt 1 view .LVU171
 867               		.loc 1 367 19 is_stmt 0 view .LVU172
 868 006a 8A01      		movw r16,r20
 869               	.LVL66:
 870               		.loc 1 367 19 view .LVU173
 871 006c 9B01      		movw r18,r22
 872               	.LVL67:
 873               		.loc 1 367 19 view .LVU174
 874 006e 0C21      		and r16,r12
 875 0070 1D21      		and r17,r13
 876 0072 2E21      		and r18,r14
 877 0074 3F21      		and r19,r15
 878               		.loc 1 367 57 view .LVU175
 879 0076 0417      		cp r16,r20
 880 0078 1507      		cpc r17,r21
 881 007a 2607      		cpc r18,r22
 882 007c 3707      		cpc r19,r23
 883 007e 01F4      		brne .L59
 884               		.loc 1 367 57 discriminator 1 view .LVU176
 885 0080 9C01      		movw r18,r24
 886 0082 AD01      		movw r20,r26
 887               	.LVL68:
 888               		.loc 1 367 57 discriminator 1 view .LVU177
 889 0084 2C29      		or r18,r12
 890 0086 3D29      		or r19,r13
 891 0088 4E29      		or r20,r14
 892 008a 5F29      		or r21,r15
 893 008c 2983      		std Y+1,r18
 894 008e 3A83      		std Y+2,r19
 895 0090 4B83      		std Y+3,r20
 896 0092 5C83      		std Y+4,r21
 897               	.LVL69:
 898               	.L58:
 368:quantum/quantum.c **** }
 899               		.loc 1 368 1 view .LVU178
 900 0094 6981      		ldd r22,Y+1
 901 0096 7A81      		ldd r23,Y+2
 902 0098 8B81      		ldd r24,Y+3
 903 009a 9C81      		ldd r25,Y+4
 904               	/* epilogue start */
 905 009c 0F90      		pop __tmp_reg__
 906 009e 0F90      		pop __tmp_reg__
 907 00a0 0F90      		pop __tmp_reg__
 908 00a2 0F90      		pop __tmp_reg__
 909 00a4 DF91      		pop r29
 910 00a6 CF91      		pop r28
 911 00a8 1F91      		pop r17
 912 00aa 0F91      		pop r16
 913 00ac FF90      		pop r15
 914 00ae EF90      		pop r14
 915 00b0 DF90      		pop r13
 916 00b2 CF90      		pop r12
 917 00b4 BF90      		pop r11
 918 00b6 AF90      		pop r10
 919 00b8 9F90      		pop r9
 920 00ba 8F90      		pop r8
 921 00bc 0895      		ret
 922               	.LVL70:
 923               	.L59:
 367:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 924               		.loc 1 367 68 discriminator 2 view .LVU179
 925 00be 8095      		com r24
 926 00c0 9095      		com r25
 927 00c2 A095      		com r26
 928 00c4 B095      		com r27
 929               	.LVL71:
 367:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 930               		.loc 1 367 57 discriminator 2 view .LVU180
 931 00c6 4C01      		movw r8,r24
 932 00c8 5D01      		movw r10,r26
 933 00ca 8C20      		and r8,r12
 934 00cc 9D20      		and r9,r13
 935 00ce AE20      		and r10,r14
 936 00d0 BF20      		and r11,r15
 937 00d2 8982      		std Y+1,r8
 938 00d4 9A82      		std Y+2,r9
 939 00d6 AB82      		std Y+3,r10
 940 00d8 BC82      		std Y+4,r11
 941 00da 00C0      		rjmp .L58
 942               		.cfi_endproc
 943               	.LFE43:
 945               		.section	.text.update_tri_layer,"ax",@progbits
 946               	.global	update_tri_layer
 948               	update_tri_layer:
 949               	.LVL72:
 950               	.LFB44:
 369:quantum/quantum.c **** 
 370:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) { layer_state_set(update_tri_
 951               		.loc 1 370 71 is_stmt 1 view -0
 952               		.cfi_startproc
 953               		.loc 1 370 71 is_stmt 0 view .LVU182
 954 0000 0F93      		push r16
 955               	.LCFI35:
 956               		.cfi_def_cfa_offset 3
 957               		.cfi_offset 16, -2
 958 0002 CF93      		push r28
 959               	.LCFI36:
 960               		.cfi_def_cfa_offset 4
 961               		.cfi_offset 28, -3
 962 0004 DF93      		push r29
 963               	.LCFI37:
 964               		.cfi_def_cfa_offset 5
 965               		.cfi_offset 29, -4
 966 0006 00D0      		rcall .
 967 0008 00D0      		rcall .
 968               	.LCFI38:
 969               		.cfi_def_cfa_offset 9
 970 000a CDB7      		in r28,__SP_L__
 971 000c DEB7      		in r29,__SP_H__
 972               	.LCFI39:
 973               		.cfi_def_cfa_register 28
 974               	/* prologue: function */
 975               	/* frame size = 4 */
 976               	/* stack size = 7 */
 977               	.L__stack_usage = 7
 978 000e 262F      		mov r18,r22
 979 0010 042F      		mov r16,r20
 980               		.loc 1 370 73 is_stmt 1 view .LVU183
 981 0012 4091 0000 		lds r20,layer_state
 982 0016 5091 0000 		lds r21,layer_state+1
 983 001a 6091 0000 		lds r22,layer_state+2
 984 001e 7091 0000 		lds r23,layer_state+3
 985               	.LVL73:
 986               		.loc 1 370 73 is_stmt 0 view .LVU184
 987 0022 4983      		std Y+1,r20
 988 0024 5A83      		std Y+2,r21
 989 0026 6B83      		std Y+3,r22
 990 0028 7C83      		std Y+4,r23
 991 002a 482F      		mov r20,r24
 992 002c 6981      		ldd r22,Y+1
 993 002e 7A81      		ldd r23,Y+2
 994 0030 8B81      		ldd r24,Y+3
 995 0032 9C81      		ldd r25,Y+4
 996               	.LVL74:
 997               		.loc 1 370 73 view .LVU185
 998 0034 0E94 0000 		call update_tri_layer_state
 999               	.LVL75:
 1000               	/* epilogue start */
 1001               		.loc 1 370 151 view .LVU186
 1002 0038 0F90      		pop __tmp_reg__
 1003 003a 0F90      		pop __tmp_reg__
 1004 003c 0F90      		pop __tmp_reg__
 1005 003e 0F90      		pop __tmp_reg__
 1006 0040 DF91      		pop r29
 1007 0042 CF91      		pop r28
 1008 0044 0F91      		pop r16
 1009               	.LVL76:
 1010               		.loc 1 370 73 view .LVU187
 1011 0046 0C94 0000 		jmp layer_state_set
 1012               	.LVL77:
 1013               		.cfi_endproc
 1014               	.LFE44:
 1016               		.section	.text.matrix_init_quantum,"ax",@progbits
 1017               	.global	matrix_init_quantum
 1019               	matrix_init_quantum:
 1020               	.LFB45:
 371:quantum/quantum.c **** 
 372:quantum/quantum.c **** void matrix_init_quantum() {
 1021               		.loc 1 372 28 is_stmt 1 view -0
 1022               		.cfi_startproc
 1023               	/* prologue: function */
 1024               	/* frame size = 0 */
 1025               	/* stack size = 0 */
 1026               	.L__stack_usage = 0
 373:quantum/quantum.c ****     magic();
 1027               		.loc 1 373 5 view .LVU189
 1028 0000 0E94 0000 		call magic
 1029               	.LVL78:
 374:quantum/quantum.c ****     led_init_ports();
 1030               		.loc 1 374 5 view .LVU190
 1031 0004 0E94 0000 		call led_init_ports
 1032               	.LVL79:
 375:quantum/quantum.c **** #ifdef BACKLIGHT_ENABLE
 376:quantum/quantum.c ****     backlight_init_ports();
 377:quantum/quantum.c **** #endif
 378:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 379:quantum/quantum.c ****     audio_init();
 380:quantum/quantum.c **** #endif
 381:quantum/quantum.c **** #ifdef LED_MATRIX_ENABLE
 382:quantum/quantum.c ****     led_matrix_init();
 383:quantum/quantum.c **** #endif
 384:quantum/quantum.c **** #ifdef RGB_MATRIX_ENABLE
 385:quantum/quantum.c ****     rgb_matrix_init();
 386:quantum/quantum.c **** #endif
 387:quantum/quantum.c **** #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 388:quantum/quantum.c ****     unicode_input_mode_init();
 389:quantum/quantum.c **** #endif
 390:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 391:quantum/quantum.c ****     haptic_init();
 392:quantum/quantum.c **** #endif
 393:quantum/quantum.c **** #if defined(BLUETOOTH_ENABLE) && defined(OUTPUT_AUTO_ENABLE)
 394:quantum/quantum.c ****     set_output(OUTPUT_AUTO);
 395:quantum/quantum.c **** #endif
 396:quantum/quantum.c **** 
 397:quantum/quantum.c ****     matrix_init_kb();
 1033               		.loc 1 397 5 view .LVU191
 1034 0008 0C94 0000 		jmp matrix_init_kb
 1035               	.LVL80:
 1036               		.cfi_endproc
 1037               	.LFE45:
 1039               		.section	.text.matrix_scan_quantum,"ax",@progbits
 1040               	.global	matrix_scan_quantum
 1042               	matrix_scan_quantum:
 1043               	.LFB46:
 398:quantum/quantum.c **** }
 399:quantum/quantum.c **** 
 400:quantum/quantum.c **** void matrix_scan_quantum() {
 1044               		.loc 1 400 28 view -0
 1045               		.cfi_startproc
 1046               	/* prologue: function */
 1047               	/* frame size = 0 */
 1048               	/* stack size = 0 */
 1049               	.L__stack_usage = 0
 401:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && defined(AUDIO_INIT_DELAY)
 402:quantum/quantum.c ****     // There are some tasks that need to be run a little bit
 403:quantum/quantum.c ****     // after keyboard startup, or else they will not work correctly
 404:quantum/quantum.c ****     // because of interaction with the USB device state, which
 405:quantum/quantum.c ****     // may still be in flux...
 406:quantum/quantum.c ****     //
 407:quantum/quantum.c ****     // At the moment the only feature that needs this is the
 408:quantum/quantum.c ****     // startup song.
 409:quantum/quantum.c ****     static bool     delayed_tasks_run  = false;
 410:quantum/quantum.c ****     static uint16_t delayed_task_timer = 0;
 411:quantum/quantum.c ****     if (!delayed_tasks_run) {
 412:quantum/quantum.c ****         if (!delayed_task_timer) {
 413:quantum/quantum.c ****             delayed_task_timer = timer_read();
 414:quantum/quantum.c ****         } else if (timer_elapsed(delayed_task_timer) > 300) {
 415:quantum/quantum.c ****             audio_startup();
 416:quantum/quantum.c ****             delayed_tasks_run = true;
 417:quantum/quantum.c ****         }
 418:quantum/quantum.c ****     }
 419:quantum/quantum.c **** #endif
 420:quantum/quantum.c **** 
 421:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 422:quantum/quantum.c ****     music_task();
 423:quantum/quantum.c **** #endif
 424:quantum/quantum.c **** 
 425:quantum/quantum.c **** #ifdef KEY_OVERRIDE_ENABLE
 426:quantum/quantum.c ****     key_override_task();
 427:quantum/quantum.c **** #endif
 428:quantum/quantum.c **** 
 429:quantum/quantum.c **** #ifdef SEQUENCER_ENABLE
 430:quantum/quantum.c ****     sequencer_task();
 431:quantum/quantum.c **** #endif
 432:quantum/quantum.c **** 
 433:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 434:quantum/quantum.c ****     tap_dance_task();
 435:quantum/quantum.c **** #endif
 436:quantum/quantum.c **** 
 437:quantum/quantum.c **** #ifdef COMBO_ENABLE
 438:quantum/quantum.c ****     combo_task();
 439:quantum/quantum.c **** #endif
 440:quantum/quantum.c **** 
 441:quantum/quantum.c **** #ifdef LED_MATRIX_ENABLE
 442:quantum/quantum.c ****     led_matrix_task();
 443:quantum/quantum.c **** #endif
 444:quantum/quantum.c **** 
 445:quantum/quantum.c **** #ifdef WPM_ENABLE
 446:quantum/quantum.c ****     decay_wpm();
 1050               		.loc 1 446 5 view .LVU193
 1051 0000 0E94 0000 		call decay_wpm
 1052               	.LVL81:
 447:quantum/quantum.c **** #endif
 448:quantum/quantum.c **** 
 449:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 450:quantum/quantum.c ****     haptic_task();
 451:quantum/quantum.c **** #endif
 452:quantum/quantum.c **** 
 453:quantum/quantum.c **** #ifdef DIP_SWITCH_ENABLE
 454:quantum/quantum.c ****     dip_switch_read(false);
 455:quantum/quantum.c **** #endif
 456:quantum/quantum.c **** 
 457:quantum/quantum.c **** #ifdef AUTO_SHIFT_ENABLE
 458:quantum/quantum.c ****     autoshift_matrix_scan();
 459:quantum/quantum.c **** #endif
 460:quantum/quantum.c **** 
 461:quantum/quantum.c ****     matrix_scan_kb();
 1053               		.loc 1 461 5 view .LVU194
 1054 0004 0C94 0000 		jmp matrix_scan_kb
 1055               	.LVL82:
 1056               		.cfi_endproc
 1057               	.LFE46:
 1059               		.section	.text.api_send_unicode,"ax",@progbits
 1060               	.global	api_send_unicode
 1062               	api_send_unicode:
 1063               	.LVL83:
 1064               	.LFB47:
 462:quantum/quantum.c **** }
 463:quantum/quantum.c **** 
 464:quantum/quantum.c **** #ifdef HD44780_ENABLED
 465:quantum/quantum.c **** #    include "hd44780.h"
 466:quantum/quantum.c **** #endif
 467:quantum/quantum.c **** 
 468:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 1065               		.loc 1 468 41 view -0
 1066               		.cfi_startproc
 1067               	/* prologue: function */
 1068               	/* frame size = 0 */
 1069               	/* stack size = 0 */
 1070               	.L__stack_usage = 0
 469:quantum/quantum.c **** #ifdef API_ENABLE
 470:quantum/quantum.c ****     uint8_t chunk[4];
 471:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
 472:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
 473:quantum/quantum.c **** #endif
 474:quantum/quantum.c **** }
 1071               		.loc 1 474 1 view .LVU196
 1072               	/* epilogue start */
 1073 0000 0895      		ret
 1074               		.cfi_endproc
 1075               	.LFE47:
 1077               		.section	.text.startup_user,"ax",@progbits
 1078               		.weak	startup_user
 1080               	startup_user:
 1081               	.LFB48:
 475:quantum/quantum.c **** 
 476:quantum/quantum.c **** //------------------------------------------------------------------------------
 477:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
 478:quantum/quantum.c **** // different events such as startup and bootloader jump
 479:quantum/quantum.c **** 
 480:quantum/quantum.c **** __attribute__((weak)) void startup_user() {}
 1082               		.loc 1 480 43 view -0
 1083               		.cfi_startproc
 1084               	/* prologue: function */
 1085               	/* frame size = 0 */
 1086               	/* stack size = 0 */
 1087               	.L__stack_usage = 0
 1088               		.loc 1 480 44 view .LVU198
 1089               	/* epilogue start */
 1090 0000 0895      		ret
 1091               		.cfi_endproc
 1092               	.LFE48:
 1094               		.section	.text.shutdown_user,"ax",@progbits
 1095               		.weak	shutdown_user
 1097               	shutdown_user:
 1098               	.LFB51:
 1099               		.cfi_startproc
 1100               	/* prologue: function */
 1101               	/* frame size = 0 */
 1102               	/* stack size = 0 */
 1103               	.L__stack_usage = 0
 1104               	/* epilogue start */
 1105 0000 0895      		ret
 1106               		.cfi_endproc
 1107               	.LFE51:
 1109               		.section	.text.reset_keyboard,"ax",@progbits
 1110               	.global	reset_keyboard
 1112               	reset_keyboard:
 1113               	.LFB36:
 121:quantum/quantum.c ****     clear_keyboard();
 1114               		.loc 1 121 27 view -0
 1115               		.cfi_startproc
 1116               	/* prologue: function */
 1117               	/* frame size = 0 */
 1118               	/* stack size = 0 */
 1119               	.L__stack_usage = 0
 122:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 1120               		.loc 1 122 5 view .LVU200
 1121 0000 0E94 0000 		call clear_keyboard
 1122               	.LVL84:
 136:quantum/quantum.c ****     wait_ms(250);
 1123               		.loc 1 136 5 view .LVU201
 1124 0004 0E94 0000 		call shutdown_user
 1125               	.LVL85:
 137:quantum/quantum.c **** #endif
 1126               		.loc 1 137 5 view .LVU202
 137:quantum/quantum.c **** #endif
 1127               		.loc 1 137 5 view .LVU203
 137:quantum/quantum.c **** #endif
 1128               		.loc 1 137 5 view .LVU204
 1129               	.LBB10:
 1130               	.LBI10:
 166:/usr/avr/include/util/delay.h **** {
 1131               		.loc 2 166 1 view .LVU205
 1132               	.LBB11:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1133               		.loc 2 168 2 view .LVU206
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1134               		.loc 2 172 2 view .LVU207
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1135               		.loc 2 173 2 view .LVU208
 174:/usr/avr/include/util/delay.h **** 
 1136               		.loc 2 174 2 view .LVU209
 184:/usr/avr/include/util/delay.h **** 	#endif
 1137               		.loc 2 184 3 view .LVU210
 1138               		.loc 2 187 2 view .LVU211
 1139 0008 2FEF      		ldi r18,lo8(799999)
 1140 000a 84E3      		ldi r24,hi8(799999)
 1141 000c 9CE0      		ldi r25,hlo8(799999)
 1142 000e 2150      	1:	subi r18,1
 1143 0010 8040      		sbci r24,0
 1144 0012 9040      		sbci r25,0
 1145 0014 01F4      		brne 1b
 1146 0016 00C0      		rjmp .
 1147 0018 0000      		nop
 1148               	.LVL86:
 1149               		.loc 2 187 2 is_stmt 0 view .LVU212
 1150               	.LBE11:
 1151               	.LBE10:
 137:quantum/quantum.c **** #endif
 1152               		.loc 1 137 5 is_stmt 1 view .LVU213
 142:quantum/quantum.c **** }
 1153               		.loc 1 142 5 view .LVU214
 1154 001a 0C94 0000 		jmp bootloader_jump
 1155               	.LVL87:
 1156               		.cfi_endproc
 1157               	.LFE36:
 1159               		.section	.text.process_record_quantum,"ax",@progbits
 1160               	.global	process_record_quantum
 1162               	process_record_quantum:
 1163               	.LVL88:
 1164               	.LFB41:
 199:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record, true);
 1165               		.loc 1 199 50 view -0
 1166               		.cfi_startproc
 199:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record, true);
 1167               		.loc 1 199 50 is_stmt 0 view .LVU216
 1168 0000 0F93      		push r16
 1169               	.LCFI40:
 1170               		.cfi_def_cfa_offset 3
 1171               		.cfi_offset 16, -2
 1172 0002 1F93      		push r17
 1173               	.LCFI41:
 1174               		.cfi_def_cfa_offset 4
 1175               		.cfi_offset 17, -3
 1176 0004 CF93      		push r28
 1177               	.LCFI42:
 1178               		.cfi_def_cfa_offset 5
 1179               		.cfi_offset 28, -4
 1180 0006 DF93      		push r29
 1181               	.LCFI43:
 1182               		.cfi_def_cfa_offset 6
 1183               		.cfi_offset 29, -5
 1184               	/* prologue: function */
 1185               	/* frame size = 0 */
 1186               	/* stack size = 4 */
 1187               	.L__stack_usage = 4
 1188 0008 8C01      		movw r16,r24
 200:quantum/quantum.c **** 
 1189               		.loc 1 200 5 is_stmt 1 view .LVU217
 200:quantum/quantum.c **** 
 1190               		.loc 1 200 24 is_stmt 0 view .LVU218
 1191 000a 61E0      		ldi r22,lo8(1)
 1192 000c 0E94 0000 		call get_record_keycode
 1193               	.LVL89:
 200:quantum/quantum.c **** 
 1194               		.loc 1 200 24 view .LVU219
 1195 0010 EC01      		movw r28,r24
 1196               	.LVL90:
 217:quantum/quantum.c ****         update_wpm(keycode);
 1197               		.loc 1 217 5 is_stmt 1 view .LVU220
 217:quantum/quantum.c ****         update_wpm(keycode);
 1198               		.loc 1 217 8 is_stmt 0 view .LVU221
 1199 0012 F801      		movw r30,r16
 1200 0014 8281      		ldd r24,Z+2
 1201               	.LVL91:
 217:quantum/quantum.c ****         update_wpm(keycode);
 1202               		.loc 1 217 8 view .LVU222
 1203 0016 8823      		tst r24
 1204 0018 01F0      		breq .L69
 218:quantum/quantum.c ****     }
 1205               		.loc 1 218 9 is_stmt 1 view .LVU223
 1206 001a CE01      		movw r24,r28
 1207 001c 0E94 0000 		call update_wpm
 1208               	.LVL92:
 1209               	.L69:
 226:quantum/quantum.c **** #if defined(KEY_LOCK_ENABLE)
 1210               		.loc 1 226 5 view .LVU224
 244:quantum/quantum.c **** #if defined(SEQUENCER_ENABLE)
 1211               		.loc 1 244 13 is_stmt 0 view .LVU225
 1212 0020 B801      		movw r22,r16
 1213 0022 CE01      		movw r24,r28
 1214 0024 0E94 0000 		call process_record_kb
 1215               	.LVL93:
 288:quantum/quantum.c **** #endif
 1216               		.loc 1 288 44 view .LVU226
 1217 0028 8823      		tst r24
 1218 002a 01F0      		breq .L68
 285:quantum/quantum.c **** #endif
 1219               		.loc 1 285 13 view .LVU227
 1220 002c B801      		movw r22,r16
 1221 002e CE01      		movw r24,r28
 1222 0030 0E94 0000 		call process_space_cadet
 1223               	.LVL94:
 244:quantum/quantum.c **** #if defined(SEQUENCER_ENABLE)
 1224               		.loc 1 244 48 view .LVU228
 1225 0034 8823      		tst r24
 1226 0036 01F0      		breq .L68
 288:quantum/quantum.c **** #endif
 1227               		.loc 1 288 13 view .LVU229
 1228 0038 B801      		movw r22,r16
 1229 003a CE01      		movw r24,r28
 1230 003c 0E94 0000 		call process_magic
 1231               	.LVL95:
 285:quantum/quantum.c **** #endif
 1232               		.loc 1 285 50 view .LVU230
 1233 0040 8823      		tst r24
 1234 0042 01F0      		breq .L68
 291:quantum/quantum.c **** #endif
 1235               		.loc 1 291 13 discriminator 2 view .LVU231
 1236 0044 B801      		movw r22,r16
 1237 0046 CE01      		movw r24,r28
 1238 0048 0E94 0000 		call process_grave_esc
 1239               	.LVL96:
 288:quantum/quantum.c **** #endif
 1240               		.loc 1 288 44 discriminator 2 view .LVU232
 1241 004c 8823      		tst r24
 1242 004e 01F0      		breq .L68
 303:quantum/quantum.c ****         switch (keycode) {
 1243               		.loc 1 303 5 is_stmt 1 view .LVU233
 303:quantum/quantum.c ****         switch (keycode) {
 1244               		.loc 1 303 8 is_stmt 0 view .LVU234
 1245 0050 F801      		movw r30,r16
 1246 0052 8281      		ldd r24,Z+2
 1247 0054 8823      		tst r24
 1248 0056 01F0      		breq .L73
 304:quantum/quantum.c **** #ifndef NO_RESET
 1249               		.loc 1 304 9 is_stmt 1 view .LVU235
 1250 0058 CB35      		cpi r28,91
 1251 005a FDE5      		ldi r31,93
 1252 005c DF07      		cpc r29,r31
 1253 005e 01F0      		breq .L74
 1254 0060 00F4      		brsh .L75
 1255 0062 C115      		cp r28,__zero_reg__
 1256 0064 ECE5      		ldi r30,92
 1257 0066 DE07      		cpc r29,r30
 1258 0068 01F0      		breq .L76
 1259 006a CF3D      		cpi r28,-33
 1260 006c DC45      		sbci r29,92
 1261 006e 01F0      		breq .L77
 1262               	.L73:
 353:quantum/quantum.c **** }
 1263               		.loc 1 353 5 view .LVU236
 353:quantum/quantum.c **** }
 1264               		.loc 1 353 12 is_stmt 0 view .LVU237
 1265 0070 C801      		movw r24,r16
 1266               	/* epilogue start */
 354:quantum/quantum.c **** 
 1267               		.loc 1 354 1 view .LVU238
 1268 0072 DF91      		pop r29
 1269 0074 CF91      		pop r28
 1270               	.LVL97:
 354:quantum/quantum.c **** 
 1271               		.loc 1 354 1 view .LVU239
 1272 0076 1F91      		pop r17
 1273 0078 0F91      		pop r16
 1274               	.LVL98:
 353:quantum/quantum.c **** }
 1275               		.loc 1 353 12 view .LVU240
 1276 007a 0C94 0000 		jmp process_action_kb
 1277               	.LVL99:
 1278               	.L75:
 304:quantum/quantum.c **** #ifndef NO_RESET
 1279               		.loc 1 304 9 view .LVU241
 1280 007e CC35      		cpi r28,92
 1281 0080 8DE5      		ldi r24,93
 1282 0082 D807      		cpc r29,r24
 1283 0084 01F0      		breq .L78
 1284 0086 CD35      		cpi r28,93
 1285 0088 DD45      		sbci r29,93
 1286 008a 01F4      		brne .L73
 341:quantum/quantum.c ****                 break;
 1287               		.loc 1 341 17 is_stmt 1 view .LVU242
 1288 008c 0E94 0000 		call oneshot_toggle
 1289               	.LVL100:
 342:quantum/quantum.c ****             case ONESHOT_ENABLE:
 1290               		.loc 1 342 17 view .LVU243
 1291 0090 00C0      		rjmp .L73
 1292               	.L76:
 307:quantum/quantum.c ****                 return false;
 1293               		.loc 1 307 17 view .LVU244
 1294 0092 0E94 0000 		call reset_keyboard
 1295               	.LVL101:
 308:quantum/quantum.c **** #endif
 1296               		.loc 1 308 17 view .LVU245
 1297               	.L68:
 354:quantum/quantum.c **** 
 1298               		.loc 1 354 1 is_stmt 0 view .LVU246
 1299 0096 80E0      		ldi r24,0
 1300               	/* epilogue start */
 1301 0098 DF91      		pop r29
 1302 009a CF91      		pop r28
 1303               	.LVL102:
 354:quantum/quantum.c **** 
 1304               		.loc 1 354 1 view .LVU247
 1305 009c 1F91      		pop r17
 1306 009e 0F91      		pop r16
 1307               	.LVL103:
 354:quantum/quantum.c **** 
 1308               		.loc 1 354 1 view .LVU248
 1309 00a0 0895      		ret
 1310               	.LVL104:
 1311               	.L77:
 321:quantum/quantum.c ****                 return false;
 1312               		.loc 1 321 17 is_stmt 1 view .LVU249
 1313 00a2 0E94 0000 		call eeconfig_init
 1314               	.LVL105:
 322:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 1315               		.loc 1 322 17 view .LVU250
 322:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 1316               		.loc 1 322 24 is_stmt 0 view .LVU251
 1317 00a6 00C0      		rjmp .L68
 1318               	.L74:
 344:quantum/quantum.c ****                 break;
 1319               		.loc 1 344 17 is_stmt 1 view .LVU252
 1320 00a8 0E94 0000 		call oneshot_enable
 1321               	.LVL106:
 345:quantum/quantum.c ****             case ONESHOT_DISABLE:
 1322               		.loc 1 345 17 view .LVU253
 1323 00ac 00C0      		rjmp .L73
 1324               	.L78:
 347:quantum/quantum.c ****                 break;
 1325               		.loc 1 347 17 view .LVU254
 1326 00ae 0E94 0000 		call oneshot_disable
 1327               	.LVL107:
 348:quantum/quantum.c **** #endif
 1328               		.loc 1 348 17 view .LVU255
 1329 00b2 00C0      		rjmp .L73
 1330               		.cfi_endproc
 1331               	.LFE41:
 1333               		.text
 1334               	.Letext0:
 1335               		.file 3 "/usr/avr/include/stdint.h"
 1336               		.file 4 "quantum/keyboard.h"
 1337               		.file 5 "quantum/action.h"
 1338               		.file 6 "quantum/keycode.h"
 1339               		.file 7 "quantum/quantum_keycodes.h"
 1340               		.file 8 "quantum/action_layer.h"
 1341               		.file 9 "quantum/matrix.h"
 1342               		.file 10 "quantum/wpm.h"
 1343               		.file 11 "quantum/led.h"
 1344               		.file 12 "quantum/bootmagic/magic.h"
 1345               		.file 13 "quantum/eeconfig.h"
 1346               		.file 14 "quantum/action_util.h"
 1347               		.file 15 "quantum/process_keycode/process_grave_esc.h"
 1348               		.file 16 "quantum/process_keycode/process_magic.h"
 1349               		.file 17 "quantum/process_keycode/process_space_cadet.h"
 1350               		.file 18 "quantum/keymap.h"
 1351               		.file 19 "tmk_core/common/bootloader.h"
 1352               		.file 20 "/usr/avr/include/math.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/cc0j4StY.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc0j4StY.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc0j4StY.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc0j4StY.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc0j4StY.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc0j4StY.s:13     .text.extract_mod_bits:0000000000000000 extract_mod_bits
     /tmp/cc0j4StY.s:129    .text.do_code16:0000000000000000 do_code16
     /tmp/cc0j4StY.s:168    .text.register_code16:0000000000000000 register_code16
     /tmp/cc0j4StY.s:226    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/cc0j4StY.s:284    .text.tap_code16:0000000000000000 tap_code16
     /tmp/cc0j4StY.s:348    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/cc0j4StY.s:370    .text.process_record_user:0000000000000000 process_record_user
     /tmp/cc0j4StY.s:392    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/cc0j4StY.s:412    .text.post_process_record_user:0000000000000000 post_process_record_user
     /tmp/cc0j4StY.s:430    .text.post_process_record_kb:0000000000000000 post_process_record_kb
     /tmp/cc0j4StY.s:449    .text.get_event_keycode:0000000000000000 get_event_keycode
     /tmp/cc0j4StY.s:564    .text.get_record_keycode:0000000000000000 get_record_keycode
     /tmp/cc0j4StY.s:596    .text.pre_process_record_quantum:0000000000000000 pre_process_record_quantum
     /tmp/cc0j4StY.s:619    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
     /tmp/cc0j4StY.s:661    .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/cc0j4StY.s:746    .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
     /tmp/cc0j4StY.s:948    .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/cc0j4StY.s:1019   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/cc0j4StY.s:1042   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/cc0j4StY.s:1062   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/cc0j4StY.s:1080   .text.startup_user:0000000000000000 startup_user
     /tmp/cc0j4StY.s:1097   .text.shutdown_user:0000000000000000 shutdown_user
     /tmp/cc0j4StY.s:1112   .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/cc0j4StY.s:1162   .text.process_record_quantum:0000000000000000 process_record_quantum

UNDEFINED SYMBOLS
register_weak_mods
register_mods
register_code
unregister_code
unregister_weak_mods
unregister_mods
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
keymap_key_to_keycode
read_source_layers_cache
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
magic
led_init_ports
matrix_init_kb
decay_wpm
matrix_scan_kb
clear_keyboard
bootloader_jump
update_wpm
process_space_cadet
process_magic
process_grave_esc
oneshot_toggle
eeconfig_init
oneshot_enable
oneshot_disable
