   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 4
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 2
  15              		.file	"action_layer.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "quantum/action_layer.c"
  20              		.section	.text.default_layer_state_set_user,"ax",%progbits
  21              		.align	1
  22              		.weak	default_layer_state_set_user
  23              		.syntax unified
  24              		.thumb
  25              		.thumb_func
  27              	default_layer_state_set_user:
  28              	.LVL0:
  29              	.LFB3:
   1:quantum/action_layer.c **** #include <stdint.h>
   2:quantum/action_layer.c **** #include "keyboard.h"
   3:quantum/action_layer.c **** #include "action.h"
   4:quantum/action_layer.c **** #include "util.h"
   5:quantum/action_layer.c **** #include "action_layer.h"
   6:quantum/action_layer.c **** 
   7:quantum/action_layer.c **** #ifdef DEBUG_ACTION
   8:quantum/action_layer.c **** #    include "debug.h"
   9:quantum/action_layer.c **** #else
  10:quantum/action_layer.c **** #    include "nodebug.h"
  11:quantum/action_layer.c **** #endif
  12:quantum/action_layer.c **** 
  13:quantum/action_layer.c **** /** \brief Default Layer State
  14:quantum/action_layer.c ****  */
  15:quantum/action_layer.c **** layer_state_t default_layer_state = 0;
  16:quantum/action_layer.c **** 
  17:quantum/action_layer.c **** /** \brief Default Layer State Set At user Level
  18:quantum/action_layer.c ****  *
  19:quantum/action_layer.c ****  * Run user code on default layer state change
  20:quantum/action_layer.c ****  */
  21:quantum/action_layer.c **** __attribute__((weak)) layer_state_t default_layer_state_set_user(layer_state_t state) { return stat
  30              		.loc 1 21 87 view -0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 0
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              		@ link register save eliminated.
  35              		.loc 1 21 89 view .LVU1
  36              		.loc 1 21 103 is_stmt 0 view .LVU2
  37 0000 7047     		bx	lr
  38              		.cfi_endproc
  39              	.LFE3:
  41              		.section	.text.default_layer_state_set_kb,"ax",%progbits
  42              		.align	1
  43              		.weak	default_layer_state_set_kb
  44              		.syntax unified
  45              		.thumb
  46              		.thumb_func
  48              	default_layer_state_set_kb:
  49              	.LVL1:
  50              	.LFB4:
  22:quantum/action_layer.c **** 
  23:quantum/action_layer.c **** /** \brief Default Layer State Set At Keyboard Level
  24:quantum/action_layer.c ****  *
  25:quantum/action_layer.c ****  *  Run keyboard code on default layer state change
  26:quantum/action_layer.c ****  */
  27:quantum/action_layer.c **** __attribute__((weak)) layer_state_t default_layer_state_set_kb(layer_state_t state) { return defaul
  51              		.loc 1 27 85 is_stmt 1 view -0
  52              		.cfi_startproc
  53              		@ args = 0, pretend = 0, frame = 0
  54              		@ frame_needed = 0, uses_anonymous_args = 0
  55              		.loc 1 27 87 view .LVU4
  56              		.loc 1 27 85 is_stmt 0 view .LVU5
  57 0000 08B5     		push	{r3, lr}
  58              		.cfi_def_cfa_offset 8
  59              		.cfi_offset 3, -8
  60              		.cfi_offset 14, -4
  61              		.loc 1 27 94 view .LVU6
  62 0002 FFF7FEFF 		bl	default_layer_state_set_user
  63              	.LVL2:
  64              		.loc 1 27 131 view .LVU7
  65 0006 08BD     		pop	{r3, pc}
  66              		.cfi_endproc
  67              	.LFE4:
  69              		.section	.text.default_layer_state_set,"ax",%progbits
  70              		.align	1
  71              		.syntax unified
  72              		.thumb
  73              		.thumb_func
  75              	default_layer_state_set:
  76              	.LVL3:
  77              	.LFB5:
  28:quantum/action_layer.c **** 
  29:quantum/action_layer.c **** /** \brief Default Layer State Set
  30:quantum/action_layer.c ****  *
  31:quantum/action_layer.c ****  * Static function to set the default layer state, prints debug info and clears keys
  32:quantum/action_layer.c ****  */
  33:quantum/action_layer.c **** static void default_layer_state_set(layer_state_t state) {
  78              		.loc 1 33 58 is_stmt 1 view -0
  79              		.cfi_startproc
  80              		@ args = 0, pretend = 0, frame = 0
  81              		@ frame_needed = 0, uses_anonymous_args = 0
  34:quantum/action_layer.c ****     state = default_layer_state_set_kb(state);
  82              		.loc 1 34 5 view .LVU9
  33:quantum/action_layer.c ****     state = default_layer_state_set_kb(state);
  83              		.loc 1 33 58 is_stmt 0 view .LVU10
  84 0000 08B5     		push	{r3, lr}
  85              		.cfi_def_cfa_offset 8
  86              		.cfi_offset 3, -8
  87              		.cfi_offset 14, -4
  88              		.loc 1 34 13 view .LVU11
  89 0002 FFF7FEFF 		bl	default_layer_state_set_kb
  90              	.LVL4:
  35:quantum/action_layer.c ****     debug("default_layer_state: ");
  91              		.loc 1 35 35 is_stmt 1 view .LVU12
  36:quantum/action_layer.c ****     default_layer_debug();
  92              		.loc 1 36 5 view .LVU13
  37:quantum/action_layer.c ****     debug(" to ");
  93              		.loc 1 37 18 view .LVU14
  38:quantum/action_layer.c ****     default_layer_state = state;
  94              		.loc 1 38 5 view .LVU15
  95              		.loc 1 38 25 is_stmt 0 view .LVU16
  96 0006 034B     		ldr	r3, .L4
  97 0008 1860     		str	r0, [r3]
  39:quantum/action_layer.c ****     default_layer_debug();
  98              		.loc 1 39 5 is_stmt 1 view .LVU17
  40:quantum/action_layer.c ****     debug("\n");
  99              		.loc 1 40 16 view .LVU18
  41:quantum/action_layer.c **** #ifdef STRICT_LAYER_RELEASE
  42:quantum/action_layer.c ****     clear_keyboard_but_mods();  // To avoid stuck keys
  43:quantum/action_layer.c **** #else
  44:quantum/action_layer.c ****     clear_keyboard_but_mods_and_keys();  // Don't reset held keys
 100              		.loc 1 44 5 view .LVU19
  45:quantum/action_layer.c **** #endif
  46:quantum/action_layer.c **** }
 101              		.loc 1 46 1 is_stmt 0 view .LVU20
 102 000a BDE80840 		pop	{r3, lr}
 103              		.cfi_restore 14
 104              		.cfi_restore 3
 105              		.cfi_def_cfa_offset 0
  44:quantum/action_layer.c **** #endif
 106              		.loc 1 44 5 view .LVU21
 107 000e FFF7FEBF 		b	clear_keyboard_but_mods_and_keys
 108              	.LVL5:
 109              	.L5:
  44:quantum/action_layer.c **** #endif
 110              		.loc 1 44 5 view .LVU22
 111 0012 00BF     		.align	2
 112              	.L4:
 113 0014 00000000 		.word	default_layer_state
 114              		.cfi_endproc
 115              	.LFE5:
 117              		.section	.text.default_layer_debug,"ax",%progbits
 118              		.align	1
 119              		.global	default_layer_debug
 120              		.syntax unified
 121              		.thumb
 122              		.thumb_func
 124              	default_layer_debug:
 125              	.LFB6:
  47:quantum/action_layer.c **** 
  48:quantum/action_layer.c **** /** \brief Default Layer Print
  49:quantum/action_layer.c ****  *
  50:quantum/action_layer.c ****  * Print out the hex value of the 32-bit default layer state, as well as the value of the highest b
  51:quantum/action_layer.c ****  */
  52:quantum/action_layer.c **** void default_layer_debug(void) { dprintf("%08lX(%u)", default_layer_state, get_highest_layer(defaul
 126              		.loc 1 52 32 is_stmt 1 view -0
 127              		.cfi_startproc
 128              		@ args = 0, pretend = 0, frame = 0
 129              		@ frame_needed = 0, uses_anonymous_args = 0
 130              		@ link register save eliminated.
 131              		.loc 1 52 115 view .LVU24
 132              		.loc 1 52 117 is_stmt 0 view .LVU25
 133 0000 7047     		bx	lr
 134              		.cfi_endproc
 135              	.LFE6:
 137              		.section	.text.default_layer_set,"ax",%progbits
 138              		.align	1
 139              		.global	default_layer_set
 140              		.syntax unified
 141              		.thumb
 142              		.thumb_func
 144              	default_layer_set:
 145              	.LVL6:
 146              	.LFB7:
  53:quantum/action_layer.c **** 
  54:quantum/action_layer.c **** /** \brief Default Layer Set
  55:quantum/action_layer.c ****  *
  56:quantum/action_layer.c ****  * Sets the default layer state.
  57:quantum/action_layer.c ****  */
  58:quantum/action_layer.c **** void default_layer_set(layer_state_t state) { default_layer_state_set(state); }
 147              		.loc 1 58 45 is_stmt 1 view -0
 148              		.cfi_startproc
 149              		@ args = 0, pretend = 0, frame = 0
 150              		@ frame_needed = 0, uses_anonymous_args = 0
 151              		@ link register save eliminated.
 152              		.loc 1 58 47 view .LVU27
 153 0000 FFF7FEBF 		b	default_layer_state_set
 154              	.LVL7:
 155              		.loc 1 58 47 is_stmt 0 view .LVU28
 156              		.cfi_endproc
 157              	.LFE7:
 159              		.section	.text.default_layer_or,"ax",%progbits
 160              		.align	1
 161              		.global	default_layer_or
 162              		.syntax unified
 163              		.thumb
 164              		.thumb_func
 166              	default_layer_or:
 167              	.LVL8:
 168              	.LFB8:
  59:quantum/action_layer.c **** 
  60:quantum/action_layer.c **** #ifndef NO_ACTION_LAYER
  61:quantum/action_layer.c **** /** \brief Default Layer Or
  62:quantum/action_layer.c ****  *
  63:quantum/action_layer.c ****  * Turns on the default layer based on matching bits between specifed layer and existing layer stat
  64:quantum/action_layer.c ****  */
  65:quantum/action_layer.c **** void default_layer_or(layer_state_t state) { default_layer_state_set(default_layer_state | state); 
 169              		.loc 1 65 44 is_stmt 1 view -0
 170              		.cfi_startproc
 171              		@ args = 0, pretend = 0, frame = 0
 172              		@ frame_needed = 0, uses_anonymous_args = 0
 173              		@ link register save eliminated.
 174              		.loc 1 65 46 view .LVU30
 175 0000 024B     		ldr	r3, .L9
 176 0002 1B68     		ldr	r3, [r3]
 177 0004 1843     		orrs	r0, r0, r3
 178              	.LVL9:
 179              		.loc 1 65 46 is_stmt 0 view .LVU31
 180 0006 FFF7FEBF 		b	default_layer_state_set
 181              	.LVL10:
 182              	.L10:
 183 000a 00BF     		.align	2
 184              	.L9:
 185 000c 00000000 		.word	default_layer_state
 186              		.cfi_endproc
 187              	.LFE8:
 189              		.section	.text.default_layer_and,"ax",%progbits
 190              		.align	1
 191              		.global	default_layer_and
 192              		.syntax unified
 193              		.thumb
 194              		.thumb_func
 196              	default_layer_and:
 197              	.LVL11:
 198              	.LFB9:
  66:quantum/action_layer.c **** /** \brief Default Layer And
  67:quantum/action_layer.c ****  *
  68:quantum/action_layer.c ****  * Turns on default layer based on matching enabled bits between specifed layer and existing layer 
  69:quantum/action_layer.c ****  */
  70:quantum/action_layer.c **** void default_layer_and(layer_state_t state) { default_layer_state_set(default_layer_state & state);
 199              		.loc 1 70 45 is_stmt 1 view -0
 200              		.cfi_startproc
 201              		@ args = 0, pretend = 0, frame = 0
 202              		@ frame_needed = 0, uses_anonymous_args = 0
 203              		@ link register save eliminated.
 204              		.loc 1 70 47 view .LVU33
 205 0000 024B     		ldr	r3, .L12
 206 0002 1B68     		ldr	r3, [r3]
 207 0004 1840     		ands	r0, r0, r3
 208              	.LVL12:
 209              		.loc 1 70 47 is_stmt 0 view .LVU34
 210 0006 FFF7FEBF 		b	default_layer_state_set
 211              	.LVL13:
 212              	.L13:
 213 000a 00BF     		.align	2
 214              	.L12:
 215 000c 00000000 		.word	default_layer_state
 216              		.cfi_endproc
 217              	.LFE9:
 219              		.section	.text.default_layer_xor,"ax",%progbits
 220              		.align	1
 221              		.global	default_layer_xor
 222              		.syntax unified
 223              		.thumb
 224              		.thumb_func
 226              	default_layer_xor:
 227              	.LVL14:
 228              	.LFB10:
  71:quantum/action_layer.c **** /** \brief Default Layer Xor
  72:quantum/action_layer.c ****  *
  73:quantum/action_layer.c ****  * Turns on default layer based on non-matching bits between specifed layer and existing layer stat
  74:quantum/action_layer.c ****  */
  75:quantum/action_layer.c **** void default_layer_xor(layer_state_t state) { default_layer_state_set(default_layer_state ^ state);
 229              		.loc 1 75 45 is_stmt 1 view -0
 230              		.cfi_startproc
 231              		@ args = 0, pretend = 0, frame = 0
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 233              		@ link register save eliminated.
 234              		.loc 1 75 47 view .LVU36
 235 0000 024B     		ldr	r3, .L15
 236 0002 1B68     		ldr	r3, [r3]
 237 0004 5840     		eors	r0, r0, r3
 238              	.LVL15:
 239              		.loc 1 75 47 is_stmt 0 view .LVU37
 240 0006 FFF7FEBF 		b	default_layer_state_set
 241              	.LVL16:
 242              	.L16:
 243 000a 00BF     		.align	2
 244              	.L15:
 245 000c 00000000 		.word	default_layer_state
 246              		.cfi_endproc
 247              	.LFE10:
 249              		.section	.text.layer_state_set_user,"ax",%progbits
 250              		.align	1
 251              		.weak	layer_state_set_user
 252              		.syntax unified
 253              		.thumb
 254              		.thumb_func
 256              	layer_state_set_user:
 257              	.LFB33:
 258              		.cfi_startproc
  76:quantum/action_layer.c **** #endif
  77:quantum/action_layer.c **** 
  78:quantum/action_layer.c **** #ifndef NO_ACTION_LAYER
  79:quantum/action_layer.c **** /** \brief Keymap Layer State
  80:quantum/action_layer.c ****  */
  81:quantum/action_layer.c **** layer_state_t layer_state = 0;
  82:quantum/action_layer.c **** 
  83:quantum/action_layer.c **** /** \brief Layer state set user
  84:quantum/action_layer.c ****  *
  85:quantum/action_layer.c ****  * Runs user code on layer state change
  86:quantum/action_layer.c ****  */
  87:quantum/action_layer.c **** __attribute__((weak)) layer_state_t layer_state_set_user(layer_state_t state) { return state; }
 259              		.loc 1 87 37 is_stmt 1 view -0
 260              		@ args = 0, pretend = 0, frame = 0
 261              		@ frame_needed = 0, uses_anonymous_args = 0
 262              		@ link register save eliminated.
 263 0000 7047     		bx	lr
 264              		.cfi_endproc
 265              	.LFE33:
 267              		.section	.text.layer_state_set_kb,"ax",%progbits
 268              		.align	1
 269              		.weak	layer_state_set_kb
 270              		.syntax unified
 271              		.thumb
 272              		.thumb_func
 274              	layer_state_set_kb:
 275              	.LVL17:
 276              	.LFB12:
  88:quantum/action_layer.c **** 
  89:quantum/action_layer.c **** /** \brief Layer state set keyboard
  90:quantum/action_layer.c ****  *
  91:quantum/action_layer.c ****  * Runs keyboard code on layer state change
  92:quantum/action_layer.c ****  */
  93:quantum/action_layer.c **** __attribute__((weak)) layer_state_t layer_state_set_kb(layer_state_t state) { return layer_state_se
 277              		.loc 1 93 77 view -0
 278              		.cfi_startproc
 279              		@ args = 0, pretend = 0, frame = 0
 280              		@ frame_needed = 0, uses_anonymous_args = 0
 281              		.loc 1 93 79 view .LVU40
 282              		.loc 1 93 77 is_stmt 0 view .LVU41
 283 0000 08B5     		push	{r3, lr}
 284              		.cfi_def_cfa_offset 8
 285              		.cfi_offset 3, -8
 286              		.cfi_offset 14, -4
 287              		.loc 1 93 86 view .LVU42
 288 0002 FFF7FEFF 		bl	layer_state_set_user
 289              	.LVL18:
 290              		.loc 1 93 115 view .LVU43
 291 0006 08BD     		pop	{r3, pc}
 292              		.cfi_endproc
 293              	.LFE12:
 295              		.section	.text.layer_state_set,"ax",%progbits
 296              		.align	1
 297              		.global	layer_state_set
 298              		.syntax unified
 299              		.thumb
 300              		.thumb_func
 302              	layer_state_set:
 303              	.LVL19:
 304              	.LFB13:
  94:quantum/action_layer.c **** 
  95:quantum/action_layer.c **** /** \brief Layer state set
  96:quantum/action_layer.c ****  *
  97:quantum/action_layer.c ****  * Sets the layer to match the specifed state (a bitmask)
  98:quantum/action_layer.c ****  */
  99:quantum/action_layer.c **** void layer_state_set(layer_state_t state) {
 305              		.loc 1 99 43 is_stmt 1 view -0
 306              		.cfi_startproc
 307              		@ args = 0, pretend = 0, frame = 0
 308              		@ frame_needed = 0, uses_anonymous_args = 0
 100:quantum/action_layer.c ****     state = layer_state_set_kb(state);
 309              		.loc 1 100 5 view .LVU45
  99:quantum/action_layer.c ****     state = layer_state_set_kb(state);
 310              		.loc 1 99 43 is_stmt 0 view .LVU46
 311 0000 08B5     		push	{r3, lr}
 312              		.cfi_def_cfa_offset 8
 313              		.cfi_offset 3, -8
 314              		.cfi_offset 14, -4
 315              		.loc 1 100 13 view .LVU47
 316 0002 FFF7FEFF 		bl	layer_state_set_kb
 317              	.LVL20:
 101:quantum/action_layer.c ****     dprint("layer_state: ");
 318              		.loc 1 101 28 is_stmt 1 view .LVU48
 102:quantum/action_layer.c ****     layer_debug();
 319              		.loc 1 102 5 view .LVU49
 103:quantum/action_layer.c ****     dprint(" to ");
 320              		.loc 1 103 19 view .LVU50
 104:quantum/action_layer.c ****     layer_state = state;
 321              		.loc 1 104 5 view .LVU51
 322              		.loc 1 104 17 is_stmt 0 view .LVU52
 323 0006 034B     		ldr	r3, .L20
 324 0008 1860     		str	r0, [r3]
 105:quantum/action_layer.c ****     layer_debug();
 325              		.loc 1 105 5 is_stmt 1 view .LVU53
 106:quantum/action_layer.c ****     dprintln();
 326              		.loc 1 106 15 view .LVU54
 107:quantum/action_layer.c **** #    ifdef STRICT_LAYER_RELEASE
 108:quantum/action_layer.c ****     clear_keyboard_but_mods();  // To avoid stuck keys
 109:quantum/action_layer.c **** #    else
 110:quantum/action_layer.c ****     clear_keyboard_but_mods_and_keys();  // Don't reset held keys
 327              		.loc 1 110 5 view .LVU55
 111:quantum/action_layer.c **** #    endif
 112:quantum/action_layer.c **** }
 328              		.loc 1 112 1 is_stmt 0 view .LVU56
 329 000a BDE80840 		pop	{r3, lr}
 330              		.cfi_restore 14
 331              		.cfi_restore 3
 332              		.cfi_def_cfa_offset 0
 110:quantum/action_layer.c **** #    endif
 333              		.loc 1 110 5 view .LVU57
 334 000e FFF7FEBF 		b	clear_keyboard_but_mods_and_keys
 335              	.LVL21:
 336              	.L21:
 110:quantum/action_layer.c **** #    endif
 337              		.loc 1 110 5 view .LVU58
 338 0012 00BF     		.align	2
 339              	.L20:
 340 0014 00000000 		.word	layer_state
 341              		.cfi_endproc
 342              	.LFE13:
 344              		.section	.text.layer_clear,"ax",%progbits
 345              		.align	1
 346              		.global	layer_clear
 347              		.syntax unified
 348              		.thumb
 349              		.thumb_func
 351              	layer_clear:
 352              	.LFB14:
 113:quantum/action_layer.c **** 
 114:quantum/action_layer.c **** /** \brief Layer clear
 115:quantum/action_layer.c ****  *
 116:quantum/action_layer.c ****  * Turn off all layers
 117:quantum/action_layer.c ****  */
 118:quantum/action_layer.c **** void layer_clear(void) { layer_state_set(0); }
 353              		.loc 1 118 24 is_stmt 1 view -0
 354              		.cfi_startproc
 355              		@ args = 0, pretend = 0, frame = 0
 356              		@ frame_needed = 0, uses_anonymous_args = 0
 357              		@ link register save eliminated.
 358              		.loc 1 118 26 view .LVU60
 359 0000 0020     		movs	r0, #0
 360 0002 FFF7FEBF 		b	layer_state_set
 361              	.LVL22:
 362              		.cfi_endproc
 363              	.LFE14:
 365              		.section	.text.layer_state_is,"ax",%progbits
 366              		.align	1
 367              		.global	layer_state_is
 368              		.syntax unified
 369              		.thumb
 370              		.thumb_func
 372              	layer_state_is:
 373              	.LVL23:
 374              	.LFB15:
 119:quantum/action_layer.c **** 
 120:quantum/action_layer.c **** /** \brief Layer state is
 121:quantum/action_layer.c ****  *
 122:quantum/action_layer.c ****  * Return whether the given state is on (it might still be shadowed by a higher state, though)
 123:quantum/action_layer.c ****  */
 124:quantum/action_layer.c **** bool layer_state_is(uint8_t layer) { return layer_state_cmp(layer_state, layer); }
 375              		.loc 1 124 36 view -0
 376              		.cfi_startproc
 377              		@ args = 0, pretend = 0, frame = 0
 378              		@ frame_needed = 0, uses_anonymous_args = 0
 379              		@ link register save eliminated.
 380              		.loc 1 124 38 view .LVU62
 381              		.loc 1 124 45 is_stmt 0 view .LVU63
 382 0000 054B     		ldr	r3, .L26
 383 0002 1B68     		ldr	r3, [r3]
 384              	.LVL24:
 385              	.LBB12:
 386              	.LBI12:
 125:quantum/action_layer.c **** 
 126:quantum/action_layer.c **** /** \brief Layer state compare
 127:quantum/action_layer.c ****  *
 128:quantum/action_layer.c ****  * Used for comparing layers {mostly used for unit testing}
 129:quantum/action_layer.c ****  */
 130:quantum/action_layer.c **** bool layer_state_cmp(layer_state_t cmp_layer_state, uint8_t layer) {
 387              		.loc 1 130 6 is_stmt 1 view .LVU64
 388              	.LBB13:
 131:quantum/action_layer.c ****     if (!cmp_layer_state) {
 389              		.loc 1 131 5 view .LVU65
 390              		.loc 1 131 8 is_stmt 0 view .LVU66
 391 0004 1BB9     		cbnz	r3, .L24
 132:quantum/action_layer.c ****         return layer == 0;
 392              		.loc 1 132 9 is_stmt 1 view .LVU67
 393              		.loc 1 132 22 is_stmt 0 view .LVU68
 394 0006 B0FA80F0 		clz	r0, r0
 395              	.LVL25:
 396              		.loc 1 132 22 view .LVU69
 397 000a 4009     		lsrs	r0, r0, #5
 398 000c 7047     		bx	lr
 399              	.LVL26:
 400              	.L24:
 133:quantum/action_layer.c ****     }
 134:quantum/action_layer.c ****     return (cmp_layer_state & ((layer_state_t)1 << layer)) != 0;
 401              		.loc 1 134 5 is_stmt 1 view .LVU70
 402              		.loc 1 134 60 is_stmt 0 view .LVU71
 403 000e 23FA00F0 		lsr	r0, r3, r0
 404              	.LVL27:
 405              		.loc 1 134 60 view .LVU72
 406 0012 00F00100 		and	r0, r0, #1
 407              	.LVL28:
 408              		.loc 1 134 60 view .LVU73
 409              	.LBE13:
 410              	.LBE12:
 124:quantum/action_layer.c **** 
 411              		.loc 1 124 82 view .LVU74
 412 0016 7047     		bx	lr
 413              	.L27:
 414              		.align	2
 415              	.L26:
 416 0018 00000000 		.word	layer_state
 417              		.cfi_endproc
 418              	.LFE15:
 420              		.section	.text.layer_state_cmp,"ax",%progbits
 421              		.align	1
 422              		.global	layer_state_cmp
 423              		.syntax unified
 424              		.thumb
 425              		.thumb_func
 427              	layer_state_cmp:
 428              	.LVL29:
 429              	.LFB16:
 130:quantum/action_layer.c ****     if (!cmp_layer_state) {
 430              		.loc 1 130 68 is_stmt 1 view -0
 431              		.cfi_startproc
 432              		@ args = 0, pretend = 0, frame = 0
 433              		@ frame_needed = 0, uses_anonymous_args = 0
 434              		@ link register save eliminated.
 131:quantum/action_layer.c ****         return layer == 0;
 435              		.loc 1 131 5 view .LVU76
 131:quantum/action_layer.c ****         return layer == 0;
 436              		.loc 1 131 8 is_stmt 0 view .LVU77
 437 0000 18B9     		cbnz	r0, .L29
 132:quantum/action_layer.c ****     }
 438              		.loc 1 132 9 is_stmt 1 view .LVU78
 132:quantum/action_layer.c ****     }
 439              		.loc 1 132 22 is_stmt 0 view .LVU79
 440 0002 B1FA81F0 		clz	r0, r1
 441              	.LVL30:
 132:quantum/action_layer.c ****     }
 442              		.loc 1 132 22 view .LVU80
 443 0006 4009     		lsrs	r0, r0, #5
 444 0008 7047     		bx	lr
 445              	.LVL31:
 446              	.L29:
 447              		.loc 1 134 5 is_stmt 1 view .LVU81
 448              		.loc 1 134 60 is_stmt 0 view .LVU82
 449 000a C840     		lsrs	r0, r0, r1
 450              	.LVL32:
 451              		.loc 1 134 60 view .LVU83
 452 000c 00F00100 		and	r0, r0, #1
 135:quantum/action_layer.c **** }
 453              		.loc 1 135 1 view .LVU84
 454 0010 7047     		bx	lr
 455              		.cfi_endproc
 456              	.LFE16:
 458              		.section	.text.layer_move,"ax",%progbits
 459              		.align	1
 460              		.global	layer_move
 461              		.syntax unified
 462              		.thumb
 463              		.thumb_func
 465              	layer_move:
 466              	.LVL33:
 467              	.LFB17:
 136:quantum/action_layer.c **** 
 137:quantum/action_layer.c **** /** \brief Layer move
 138:quantum/action_layer.c ****  *
 139:quantum/action_layer.c ****  * Turns on the given layer and turn off all other layers
 140:quantum/action_layer.c ****  */
 141:quantum/action_layer.c **** void layer_move(uint8_t layer) { layer_state_set((layer_state_t)1 << layer); }
 468              		.loc 1 141 32 is_stmt 1 view -0
 469              		.cfi_startproc
 470              		@ args = 0, pretend = 0, frame = 0
 471              		@ frame_needed = 0, uses_anonymous_args = 0
 472              		@ link register save eliminated.
 473              		.loc 1 141 34 view .LVU86
 474 0000 0123     		movs	r3, #1
 475 0002 03FA00F0 		lsl	r0, r3, r0
 476              	.LVL34:
 477              		.loc 1 141 34 is_stmt 0 view .LVU87
 478 0006 FFF7FEBF 		b	layer_state_set
 479              	.LVL35:
 480              		.cfi_endproc
 481              	.LFE17:
 483              		.section	.text.layer_on,"ax",%progbits
 484              		.align	1
 485              		.global	layer_on
 486              		.syntax unified
 487              		.thumb
 488              		.thumb_func
 490              	layer_on:
 491              	.LVL36:
 492              	.LFB18:
 142:quantum/action_layer.c **** 
 143:quantum/action_layer.c **** /** \brief Layer on
 144:quantum/action_layer.c ****  *
 145:quantum/action_layer.c ****  * Turns on given layer
 146:quantum/action_layer.c ****  */
 147:quantum/action_layer.c **** void layer_on(uint8_t layer) { layer_state_set(layer_state | ((layer_state_t)1 << layer)); }
 493              		.loc 1 147 30 is_stmt 1 view -0
 494              		.cfi_startproc
 495              		@ args = 0, pretend = 0, frame = 0
 496              		@ frame_needed = 0, uses_anonymous_args = 0
 497              		@ link register save eliminated.
 498              		.loc 1 147 32 view .LVU89
 499 0000 034A     		ldr	r2, .L33
 500              		.loc 1 147 80 is_stmt 0 view .LVU90
 501 0002 0123     		movs	r3, #1
 502 0004 8340     		lsls	r3, r3, r0
 503              		.loc 1 147 32 view .LVU91
 504 0006 1068     		ldr	r0, [r2]
 505              	.LVL37:
 506              		.loc 1 147 32 view .LVU92
 507 0008 1843     		orrs	r0, r0, r3
 508 000a FFF7FEBF 		b	layer_state_set
 509              	.LVL38:
 510              	.L34:
 511 000e 00BF     		.align	2
 512              	.L33:
 513 0010 00000000 		.word	layer_state
 514              		.cfi_endproc
 515              	.LFE18:
 517              		.section	.text.layer_off,"ax",%progbits
 518              		.align	1
 519              		.global	layer_off
 520              		.syntax unified
 521              		.thumb
 522              		.thumb_func
 524              	layer_off:
 525              	.LVL39:
 526              	.LFB19:
 148:quantum/action_layer.c **** 
 149:quantum/action_layer.c **** /** \brief Layer off
 150:quantum/action_layer.c ****  *
 151:quantum/action_layer.c ****  * Turns off given layer
 152:quantum/action_layer.c ****  */
 153:quantum/action_layer.c **** void layer_off(uint8_t layer) { layer_state_set(layer_state & ~((layer_state_t)1 << layer)); }
 527              		.loc 1 153 31 is_stmt 1 view -0
 528              		.cfi_startproc
 529              		@ args = 0, pretend = 0, frame = 0
 530              		@ frame_needed = 0, uses_anonymous_args = 0
 531              		@ link register save eliminated.
 532              		.loc 1 153 33 view .LVU94
 533 0000 034A     		ldr	r2, .L36
 534              		.loc 1 153 82 is_stmt 0 view .LVU95
 535 0002 0123     		movs	r3, #1
 536 0004 8340     		lsls	r3, r3, r0
 537              		.loc 1 153 33 view .LVU96
 538 0006 1068     		ldr	r0, [r2]
 539              	.LVL40:
 540              		.loc 1 153 33 view .LVU97
 541 0008 20EA0300 		bic	r0, r0, r3
 542 000c FFF7FEBF 		b	layer_state_set
 543              	.LVL41:
 544              	.L37:
 545              		.align	2
 546              	.L36:
 547 0010 00000000 		.word	layer_state
 548              		.cfi_endproc
 549              	.LFE19:
 551              		.section	.text.layer_invert,"ax",%progbits
 552              		.align	1
 553              		.global	layer_invert
 554              		.syntax unified
 555              		.thumb
 556              		.thumb_func
 558              	layer_invert:
 559              	.LVL42:
 560              	.LFB20:
 154:quantum/action_layer.c **** 
 155:quantum/action_layer.c **** /** \brief Layer invert
 156:quantum/action_layer.c ****  *
 157:quantum/action_layer.c ****  * Toggle the given layer (set it if it's unset, or unset it if it's set)
 158:quantum/action_layer.c ****  */
 159:quantum/action_layer.c **** void layer_invert(uint8_t layer) { layer_state_set(layer_state ^ ((layer_state_t)1 << layer)); }
 561              		.loc 1 159 34 is_stmt 1 view -0
 562              		.cfi_startproc
 563              		@ args = 0, pretend = 0, frame = 0
 564              		@ frame_needed = 0, uses_anonymous_args = 0
 565              		@ link register save eliminated.
 566              		.loc 1 159 36 view .LVU99
 567 0000 034A     		ldr	r2, .L39
 568              		.loc 1 159 84 is_stmt 0 view .LVU100
 569 0002 0123     		movs	r3, #1
 570 0004 8340     		lsls	r3, r3, r0
 571              		.loc 1 159 36 view .LVU101
 572 0006 1068     		ldr	r0, [r2]
 573              	.LVL43:
 574              		.loc 1 159 36 view .LVU102
 575 0008 5840     		eors	r0, r0, r3
 576 000a FFF7FEBF 		b	layer_state_set
 577              	.LVL44:
 578              	.L40:
 579 000e 00BF     		.align	2
 580              	.L39:
 581 0010 00000000 		.word	layer_state
 582              		.cfi_endproc
 583              	.LFE20:
 585              		.section	.text.layer_or,"ax",%progbits
 586              		.align	1
 587              		.global	layer_or
 588              		.syntax unified
 589              		.thumb
 590              		.thumb_func
 592              	layer_or:
 593              	.LVL45:
 594              	.LFB21:
 160:quantum/action_layer.c **** 
 161:quantum/action_layer.c **** /** \brief Layer or
 162:quantum/action_layer.c ****  *
 163:quantum/action_layer.c ****  * Turns on layers based on matching bits between specifed layer and existing layer state
 164:quantum/action_layer.c ****  */
 165:quantum/action_layer.c **** void layer_or(layer_state_t state) { layer_state_set(layer_state | state); }
 595              		.loc 1 165 36 is_stmt 1 view -0
 596              		.cfi_startproc
 597              		@ args = 0, pretend = 0, frame = 0
 598              		@ frame_needed = 0, uses_anonymous_args = 0
 599              		@ link register save eliminated.
 600              		.loc 1 165 38 view .LVU104
 601 0000 024B     		ldr	r3, .L42
 602 0002 1B68     		ldr	r3, [r3]
 603 0004 1843     		orrs	r0, r0, r3
 604              	.LVL46:
 605              		.loc 1 165 38 is_stmt 0 view .LVU105
 606 0006 FFF7FEBF 		b	layer_state_set
 607              	.LVL47:
 608              	.L43:
 609 000a 00BF     		.align	2
 610              	.L42:
 611 000c 00000000 		.word	layer_state
 612              		.cfi_endproc
 613              	.LFE21:
 615              		.section	.text.layer_and,"ax",%progbits
 616              		.align	1
 617              		.global	layer_and
 618              		.syntax unified
 619              		.thumb
 620              		.thumb_func
 622              	layer_and:
 623              	.LVL48:
 624              	.LFB22:
 166:quantum/action_layer.c **** /** \brief Layer and
 167:quantum/action_layer.c ****  *
 168:quantum/action_layer.c ****  * Turns on layers based on matching enabled bits between specifed layer and existing layer state
 169:quantum/action_layer.c ****  */
 170:quantum/action_layer.c **** void layer_and(layer_state_t state) { layer_state_set(layer_state & state); }
 625              		.loc 1 170 37 is_stmt 1 view -0
 626              		.cfi_startproc
 627              		@ args = 0, pretend = 0, frame = 0
 628              		@ frame_needed = 0, uses_anonymous_args = 0
 629              		@ link register save eliminated.
 630              		.loc 1 170 39 view .LVU107
 631 0000 024B     		ldr	r3, .L45
 632 0002 1B68     		ldr	r3, [r3]
 633 0004 1840     		ands	r0, r0, r3
 634              	.LVL49:
 635              		.loc 1 170 39 is_stmt 0 view .LVU108
 636 0006 FFF7FEBF 		b	layer_state_set
 637              	.LVL50:
 638              	.L46:
 639 000a 00BF     		.align	2
 640              	.L45:
 641 000c 00000000 		.word	layer_state
 642              		.cfi_endproc
 643              	.LFE22:
 645              		.section	.text.layer_xor,"ax",%progbits
 646              		.align	1
 647              		.global	layer_xor
 648              		.syntax unified
 649              		.thumb
 650              		.thumb_func
 652              	layer_xor:
 653              	.LVL51:
 654              	.LFB23:
 171:quantum/action_layer.c **** /** \brief Layer xor
 172:quantum/action_layer.c ****  *
 173:quantum/action_layer.c ****  * Turns on layers based on non-matching bits between specifed layer and existing layer state
 174:quantum/action_layer.c ****  */
 175:quantum/action_layer.c **** void layer_xor(layer_state_t state) { layer_state_set(layer_state ^ state); }
 655              		.loc 1 175 37 is_stmt 1 view -0
 656              		.cfi_startproc
 657              		@ args = 0, pretend = 0, frame = 0
 658              		@ frame_needed = 0, uses_anonymous_args = 0
 659              		@ link register save eliminated.
 660              		.loc 1 175 39 view .LVU110
 661 0000 024B     		ldr	r3, .L48
 662 0002 1B68     		ldr	r3, [r3]
 663 0004 5840     		eors	r0, r0, r3
 664              	.LVL52:
 665              		.loc 1 175 39 is_stmt 0 view .LVU111
 666 0006 FFF7FEBF 		b	layer_state_set
 667              	.LVL53:
 668              	.L49:
 669 000a 00BF     		.align	2
 670              	.L48:
 671 000c 00000000 		.word	layer_state
 672              		.cfi_endproc
 673              	.LFE23:
 675              		.section	.text.layer_debug,"ax",%progbits
 676              		.align	1
 677              		.global	layer_debug
 678              		.syntax unified
 679              		.thumb
 680              		.thumb_func
 682              	layer_debug:
 683              	.LFB31:
 684              		.cfi_startproc
 176:quantum/action_layer.c **** 
 177:quantum/action_layer.c **** /** \brief Layer debug printing
 178:quantum/action_layer.c ****  *
 179:quantum/action_layer.c ****  * Print out the hex value of the 32-bit layer state, as well as the value of the highest bit.
 180:quantum/action_layer.c ****  */
 181:quantum/action_layer.c **** void layer_debug(void) { dprintf("%08lX(%u)", layer_state, get_highest_layer(layer_state)); }
 685              		.loc 1 181 6 is_stmt 1 view -0
 686              		@ args = 0, pretend = 0, frame = 0
 687              		@ frame_needed = 0, uses_anonymous_args = 0
 688              		@ link register save eliminated.
 689 0000 7047     		bx	lr
 690              		.cfi_endproc
 691              	.LFE31:
 693              		.section	.text.update_source_layers_cache,"ax",%progbits
 694              		.align	1
 695              		.global	update_source_layers_cache
 696              		.syntax unified
 697              		.thumb
 698              		.thumb_func
 700              	update_source_layers_cache:
 701              	.LVL54:
 702              	.LFB25:
 182:quantum/action_layer.c **** #endif
 183:quantum/action_layer.c **** 
 184:quantum/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 185:quantum/action_layer.c **** /** \brief source layer cache
 186:quantum/action_layer.c ****  */
 187:quantum/action_layer.c **** 
 188:quantum/action_layer.c **** uint8_t source_layers_cache[(MATRIX_ROWS * MATRIX_COLS + 7) / 8][MAX_LAYER_BITS] = {{0}};
 189:quantum/action_layer.c **** 
 190:quantum/action_layer.c **** /** \brief update source layers cache
 191:quantum/action_layer.c ****  *
 192:quantum/action_layer.c ****  * Updates the cached keys when changing layers
 193:quantum/action_layer.c ****  */
 194:quantum/action_layer.c **** void update_source_layers_cache(keypos_t key, uint8_t layer) {
 703              		.loc 1 194 62 view -0
 704              		.cfi_startproc
 705              		@ args = 0, pretend = 0, frame = 8
 706              		@ frame_needed = 0, uses_anonymous_args = 0
 195:quantum/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 707              		.loc 1 195 5 view .LVU114
 708              		.loc 1 195 41 is_stmt 0 view .LVU115
 709 0000 C0F30723 		ubfx	r3, r0, #8, #8
 710 0004 03EB4303 		add	r3, r3, r3, lsl #1
 711              		.loc 1 195 19 view .LVU116
 712 0008 00EB4303 		add	r3, r0, r3, lsl #1
 713              	.LVL55:
 196:quantum/action_layer.c ****     const uint8_t storage_row = key_number / 8;
 714              		.loc 1 196 5 is_stmt 1 view .LVU117
 197:quantum/action_layer.c ****     const uint8_t storage_bit = key_number % 8;
 715              		.loc 1 197 5 view .LVU118
 198:quantum/action_layer.c **** 
 199:quantum/action_layer.c ****     for (uint8_t bit_number = 0; bit_number < MAX_LAYER_BITS; bit_number++) {
 716              		.loc 1 199 5 view .LVU119
 717              	.LBB14:
 718              		.loc 1 199 10 view .LVU120
 719              		.loc 1 199 45 view .LVU121
 720              	.LBE14:
 194:quantum/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 721              		.loc 1 194 62 is_stmt 0 view .LVU122
 722 000c 37B5     		push	{r0, r1, r2, r4, r5, lr}
 723              		.cfi_def_cfa_offset 24
 724              		.cfi_offset 4, -12
 725              		.cfi_offset 5, -8
 726              		.cfi_offset 14, -4
 727              	.LBB15:
 200:quantum/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 728              		.loc 1 200 149 view .LVU123
 729 000e 03F00702 		and	r2, r3, #7
 730 0012 0120     		movs	r0, #1
 731 0014 9040     		lsls	r0, r0, r2
 732 0016 C3F3C403 		ubfx	r3, r3, #3, #5
 733              	.LVL56:
 734              		.loc 1 200 149 view .LVU124
 735 001a 0A4A     		ldr	r2, .L54
 736 001c 03EB8303 		add	r3, r3, r3, lsl #2
 737              		.loc 1 200 143 view .LVU125
 738 0020 C0B2     		uxtb	r0, r0
 739 0022 1344     		add	r3, r3, r2
 740 0024 0024     		movs	r4, #0
 741              	.LVL57:
 742              	.L52:
 743              		.loc 1 200 9 is_stmt 1 discriminator 3 view .LVU126
 744              		.loc 1 200 41 is_stmt 0 discriminator 3 view .LVU127
 745 0026 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 746              		.loc 1 200 89 discriminator 3 view .LVU128
 747 0028 21FA04F2 		lsr	r2, r1, r4
 748              		.loc 1 200 95 discriminator 3 view .LVU129
 749 002c 42F30002 		sbfx	r2, r2, #0, #1
 750              		.loc 1 200 143 discriminator 3 view .LVU130
 751 0030 6A40     		eors	r2, r2, r5
 752 0032 0240     		ands	r2, r2, r0
 199:quantum/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 753              		.loc 1 199 45 discriminator 3 view .LVU131
 754 0034 0134     		adds	r4, r4, #1
 755              	.LVL58:
 756              		.loc 1 200 54 discriminator 3 view .LVU132
 757 0036 5540     		eors	r5, r5, r2
 199:quantum/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 758              		.loc 1 199 45 discriminator 3 view .LVU133
 759 0038 052C     		cmp	r4, #5
 760              		.loc 1 200 54 discriminator 3 view .LVU134
 761 003a 03F8015B 		strb	r5, [r3], #1
 199:quantum/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 762              		.loc 1 199 73 is_stmt 1 discriminator 3 view .LVU135
 763              	.LVL59:
 199:quantum/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 764              		.loc 1 199 45 discriminator 3 view .LVU136
 765 003e F2D1     		bne	.L52
 766              	.LBE15:
 201:quantum/action_layer.c ****     }
 202:quantum/action_layer.c **** }
 767              		.loc 1 202 1 is_stmt 0 view .LVU137
 768 0040 03B0     		add	sp, sp, #12
 769              		.cfi_def_cfa_offset 12
 770              		@ sp needed
 771 0042 30BD     		pop	{r4, r5, pc}
 772              	.L55:
 773              		.align	2
 774              	.L54:
 775 0044 00000000 		.word	source_layers_cache
 776              		.cfi_endproc
 777              	.LFE25:
 779              		.section	.text.read_source_layers_cache,"ax",%progbits
 780              		.align	1
 781              		.global	read_source_layers_cache
 782              		.syntax unified
 783              		.thumb
 784              		.thumb_func
 786              	read_source_layers_cache:
 787              	.LFB26:
 203:quantum/action_layer.c **** 
 204:quantum/action_layer.c **** /** \brief read source layers cache
 205:quantum/action_layer.c ****  *
 206:quantum/action_layer.c ****  * reads the cached keys stored when the layer was changed
 207:quantum/action_layer.c ****  */
 208:quantum/action_layer.c **** uint8_t read_source_layers_cache(keypos_t key) {
 788              		.loc 1 208 48 is_stmt 1 view -0
 789              		.cfi_startproc
 790              		@ args = 0, pretend = 0, frame = 8
 791              		@ frame_needed = 0, uses_anonymous_args = 0
 209:quantum/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 792              		.loc 1 209 5 view .LVU139
 793              		.loc 1 209 41 is_stmt 0 view .LVU140
 794 0000 C0F30723 		ubfx	r3, r0, #8, #8
 795 0004 03EB4303 		add	r3, r3, r3, lsl #1
 796              		.loc 1 209 19 view .LVU141
 797 0008 00EB4303 		add	r3, r0, r3, lsl #1
 798              	.LVL60:
 210:quantum/action_layer.c ****     const uint8_t storage_row = key_number / 8;
 799              		.loc 1 210 5 is_stmt 1 view .LVU142
 211:quantum/action_layer.c ****     const uint8_t storage_bit = key_number % 8;
 800              		.loc 1 211 5 view .LVU143
 208:quantum/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 801              		.loc 1 208 48 is_stmt 0 view .LVU144
 802 000c 13B5     		push	{r0, r1, r4, lr}
 803              		.cfi_def_cfa_offset 16
 804              		.cfi_offset 4, -8
 805              		.cfi_offset 14, -4
 806 000e 0B4A     		ldr	r2, .L59
 807              		.loc 1 211 19 view .LVU145
 808 0010 03F00704 		and	r4, r3, #7
 809              	.LVL61:
 212:quantum/action_layer.c ****     uint8_t       layer       = 0;
 810              		.loc 1 212 5 is_stmt 1 view .LVU146
 213:quantum/action_layer.c **** 
 214:quantum/action_layer.c ****     for (uint8_t bit_number = 0; bit_number < MAX_LAYER_BITS; bit_number++) {
 811              		.loc 1 214 5 view .LVU147
 812              	.LBB16:
 813              		.loc 1 214 10 view .LVU148
 814              		.loc 1 214 45 view .LVU149
 815 0014 C3F3C403 		ubfx	r3, r3, #3, #5
 816              	.LVL62:
 817              		.loc 1 214 45 is_stmt 0 view .LVU150
 818 0018 03EB8303 		add	r3, r3, r3, lsl #2
 819              	.LBE16:
 211:quantum/action_layer.c ****     uint8_t       layer       = 0;
 820              		.loc 1 211 19 view .LVU151
 821 001c 0021     		movs	r1, #0
 822 001e 1344     		add	r3, r3, r2
 212:quantum/action_layer.c ****     uint8_t       layer       = 0;
 823              		.loc 1 212 19 view .LVU152
 824 0020 0846     		mov	r0, r1
 825              	.LVL63:
 826              	.L57:
 827              	.LBB17:
 215:quantum/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 828              		.loc 1 215 9 is_stmt 1 discriminator 3 view .LVU153
 829              		.loc 1 215 52 is_stmt 0 discriminator 3 view .LVU154
 830 0022 13F8012B 		ldrb	r2, [r3], #1	@ zero_extendqisi2
 831              		.loc 1 215 88 discriminator 3 view .LVU155
 832 0026 E240     		lsrs	r2, r2, r4
 833 0028 02F00102 		and	r2, r2, #1
 834              		.loc 1 215 94 discriminator 3 view .LVU156
 835 002c 8A40     		lsls	r2, r2, r1
 214:quantum/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 836              		.loc 1 214 45 discriminator 3 view .LVU157
 837 002e 0131     		adds	r1, r1, #1
 838              	.LVL64:
 839              		.loc 1 215 15 discriminator 3 view .LVU158
 840 0030 1043     		orrs	r0, r0, r2
 841              	.LVL65:
 214:quantum/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 842              		.loc 1 214 45 discriminator 3 view .LVU159
 843 0032 0529     		cmp	r1, #5
 844              		.loc 1 215 15 discriminator 3 view .LVU160
 845 0034 C0B2     		uxtb	r0, r0
 846              	.LVL66:
 214:quantum/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 847              		.loc 1 214 73 is_stmt 1 discriminator 3 view .LVU161
 214:quantum/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 848              		.loc 1 214 45 discriminator 3 view .LVU162
 849 0036 F4D1     		bne	.L57
 850              	.LBE17:
 216:quantum/action_layer.c ****     }
 217:quantum/action_layer.c **** 
 218:quantum/action_layer.c ****     return layer;
 851              		.loc 1 218 5 view .LVU163
 219:quantum/action_layer.c **** }
 852              		.loc 1 219 1 is_stmt 0 view .LVU164
 853 0038 02B0     		add	sp, sp, #8
 854              		.cfi_def_cfa_offset 8
 855              		@ sp needed
 856 003a 10BD     		pop	{r4, pc}
 857              	.LVL67:
 858              	.L60:
 859              		.loc 1 219 1 view .LVU165
 860              		.align	2
 861              	.L59:
 862 003c 00000000 		.word	source_layers_cache
 863              		.cfi_endproc
 864              	.LFE26:
 866              		.section	.text.layer_switch_get_layer,"ax",%progbits
 867              		.align	1
 868              		.global	layer_switch_get_layer
 869              		.syntax unified
 870              		.thumb
 871              		.thumb_func
 873              	layer_switch_get_layer:
 874              	.LFB28:
 220:quantum/action_layer.c **** #endif
 221:quantum/action_layer.c **** 
 222:quantum/action_layer.c **** /** \brief Store or get action (FIXME: Needs better summary)
 223:quantum/action_layer.c ****  *
 224:quantum/action_layer.c ****  * Make sure the action triggered when the key is released is the same
 225:quantum/action_layer.c ****  * one as the one triggered on press. It's important for the mod keys
 226:quantum/action_layer.c ****  * when the layer is switched after the down event but before the up
 227:quantum/action_layer.c ****  * event as they may get stuck otherwise.
 228:quantum/action_layer.c ****  */
 229:quantum/action_layer.c **** action_t store_or_get_action(bool pressed, keypos_t key) {
 230:quantum/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 231:quantum/action_layer.c ****     if (disable_action_cache) {
 232:quantum/action_layer.c ****         return layer_switch_get_action(key);
 233:quantum/action_layer.c ****     }
 234:quantum/action_layer.c **** 
 235:quantum/action_layer.c ****     uint8_t layer;
 236:quantum/action_layer.c **** 
 237:quantum/action_layer.c ****     if (pressed) {
 238:quantum/action_layer.c ****         layer = layer_switch_get_layer(key);
 239:quantum/action_layer.c ****         update_source_layers_cache(key, layer);
 240:quantum/action_layer.c ****     } else {
 241:quantum/action_layer.c ****         layer = read_source_layers_cache(key);
 242:quantum/action_layer.c ****     }
 243:quantum/action_layer.c ****     return action_for_key(layer, key);
 244:quantum/action_layer.c **** #else
 245:quantum/action_layer.c ****     return layer_switch_get_action(key);
 246:quantum/action_layer.c **** #endif
 247:quantum/action_layer.c **** }
 248:quantum/action_layer.c **** 
 249:quantum/action_layer.c **** /** \brief Layer switch get layer
 250:quantum/action_layer.c ****  *
 251:quantum/action_layer.c ****  * Gets the layer based on key info
 252:quantum/action_layer.c ****  */
 253:quantum/action_layer.c **** uint8_t layer_switch_get_layer(keypos_t key) {
 875              		.loc 1 253 46 is_stmt 1 view -0
 876              		.cfi_startproc
 877              		@ args = 0, pretend = 0, frame = 8
 878              		@ frame_needed = 0, uses_anonymous_args = 0
 254:quantum/action_layer.c **** #ifndef NO_ACTION_LAYER
 255:quantum/action_layer.c ****     action_t action;
 879              		.loc 1 255 5 view .LVU167
 256:quantum/action_layer.c ****     action.code = ACTION_TRANSPARENT;
 880              		.loc 1 256 5 view .LVU168
 881              	.LVL68:
 257:quantum/action_layer.c **** 
 258:quantum/action_layer.c ****     layer_state_t layers = layer_state | default_layer_state;
 882              		.loc 1 258 5 view .LVU169
 883              		.loc 1 258 19 is_stmt 0 view .LVU170
 884 0000 0D4B     		ldr	r3, .L70
 253:quantum/action_layer.c **** #ifndef NO_ACTION_LAYER
 885              		.loc 1 253 46 view .LVU171
 886 0002 73B5     		push	{r0, r1, r4, r5, r6, lr}
 887              		.cfi_def_cfa_offset 24
 888              		.cfi_offset 4, -16
 889              		.cfi_offset 5, -12
 890              		.cfi_offset 6, -8
 891              		.cfi_offset 14, -4
 892              		.loc 1 258 19 view .LVU172
 893 0004 1E68     		ldr	r6, [r3]
 894 0006 0D4B     		ldr	r3, .L70+4
 253:quantum/action_layer.c **** #ifndef NO_ACTION_LAYER
 895              		.loc 1 253 46 view .LVU173
 896 0008 ADF80400 		strh	r0, [sp, #4]	@ movhi
 897              		.loc 1 258 19 view .LVU174
 898 000c 1B68     		ldr	r3, [r3]
 899 000e 1F24     		movs	r4, #31
 900 0010 1E43     		orrs	r6, r6, r3
 901              	.LVL69:
 259:quantum/action_layer.c ****     /* check top layer first */
 260:quantum/action_layer.c ****     for (int8_t i = MAX_LAYER - 1; i >= 0; i--) {
 902              		.loc 1 260 5 is_stmt 1 view .LVU175
 903              	.LBB18:
 904              		.loc 1 260 10 view .LVU176
 905              		.loc 1 260 38 view .LVU177
 906              	.L63:
 261:quantum/action_layer.c ****         if (layers & ((layer_state_t)1 << i)) {
 907              		.loc 1 261 9 view .LVU178
 908              		.loc 1 261 13 is_stmt 0 view .LVU179
 909 0012 26FA04F3 		lsr	r3, r6, r4
 910              		.loc 1 261 12 view .LVU180
 911 0016 DB07     		lsls	r3, r3, #31
 912 0018 05D4     		bmi	.L62
 913              	.L65:
 260:quantum/action_layer.c ****         if (layers & ((layer_state_t)1 << i)) {
 914              		.loc 1 260 45 is_stmt 1 view .LVU181
 915              	.LVL70:
 260:quantum/action_layer.c ****         if (layers & ((layer_state_t)1 << i)) {
 916              		.loc 1 260 38 view .LVU182
 917 001a 013C     		subs	r4, r4, #1
 918              	.LVL71:
 260:quantum/action_layer.c ****         if (layers & ((layer_state_t)1 << i)) {
 919              		.loc 1 260 38 is_stmt 0 view .LVU183
 920 001c F9D2     		bcs	.L63
 921              	.LBE18:
 262:quantum/action_layer.c ****             action = action_for_key(i, key);
 263:quantum/action_layer.c ****             if (action.code != ACTION_TRANSPARENT) {
 264:quantum/action_layer.c ****                 return i;
 265:quantum/action_layer.c ****             }
 266:quantum/action_layer.c ****         }
 267:quantum/action_layer.c ****     }
 268:quantum/action_layer.c ****     /* fall back to layer 0 */
 269:quantum/action_layer.c ****     return 0;
 922              		.loc 1 269 12 view .LVU184
 923 001e 0025     		movs	r5, #0
 924              	.LVL72:
 925              	.L64:
 270:quantum/action_layer.c **** #else
 271:quantum/action_layer.c ****     return get_highest_layer(default_layer_state);
 272:quantum/action_layer.c **** #endif
 273:quantum/action_layer.c **** }
 926              		.loc 1 273 1 view .LVU185
 927 0020 2846     		mov	r0, r5
 928              	.LVL73:
 929              		.loc 1 273 1 view .LVU186
 930 0022 02B0     		add	sp, sp, #8
 931              		.cfi_remember_state
 932              		.cfi_def_cfa_offset 16
 933              		@ sp needed
 934 0024 70BD     		pop	{r4, r5, r6, pc}
 935              	.LVL74:
 936              	.L62:
 937              		.cfi_restore_state
 938              		.loc 1 273 1 view .LVU187
 939 0026 E5B2     		uxtb	r5, r4
 940              	.LBB19:
 262:quantum/action_layer.c ****             action = action_for_key(i, key);
 941              		.loc 1 262 13 is_stmt 1 view .LVU188
 262:quantum/action_layer.c ****             action = action_for_key(i, key);
 942              		.loc 1 262 22 is_stmt 0 view .LVU189
 943 0028 0199     		ldr	r1, [sp, #4]
 944 002a 2846     		mov	r0, r5
 945              	.LVL75:
 262:quantum/action_layer.c ****             action = action_for_key(i, key);
 946              		.loc 1 262 22 view .LVU190
 947 002c FFF7FEFF 		bl	action_for_key
 948              	.LVL76:
 263:quantum/action_layer.c ****                 return i;
 949              		.loc 1 263 13 is_stmt 1 view .LVU191
 263:quantum/action_layer.c ****                 return i;
 950              		.loc 1 263 16 is_stmt 0 view .LVU192
 951 0030 80B2     		uxth	r0, r0
 952              	.LVL77:
 263:quantum/action_layer.c ****                 return i;
 953              		.loc 1 263 16 view .LVU193
 954 0032 0128     		cmp	r0, #1
 955 0034 F1D0     		beq	.L65
 956 0036 F3E7     		b	.L64
 957              	.L71:
 958              		.align	2
 959              	.L70:
 960 0038 00000000 		.word	layer_state
 961 003c 00000000 		.word	default_layer_state
 962              	.LBE19:
 963              		.cfi_endproc
 964              	.LFE28:
 966              		.section	.text.layer_switch_get_action,"ax",%progbits
 967              		.align	1
 968              		.global	layer_switch_get_action
 969              		.syntax unified
 970              		.thumb
 971              		.thumb_func
 973              	layer_switch_get_action:
 974              	.LFB29:
 274:quantum/action_layer.c **** 
 275:quantum/action_layer.c **** /** \brief Layer switch get layer
 276:quantum/action_layer.c ****  *
 277:quantum/action_layer.c ****  * Gets action code based on key position
 278:quantum/action_layer.c ****  */
 279:quantum/action_layer.c **** action_t layer_switch_get_action(keypos_t key) { return action_for_key(layer_switch_get_layer(key),
 975              		.loc 1 279 48 is_stmt 1 view -0
 976              		.cfi_startproc
 977              		@ args = 0, pretend = 0, frame = 8
 978              		@ frame_needed = 0, uses_anonymous_args = 0
 979              		.loc 1 279 50 view .LVU195
 980              		.loc 1 279 48 is_stmt 0 view .LVU196
 981 0000 07B5     		push	{r0, r1, r2, lr}
 982              		.cfi_def_cfa_offset 16
 983              		.cfi_offset 14, -4
 984              		.loc 1 279 48 view .LVU197
 985 0002 ADF80400 		strh	r0, [sp, #4]	@ movhi
 986              		.loc 1 279 57 view .LVU198
 987 0006 0198     		ldr	r0, [sp, #4]
 988 0008 FFF7FEFF 		bl	layer_switch_get_layer
 989              	.LVL78:
 990 000c 0199     		ldr	r1, [sp, #4]
 991              		.loc 1 279 107 view .LVU199
 992 000e 03B0     		add	sp, sp, #12
 993              		.cfi_def_cfa_offset 4
 994              		@ sp needed
 995 0010 5DF804EB 		ldr	lr, [sp], #4
 996              		.cfi_restore 14
 997              		.cfi_def_cfa_offset 0
 998              		.loc 1 279 57 view .LVU200
 999 0014 FFF7FEBF 		b	action_for_key
 1000              	.LVL79:
 1001              		.cfi_endproc
 1002              	.LFE29:
 1004              		.section	.text.store_or_get_action,"ax",%progbits
 1005              		.align	1
 1006              		.global	store_or_get_action
 1007              		.syntax unified
 1008              		.thumb
 1009              		.thumb_func
 1011              	store_or_get_action:
 1012              	.LVL80:
 1013              	.LFB27:
 229:quantum/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 1014              		.loc 1 229 58 is_stmt 1 view -0
 1015              		.cfi_startproc
 1016              		@ args = 0, pretend = 0, frame = 8
 1017              		@ frame_needed = 0, uses_anonymous_args = 0
 231:quantum/action_layer.c ****         return layer_switch_get_action(key);
 1018              		.loc 1 231 5 view .LVU202
 229:quantum/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 1019              		.loc 1 229 58 is_stmt 0 view .LVU203
 1020 0000 13B5     		push	{r0, r1, r4, lr}
 1021              		.cfi_def_cfa_offset 16
 1022              		.cfi_offset 4, -8
 1023              		.cfi_offset 14, -4
 231:quantum/action_layer.c ****         return layer_switch_get_action(key);
 1024              		.loc 1 231 9 view .LVU204
 1025 0002 104B     		ldr	r3, .L77
 229:quantum/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 1026              		.loc 1 229 58 view .LVU205
 1027 0004 ADF80410 		strh	r1, [sp, #4]	@ movhi
 231:quantum/action_layer.c ****         return layer_switch_get_action(key);
 1028              		.loc 1 231 8 view .LVU206
 1029 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1030 000a 2BB1     		cbz	r3, .L74
 232:quantum/action_layer.c ****     }
 1031              		.loc 1 232 9 is_stmt 1 view .LVU207
 232:quantum/action_layer.c ****     }
 1032              		.loc 1 232 16 is_stmt 0 view .LVU208
 1033 000c 0198     		ldr	r0, [sp, #4]
 1034              	.LVL81:
 247:quantum/action_layer.c **** 
 1035              		.loc 1 247 1 view .LVU209
 1036 000e 02B0     		add	sp, sp, #8
 1037              		.cfi_remember_state
 1038              		.cfi_def_cfa_offset 8
 1039              		@ sp needed
 1040 0010 BDE81040 		pop	{r4, lr}
 1041              		.cfi_restore 14
 1042              		.cfi_restore 4
 1043              		.cfi_def_cfa_offset 0
 232:quantum/action_layer.c ****     }
 1044              		.loc 1 232 16 view .LVU210
 1045 0014 FFF7FEBF 		b	layer_switch_get_action
 1046              	.LVL82:
 1047              	.L74:
 1048              		.cfi_restore_state
 235:quantum/action_layer.c **** 
 1049              		.loc 1 235 5 is_stmt 1 view .LVU211
 237:quantum/action_layer.c ****         layer = layer_switch_get_layer(key);
 1050              		.loc 1 237 5 view .LVU212
 237:quantum/action_layer.c ****         layer = layer_switch_get_layer(key);
 1051              		.loc 1 237 8 is_stmt 0 view .LVU213
 1052 0018 70B1     		cbz	r0, .L75
 238:quantum/action_layer.c ****         update_source_layers_cache(key, layer);
 1053              		.loc 1 238 9 is_stmt 1 view .LVU214
 238:quantum/action_layer.c ****         update_source_layers_cache(key, layer);
 1054              		.loc 1 238 17 is_stmt 0 view .LVU215
 1055 001a 0198     		ldr	r0, [sp, #4]
 1056              	.LVL83:
 238:quantum/action_layer.c ****         update_source_layers_cache(key, layer);
 1057              		.loc 1 238 17 view .LVU216
 1058 001c FFF7FEFF 		bl	layer_switch_get_layer
 1059              	.LVL84:
 1060 0020 0446     		mov	r4, r0
 1061              	.LVL85:
 239:quantum/action_layer.c ****     } else {
 1062              		.loc 1 239 9 is_stmt 1 view .LVU217
 1063 0022 0146     		mov	r1, r0
 1064 0024 0198     		ldr	r0, [sp, #4]
 1065              	.LVL86:
 239:quantum/action_layer.c ****     } else {
 1066              		.loc 1 239 9 is_stmt 0 view .LVU218
 1067 0026 FFF7FEFF 		bl	update_source_layers_cache
 1068              	.LVL87:
 1069              	.L76:
 243:quantum/action_layer.c **** #else
 1070              		.loc 1 243 5 is_stmt 1 view .LVU219
 243:quantum/action_layer.c **** #else
 1071              		.loc 1 243 12 is_stmt 0 view .LVU220
 1072 002a 0199     		ldr	r1, [sp, #4]
 1073 002c 2046     		mov	r0, r4
 247:quantum/action_layer.c **** 
 1074              		.loc 1 247 1 view .LVU221
 1075 002e 02B0     		add	sp, sp, #8
 1076              		.cfi_remember_state
 1077              		.cfi_def_cfa_offset 8
 1078              		@ sp needed
 1079 0030 BDE81040 		pop	{r4, lr}
 1080              		.cfi_restore 14
 1081              		.cfi_restore 4
 1082              		.cfi_def_cfa_offset 0
 1083              	.LVL88:
 243:quantum/action_layer.c **** #else
 1084              		.loc 1 243 12 view .LVU222
 1085 0034 FFF7FEBF 		b	action_for_key
 1086              	.LVL89:
 1087              	.L75:
 1088              		.cfi_restore_state
 241:quantum/action_layer.c ****     }
 1089              		.loc 1 241 9 is_stmt 1 view .LVU223
 241:quantum/action_layer.c ****     }
 1090              		.loc 1 241 17 is_stmt 0 view .LVU224
 1091 0038 0198     		ldr	r0, [sp, #4]
 1092              	.LVL90:
 241:quantum/action_layer.c ****     }
 1093              		.loc 1 241 17 view .LVU225
 1094 003a FFF7FEFF 		bl	read_source_layers_cache
 1095              	.LVL91:
 1096 003e 0446     		mov	r4, r0
 1097              	.LVL92:
 241:quantum/action_layer.c ****     }
 1098              		.loc 1 241 17 view .LVU226
 1099 0040 F3E7     		b	.L76
 1100              	.L78:
 1101 0042 00BF     		.align	2
 1102              	.L77:
 1103 0044 00000000 		.word	disable_action_cache
 1104              		.cfi_endproc
 1105              	.LFE27:
 1107              		.global	source_layers_cache
 1108              		.section	.bss.source_layers_cache,"aw",%nobits
 1111              	source_layers_cache:
 1112 0000 00000000 		.space	30
 1112      00000000 
 1112      00000000 
 1112      00000000 
 1112      00000000 
 1113              		.global	layer_state
 1114              		.section	.bss.layer_state,"aw",%nobits
 1115              		.align	2
 1118              	layer_state:
 1119 0000 00000000 		.space	4
 1120              		.global	default_layer_state
 1121              		.section	.bss.default_layer_state,"aw",%nobits
 1122              		.align	2
 1125              	default_layer_state:
 1126 0000 00000000 		.space	4
 1127              		.text
 1128              	.Letext0:
 1129              		.file 2 "/usr/arm-none-eabi/include/machine/_default_types.h"
 1130              		.file 3 "/usr/arm-none-eabi/include/sys/_stdint.h"
 1131              		.file 4 "quantum/keyboard.h"
 1132              		.file 5 "quantum/action_code.h"
 1133              		.file 6 "quantum/action_layer.h"
 1134              		.file 7 "quantum/action.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action_layer.c
     /tmp/cclEpFZJ.s:21     .text.default_layer_state_set_user:0000000000000000 $t
     /tmp/cclEpFZJ.s:27     .text.default_layer_state_set_user:0000000000000000 default_layer_state_set_user
     /tmp/cclEpFZJ.s:42     .text.default_layer_state_set_kb:0000000000000000 $t
     /tmp/cclEpFZJ.s:48     .text.default_layer_state_set_kb:0000000000000000 default_layer_state_set_kb
     /tmp/cclEpFZJ.s:70     .text.default_layer_state_set:0000000000000000 $t
     /tmp/cclEpFZJ.s:75     .text.default_layer_state_set:0000000000000000 default_layer_state_set
     /tmp/cclEpFZJ.s:113    .text.default_layer_state_set:0000000000000014 $d
     /tmp/cclEpFZJ.s:1125   .bss.default_layer_state:0000000000000000 default_layer_state
     /tmp/cclEpFZJ.s:118    .text.default_layer_debug:0000000000000000 $t
     /tmp/cclEpFZJ.s:124    .text.default_layer_debug:0000000000000000 default_layer_debug
     /tmp/cclEpFZJ.s:138    .text.default_layer_set:0000000000000000 $t
     /tmp/cclEpFZJ.s:144    .text.default_layer_set:0000000000000000 default_layer_set
     /tmp/cclEpFZJ.s:160    .text.default_layer_or:0000000000000000 $t
     /tmp/cclEpFZJ.s:166    .text.default_layer_or:0000000000000000 default_layer_or
     /tmp/cclEpFZJ.s:185    .text.default_layer_or:000000000000000c $d
     /tmp/cclEpFZJ.s:190    .text.default_layer_and:0000000000000000 $t
     /tmp/cclEpFZJ.s:196    .text.default_layer_and:0000000000000000 default_layer_and
     /tmp/cclEpFZJ.s:215    .text.default_layer_and:000000000000000c $d
     /tmp/cclEpFZJ.s:220    .text.default_layer_xor:0000000000000000 $t
     /tmp/cclEpFZJ.s:226    .text.default_layer_xor:0000000000000000 default_layer_xor
     /tmp/cclEpFZJ.s:245    .text.default_layer_xor:000000000000000c $d
     /tmp/cclEpFZJ.s:250    .text.layer_state_set_user:0000000000000000 $t
     /tmp/cclEpFZJ.s:256    .text.layer_state_set_user:0000000000000000 layer_state_set_user
     /tmp/cclEpFZJ.s:268    .text.layer_state_set_kb:0000000000000000 $t
     /tmp/cclEpFZJ.s:274    .text.layer_state_set_kb:0000000000000000 layer_state_set_kb
     /tmp/cclEpFZJ.s:296    .text.layer_state_set:0000000000000000 $t
     /tmp/cclEpFZJ.s:302    .text.layer_state_set:0000000000000000 layer_state_set
     /tmp/cclEpFZJ.s:340    .text.layer_state_set:0000000000000014 $d
     /tmp/cclEpFZJ.s:1118   .bss.layer_state:0000000000000000 layer_state
     /tmp/cclEpFZJ.s:345    .text.layer_clear:0000000000000000 $t
     /tmp/cclEpFZJ.s:351    .text.layer_clear:0000000000000000 layer_clear
     /tmp/cclEpFZJ.s:366    .text.layer_state_is:0000000000000000 $t
     /tmp/cclEpFZJ.s:372    .text.layer_state_is:0000000000000000 layer_state_is
     /tmp/cclEpFZJ.s:416    .text.layer_state_is:0000000000000018 $d
     /tmp/cclEpFZJ.s:421    .text.layer_state_cmp:0000000000000000 $t
     /tmp/cclEpFZJ.s:427    .text.layer_state_cmp:0000000000000000 layer_state_cmp
     /tmp/cclEpFZJ.s:459    .text.layer_move:0000000000000000 $t
     /tmp/cclEpFZJ.s:465    .text.layer_move:0000000000000000 layer_move
     /tmp/cclEpFZJ.s:484    .text.layer_on:0000000000000000 $t
     /tmp/cclEpFZJ.s:490    .text.layer_on:0000000000000000 layer_on
     /tmp/cclEpFZJ.s:513    .text.layer_on:0000000000000010 $d
     /tmp/cclEpFZJ.s:518    .text.layer_off:0000000000000000 $t
     /tmp/cclEpFZJ.s:524    .text.layer_off:0000000000000000 layer_off
     /tmp/cclEpFZJ.s:547    .text.layer_off:0000000000000010 $d
     /tmp/cclEpFZJ.s:552    .text.layer_invert:0000000000000000 $t
     /tmp/cclEpFZJ.s:558    .text.layer_invert:0000000000000000 layer_invert
     /tmp/cclEpFZJ.s:581    .text.layer_invert:0000000000000010 $d
     /tmp/cclEpFZJ.s:586    .text.layer_or:0000000000000000 $t
     /tmp/cclEpFZJ.s:592    .text.layer_or:0000000000000000 layer_or
     /tmp/cclEpFZJ.s:611    .text.layer_or:000000000000000c $d
     /tmp/cclEpFZJ.s:616    .text.layer_and:0000000000000000 $t
     /tmp/cclEpFZJ.s:622    .text.layer_and:0000000000000000 layer_and
     /tmp/cclEpFZJ.s:641    .text.layer_and:000000000000000c $d
     /tmp/cclEpFZJ.s:646    .text.layer_xor:0000000000000000 $t
     /tmp/cclEpFZJ.s:652    .text.layer_xor:0000000000000000 layer_xor
     /tmp/cclEpFZJ.s:671    .text.layer_xor:000000000000000c $d
     /tmp/cclEpFZJ.s:676    .text.layer_debug:0000000000000000 $t
     /tmp/cclEpFZJ.s:682    .text.layer_debug:0000000000000000 layer_debug
     /tmp/cclEpFZJ.s:694    .text.update_source_layers_cache:0000000000000000 $t
     /tmp/cclEpFZJ.s:700    .text.update_source_layers_cache:0000000000000000 update_source_layers_cache
     /tmp/cclEpFZJ.s:775    .text.update_source_layers_cache:0000000000000044 $d
     /tmp/cclEpFZJ.s:1111   .bss.source_layers_cache:0000000000000000 source_layers_cache
     /tmp/cclEpFZJ.s:780    .text.read_source_layers_cache:0000000000000000 $t
     /tmp/cclEpFZJ.s:786    .text.read_source_layers_cache:0000000000000000 read_source_layers_cache
     /tmp/cclEpFZJ.s:862    .text.read_source_layers_cache:000000000000003c $d
     /tmp/cclEpFZJ.s:867    .text.layer_switch_get_layer:0000000000000000 $t
     /tmp/cclEpFZJ.s:873    .text.layer_switch_get_layer:0000000000000000 layer_switch_get_layer
     /tmp/cclEpFZJ.s:960    .text.layer_switch_get_layer:0000000000000038 $d
     /tmp/cclEpFZJ.s:967    .text.layer_switch_get_action:0000000000000000 $t
     /tmp/cclEpFZJ.s:973    .text.layer_switch_get_action:0000000000000000 layer_switch_get_action
     /tmp/cclEpFZJ.s:1005   .text.store_or_get_action:0000000000000000 $t
     /tmp/cclEpFZJ.s:1011   .text.store_or_get_action:0000000000000000 store_or_get_action
     /tmp/cclEpFZJ.s:1103   .text.store_or_get_action:0000000000000044 $d
     /tmp/cclEpFZJ.s:1112   .bss.source_layers_cache:0000000000000000 $d
     /tmp/cclEpFZJ.s:1115   .bss.layer_state:0000000000000000 $d
     /tmp/cclEpFZJ.s:1122   .bss.default_layer_state:0000000000000000 $d

UNDEFINED SYMBOLS
clear_keyboard_but_mods_and_keys
action_for_key
disable_action_cache
