   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 4
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 2
  15              		.file	"action.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "quantum/action.c"
  20              		.section	.text.pre_process_record_quantum,"ax",%progbits
  21              		.align	1
  22              		.weak	pre_process_record_quantum
  23              		.syntax unified
  24              		.thumb
  25              		.thumb_func
  27              	pre_process_record_quantum:
  28              	.LFB323:
  29              		.cfi_startproc
   1:quantum/action.c **** /*
   2:quantum/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:quantum/action.c **** 
   4:quantum/action.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/action.c **** it under the terms of the GNU General Public License as published by
   6:quantum/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/action.c **** (at your option) any later version.
   8:quantum/action.c **** 
   9:quantum/action.c **** This program is distributed in the hope that it will be useful,
  10:quantum/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/action.c **** GNU General Public License for more details.
  13:quantum/action.c **** 
  14:quantum/action.c **** You should have received a copy of the GNU General Public License
  15:quantum/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/action.c **** */
  17:quantum/action.c **** #include "host.h"
  18:quantum/action.c **** #include "keycode.h"
  19:quantum/action.c **** #include "keyboard.h"
  20:quantum/action.c **** #include "mousekey.h"
  21:quantum/action.c **** #include "command.h"
  22:quantum/action.c **** #include "led.h"
  23:quantum/action.c **** #include "action_layer.h"
  24:quantum/action.c **** #include "action_tapping.h"
  25:quantum/action.c **** #include "action_macro.h"
  26:quantum/action.c **** #include "action_util.h"
  27:quantum/action.c **** #include "action.h"
  28:quantum/action.c **** #include "wait.h"
  29:quantum/action.c **** 
  30:quantum/action.c **** #ifdef BACKLIGHT_ENABLE
  31:quantum/action.c **** #    include "backlight.h"
  32:quantum/action.c **** #endif
  33:quantum/action.c **** 
  34:quantum/action.c **** #ifdef DEBUG_ACTION
  35:quantum/action.c **** #    include "debug.h"
  36:quantum/action.c **** #else
  37:quantum/action.c **** #    include "nodebug.h"
  38:quantum/action.c **** #endif
  39:quantum/action.c **** 
  40:quantum/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:quantum/action.c **** #    include "pointing_device.h"
  42:quantum/action.c **** #endif
  43:quantum/action.c **** 
  44:quantum/action.c **** int tp_buttons;
  45:quantum/action.c **** 
  46:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:quantum/action.c **** int retro_tapping_counter = 0;
  48:quantum/action.c **** #endif
  49:quantum/action.c **** 
  50:quantum/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:quantum/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:quantum/action.c **** #endif
  53:quantum/action.c **** 
  54:quantum/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  55:quantum/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  56:quantum/action.c **** #endif
  57:quantum/action.c **** 
  58:quantum/action.c **** __attribute__((weak)) bool pre_process_record_quantum(keyrecord_t *record) { return true; }
  30              		.loc 1 58 28 view -0
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
  34 0000 0120     		movs	r0, #1
  35 0002 7047     		bx	lr
  36              		.cfi_endproc
  37              	.LFE323:
  39              		.section	.text.action_exec,"ax",%progbits
  40              		.align	1
  41              		.global	action_exec
  42              		.syntax unified
  43              		.thumb
  44              		.thumb_func
  46              	action_exec:
  47              	.LFB292:
  59:quantum/action.c **** 
  60:quantum/action.c **** /** \brief Called to execute an action.
  61:quantum/action.c ****  *
  62:quantum/action.c ****  * FIXME: Needs documentation.
  63:quantum/action.c ****  */
  64:quantum/action.c **** void action_exec(keyevent_t event) {
  48              		.loc 1 64 36 view -0
  49              		.cfi_startproc
  50              		@ args = 0, pretend = 0, frame = 24
  51              		@ frame_needed = 0, uses_anonymous_args = 0
  52 0000 30B5     		push	{r4, r5, lr}
  53              		.cfi_def_cfa_offset 12
  54              		.cfi_offset 4, -12
  55              		.cfi_offset 5, -8
  56              		.cfi_offset 14, -4
  57 0002 87B0     		sub	sp, sp, #28
  58              		.cfi_def_cfa_offset 40
  59              	.LVL0:
  60              		.loc 1 64 36 is_stmt 0 view .LVU2
  61 0004 6C46     		mov	r4, sp
  62 0006 84E80300 		stm	r4, {r0, r1}
  63              	.LVL1:
  65:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  66:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:quantum/action.c ****         dprint("EVENT: ");
  68:quantum/action.c ****         debug_event(event);
  69:quantum/action.c ****         dprintln();
  70:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  71:quantum/action.c ****         retro_tapping_counter++;
  72:quantum/action.c **** #endif
  73:quantum/action.c ****     }
  74:quantum/action.c **** 
  75:quantum/action.c ****     if (event.pressed) {
  64              		.loc 1 75 8 view .LVU3
  65 000a 9DF80230 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
  66 000e BDF80450 		ldrh	r5, [sp, #4]
  67              	.LVL2:
  65:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  68              		.loc 1 65 5 is_stmt 1 view .LVU4
  69              	.LBB16:
  70              	.LBI16:
  71              		.file 2 "quantum/keyboard.h"
   1:quantum/keyboard.h **** /*
   2:quantum/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:quantum/keyboard.h **** 
   4:quantum/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:quantum/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:quantum/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/keyboard.h **** (at your option) any later version.
   8:quantum/keyboard.h **** 
   9:quantum/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:quantum/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/keyboard.h **** GNU General Public License for more details.
  13:quantum/keyboard.h **** 
  14:quantum/keyboard.h **** You should have received a copy of the GNU General Public License
  15:quantum/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/keyboard.h **** */
  17:quantum/keyboard.h **** 
  18:quantum/keyboard.h **** #pragma once
  19:quantum/keyboard.h **** 
  20:quantum/keyboard.h **** #include <stdbool.h>
  21:quantum/keyboard.h **** #include <stdint.h>
  22:quantum/keyboard.h **** 
  23:quantum/keyboard.h **** #ifdef __cplusplus
  24:quantum/keyboard.h **** extern "C" {
  25:quantum/keyboard.h **** #endif
  26:quantum/keyboard.h **** 
  27:quantum/keyboard.h **** /* key matrix position */
  28:quantum/keyboard.h **** typedef struct {
  29:quantum/keyboard.h ****     uint8_t col;
  30:quantum/keyboard.h ****     uint8_t row;
  31:quantum/keyboard.h **** } keypos_t;
  32:quantum/keyboard.h **** 
  33:quantum/keyboard.h **** /* key event */
  34:quantum/keyboard.h **** typedef struct {
  35:quantum/keyboard.h ****     keypos_t key;
  36:quantum/keyboard.h ****     bool     pressed;
  37:quantum/keyboard.h ****     uint16_t time;
  38:quantum/keyboard.h **** } keyevent_t;
  39:quantum/keyboard.h **** 
  40:quantum/keyboard.h **** /* equivalent test of keypos_t */
  41:quantum/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  42:quantum/keyboard.h **** 
  43:quantum/keyboard.h **** /* Rules for No Event:
  44:quantum/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  45:quantum/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  46:quantum/keyboard.h ****  */
  47:quantum/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
  72              		.loc 2 47 20 view .LVU5
  73              		.loc 2 47 51 view .LVU6
  74              		.loc 2 47 51 is_stmt 0 view .LVU7
  75              	.LBE16:
  69:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  76              		.loc 1 69 19 is_stmt 1 view .LVU8
  77              		.loc 1 75 5 view .LVU9
  78              		.loc 1 75 8 is_stmt 0 view .LVU10
  79 0012 0BB1     		cbz	r3, .L3
  76:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
  77:quantum/action.c ****         clear_weak_mods();
  80              		.loc 1 77 9 is_stmt 1 view .LVU11
  81 0014 FFF7FEFF 		bl	clear_weak_mods
  82              	.LVL3:
  83              	.L3:
  78:quantum/action.c ****     }
  79:quantum/action.c **** 
  80:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
  81:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  82:quantum/action.c ****         process_hand_swap(&event);
  83:quantum/action.c ****     }
  84:quantum/action.c **** #endif
  85:quantum/action.c **** 
  86:quantum/action.c ****     keyrecord_t record = {.event = event};
  84              		.loc 1 86 5 view .LVU12
  85              		.loc 1 86 17 is_stmt 0 view .LVU13
  86 0018 0023     		movs	r3, #0
  87 001a ADF81630 		strh	r3, [sp, #22]	@ movhi
  88 001e 94E80300 		ldm	r4, {r0, r1}
  89 0022 04AC     		add	r4, sp, #16
  90 0024 0490     		str	r0, [sp, #16]
  91 0026 ADF81410 		strh	r1, [sp, #20]	@ movhi
  87:quantum/action.c **** 
  88:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
  89:quantum/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  90:quantum/action.c ****     if (has_oneshot_layer_timed_out()) {
  91:quantum/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  92:quantum/action.c ****     }
  93:quantum/action.c ****     if (has_oneshot_mods_timed_out()) {
  94:quantum/action.c ****         clear_oneshot_mods();
  95:quantum/action.c ****     }
  96:quantum/action.c **** #        ifdef SWAP_HANDS_ENABLE
  97:quantum/action.c ****     if (has_oneshot_swaphands_timed_out()) {
  98:quantum/action.c ****         clear_oneshot_swaphands();
  99:quantum/action.c ****     }
 100:quantum/action.c **** #        endif
 101:quantum/action.c **** #    endif
 102:quantum/action.c **** #endif
 103:quantum/action.c **** 
 104:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 105:quantum/action.c ****     if (IS_NOEVENT(record.event) || pre_process_record_quantum(&record)) {
  92              		.loc 1 105 5 is_stmt 1 view .LVU14
  93 002a 94E80300 		ldm	r4, {r0, r1}
  94 002e 0290     		str	r0, [sp, #8]
  95              	.LVL4:
  96              	.LBB17:
  97              	.LBI17:
  98              		.loc 2 47 20 view .LVU15
  99              	.LBB18:
 100              		.loc 2 47 51 view .LVU16
 101              		.loc 2 47 74 is_stmt 0 view .LVU17
 102 0030 4DB1     		cbz	r5, .L5
 103              		.loc 2 47 74 view .LVU18
 104 0032 BDF80820 		ldrh	r2, [sp, #8]
 105 0036 4FF6FF73 		movw	r3, #65535
 106 003a 9A42     		cmp	r2, r3
 107 003c 03D0     		beq	.L5
 108              	.LVL5:
 109              		.loc 2 47 74 view .LVU19
 110              	.LBE18:
 111              	.LBE17:
 112              		.loc 1 105 37 view .LVU20
 113 003e 2046     		mov	r0, r4
 114 0040 FFF7FEFF 		bl	pre_process_record_quantum
 115              	.LVL6:
 116              		.loc 1 105 34 view .LVU21
 117 0044 18B1     		cbz	r0, .L2
 118              	.L5:
 106:quantum/action.c ****         action_tapping_process(record);
 119              		.loc 1 106 9 is_stmt 1 view .LVU22
 120 0046 94E80300 		ldm	r4, {r0, r1}
 121 004a FFF7FEFF 		bl	action_tapping_process
 122              	.LVL7:
 123              	.L2:
 107:quantum/action.c ****     }
 108:quantum/action.c **** #else
 109:quantum/action.c ****     if (IS_NOEVENT(record.event) || pre_process_record_quantum(&record)) {
 110:quantum/action.c ****         process_record(&record);
 111:quantum/action.c ****     }
 112:quantum/action.c ****     if (!IS_NOEVENT(record.event)) {
 113:quantum/action.c ****         dprint("processed: ");
 114:quantum/action.c ****         debug_record(record);
 115:quantum/action.c ****         dprintln();
 116:quantum/action.c ****     }
 117:quantum/action.c **** #endif
 118:quantum/action.c **** }
 124              		.loc 1 118 1 is_stmt 0 view .LVU23
 125 004e 07B0     		add	sp, sp, #28
 126              		.cfi_def_cfa_offset 12
 127              		@ sp needed
 128 0050 30BD     		pop	{r4, r5, pc}
 129              		.loc 1 118 1 view .LVU24
 130              		.cfi_endproc
 131              	.LFE292:
 133              		.section	.text.process_record_quantum,"ax",%progbits
 134              		.align	1
 135              		.weak	process_record_quantum
 136              		.syntax unified
 137              		.thumb
 138              		.thumb_func
 140              	process_record_quantum:
 141              	.LVL8:
 142              	.LFB294:
 119:quantum/action.c **** 
 120:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 121:quantum/action.c **** bool swap_hands = false;
 122:quantum/action.c **** bool swap_held  = false;
 123:quantum/action.c **** 
 124:quantum/action.c **** /** \brief Process Hand Swap
 125:quantum/action.c ****  *
 126:quantum/action.c ****  * FIXME: Needs documentation.
 127:quantum/action.c ****  */
 128:quantum/action.c **** void process_hand_swap(keyevent_t *event) {
 129:quantum/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 130:quantum/action.c **** 
 131:quantum/action.c ****     keypos_t         pos     = event->key;
 132:quantum/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 133:quantum/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 134:quantum/action.c **** 
 135:quantum/action.c ****     if (do_swap) {
 136:quantum/action.c ****         event->key.row = pgm_read_byte(&hand_swap_config[pos.row][pos.col].row);
 137:quantum/action.c ****         event->key.col = pgm_read_byte(&hand_swap_config[pos.row][pos.col].col);
 138:quantum/action.c ****         swap_state[pos.row] |= col_bit;
 139:quantum/action.c ****     } else {
 140:quantum/action.c ****         swap_state[pos.row] &= ~(col_bit);
 141:quantum/action.c ****     }
 142:quantum/action.c **** }
 143:quantum/action.c **** #endif
 144:quantum/action.c **** 
 145:quantum/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:quantum/action.c **** bool disable_action_cache = false;
 147:quantum/action.c **** 
 148:quantum/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:quantum/action.c ****     disable_action_cache = true;
 150:quantum/action.c ****     process_record(record);
 151:quantum/action.c ****     disable_action_cache = false;
 152:quantum/action.c **** }
 153:quantum/action.c **** #else
 154:quantum/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:quantum/action.c **** #endif
 156:quantum/action.c **** 
 157:quantum/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
 143              		.loc 1 157 72 is_stmt 1 view -0
 144              		.cfi_startproc
 145              		@ args = 0, pretend = 0, frame = 0
 146              		@ frame_needed = 0, uses_anonymous_args = 0
 147              		@ link register save eliminated.
 148              		.loc 1 157 74 view .LVU26
 149              		.loc 1 157 87 is_stmt 0 view .LVU27
 150 0000 0120     		movs	r0, #1
 151              	.LVL9:
 152              		.loc 1 157 87 view .LVU28
 153 0002 7047     		bx	lr
 154              		.cfi_endproc
 155              	.LFE294:
 157              		.section	.text.post_process_record_quantum,"ax",%progbits
 158              		.align	1
 159              		.weak	post_process_record_quantum
 160              		.syntax unified
 161              		.thumb
 162              		.thumb_func
 164              	post_process_record_quantum:
 165              	.LVL10:
 166              	.LFB295:
 158:quantum/action.c **** 
 159:quantum/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 167              		.loc 1 159 77 is_stmt 1 view -0
 168              		.cfi_startproc
 169              		@ args = 0, pretend = 0, frame = 0
 170              		@ frame_needed = 0, uses_anonymous_args = 0
 171              		@ link register save eliminated.
 172              		.loc 1 159 78 view .LVU30
 173 0000 7047     		bx	lr
 174              		.cfi_endproc
 175              	.LFE295:
 177              		.section	.text.process_record_tap_hint,"ax",%progbits
 178              		.align	1
 179              		.global	process_record_tap_hint
 180              		.syntax unified
 181              		.thumb
 182              		.thumb_func
 184              	process_record_tap_hint:
 185              	.LVL11:
 186              	.LFB296:
 160:quantum/action.c **** 
 161:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 162:quantum/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:quantum/action.c ****  *
 164:quantum/action.c ****  * FIXME: Needs documentation.
 165:quantum/action.c ****  */
 166:quantum/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 187              		.loc 1 166 51 view -0
 188              		.cfi_startproc
 189              		@ args = 0, pretend = 0, frame = 0
 190              		@ frame_needed = 0, uses_anonymous_args = 0
 191              		@ link register save eliminated.
 167:quantum/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 192              		.loc 1 167 5 view .LVU32
 193              		.loc 1 167 23 is_stmt 0 view .LVU33
 194 0000 0088     		ldrh	r0, [r0]
 195              	.LVL12:
 196              		.loc 1 167 23 view .LVU34
 197 0002 FFF7FEBF 		b	layer_switch_get_action
 198              	.LVL13:
 199              		.cfi_endproc
 200              	.LFE296:
 202              		.section	.text.register_code,"ax",%progbits
 203              		.align	1
 204              		.global	register_code
 205              		.syntax unified
 206              		.thumb
 207              		.thumb_func
 209              	register_code:
 210              	.LVL14:
 211              	.LFB300:
 168:quantum/action.c **** 
 169:quantum/action.c ****     switch (action.kind.id) {
 170:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:quantum/action.c ****         case ACT_SWAP_HANDS:
 172:quantum/action.c ****             switch (action.swap.code) {
 173:quantum/action.c ****                 case OP_SH_ONESHOT:
 174:quantum/action.c ****                     break;
 175:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:quantum/action.c ****                 default:
 177:quantum/action.c ****                     swap_hands = !swap_hands;
 178:quantum/action.c ****                     swap_held  = true;
 179:quantum/action.c ****             }
 180:quantum/action.c ****             break;
 181:quantum/action.c **** #    endif
 182:quantum/action.c ****     }
 183:quantum/action.c **** }
 184:quantum/action.c **** #endif
 185:quantum/action.c **** 
 186:quantum/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:quantum/action.c ****  *
 188:quantum/action.c ****  * FIXME: Needs documentation.
 189:quantum/action.c ****  */
 190:quantum/action.c **** void process_record(keyrecord_t *record) {
 191:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 192:quantum/action.c ****         return;
 193:quantum/action.c ****     }
 194:quantum/action.c **** 
 195:quantum/action.c ****     if (!process_record_quantum(record)) {
 196:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 197:quantum/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:quantum/action.c ****         }
 200:quantum/action.c **** #endif
 201:quantum/action.c ****         return;
 202:quantum/action.c ****     }
 203:quantum/action.c **** 
 204:quantum/action.c ****     process_record_handler(record);
 205:quantum/action.c ****     post_process_record_quantum(record);
 206:quantum/action.c **** }
 207:quantum/action.c **** 
 208:quantum/action.c **** void process_record_handler(keyrecord_t *record) {
 209:quantum/action.c **** #ifdef COMBO_ENABLE
 210:quantum/action.c ****     action_t action;
 211:quantum/action.c ****     if (record->keycode) {
 212:quantum/action.c ****         action = action_for_keycode(record->keycode);
 213:quantum/action.c ****     } else {
 214:quantum/action.c ****         action = store_or_get_action(record->event.pressed, record->event.key);
 215:quantum/action.c ****     }
 216:quantum/action.c **** #else
 217:quantum/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 218:quantum/action.c **** #endif
 219:quantum/action.c ****     dprint("ACTION: ");
 220:quantum/action.c ****     debug_action(action);
 221:quantum/action.c **** #ifndef NO_ACTION_LAYER
 222:quantum/action.c ****     dprint(" layer_state: ");
 223:quantum/action.c ****     layer_debug();
 224:quantum/action.c ****     dprint(" default_layer_state: ");
 225:quantum/action.c ****     default_layer_debug();
 226:quantum/action.c **** #endif
 227:quantum/action.c ****     dprintln();
 228:quantum/action.c **** 
 229:quantum/action.c ****     process_action(record, action);
 230:quantum/action.c **** }
 231:quantum/action.c **** 
 232:quantum/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 233:quantum/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 234:quantum/action.c **** #    ifdef PS2_MOUSE_ENABLE
 235:quantum/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 236:quantum/action.c **** #    endif
 237:quantum/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 238:quantum/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 239:quantum/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 240:quantum/action.c ****     pointing_device_set_report(currentReport);
 241:quantum/action.c **** #    endif
 242:quantum/action.c **** }
 243:quantum/action.c **** #endif
 244:quantum/action.c **** 
 245:quantum/action.c **** /** \brief Take an action and processes it.
 246:quantum/action.c ****  *
 247:quantum/action.c ****  * FIXME: Needs documentation.
 248:quantum/action.c ****  */
 249:quantum/action.c **** void process_action(keyrecord_t *record, action_t action) {
 250:quantum/action.c ****     keyevent_t event = record->event;
 251:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 252:quantum/action.c ****     uint8_t tap_count = record->tap.count;
 253:quantum/action.c **** #endif
 254:quantum/action.c **** 
 255:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 256:quantum/action.c ****     bool do_release_oneshot = false;
 257:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 258:quantum/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 259:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 260:quantum/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 261:quantum/action.c **** #    endif
 262:quantum/action.c ****     ) {
 263:quantum/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 264:quantum/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 265:quantum/action.c ****     }
 266:quantum/action.c **** #endif
 267:quantum/action.c **** 
 268:quantum/action.c ****     switch (action.kind.id) {
 269:quantum/action.c ****         /* Key and Mods */
 270:quantum/action.c ****         case ACT_LMODS:
 271:quantum/action.c ****         case ACT_RMODS: {
 272:quantum/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 273:quantum/action.c ****             if (event.pressed) {
 274:quantum/action.c ****                 if (mods) {
 275:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 276:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 277:quantum/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 278:quantum/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 279:quantum/action.c ****                         add_mods(mods);
 280:quantum/action.c ****                     } else {
 281:quantum/action.c ****                         add_weak_mods(mods);
 282:quantum/action.c ****                     }
 283:quantum/action.c ****                     send_keyboard_report();
 284:quantum/action.c ****                 }
 285:quantum/action.c ****                 register_code(action.key.code);
 286:quantum/action.c ****             } else {
 287:quantum/action.c ****                 unregister_code(action.key.code);
 288:quantum/action.c ****                 if (mods) {
 289:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 290:quantum/action.c ****                         del_mods(mods);
 291:quantum/action.c ****                     } else {
 292:quantum/action.c ****                         del_weak_mods(mods);
 293:quantum/action.c ****                     }
 294:quantum/action.c ****                     send_keyboard_report();
 295:quantum/action.c ****                 }
 296:quantum/action.c ****             }
 297:quantum/action.c ****         } break;
 298:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 299:quantum/action.c ****         case ACT_LMODS_TAP:
 300:quantum/action.c ****         case ACT_RMODS_TAP: {
 301:quantum/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 302:quantum/action.c ****             switch (action.layer_tap.code) {
 303:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 304:quantum/action.c ****                 case MODS_ONESHOT:
 305:quantum/action.c ****                     // Oneshot modifier
 306:quantum/action.c ****                     if (event.pressed) {
 307:quantum/action.c ****                         if (tap_count == 0) {
 308:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 309:quantum/action.c ****                             register_mods(mods | get_oneshot_mods());
 310:quantum/action.c ****                         } else if (tap_count == 1) {
 311:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 312:quantum/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 313:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 314:quantum/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 315:quantum/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 316:quantum/action.c ****                             clear_oneshot_mods();
 317:quantum/action.c ****                             set_oneshot_locked_mods(mods);
 318:quantum/action.c ****                             register_mods(mods);
 319:quantum/action.c **** #        endif
 320:quantum/action.c ****                         } else {
 321:quantum/action.c ****                             register_mods(mods | get_oneshot_mods());
 322:quantum/action.c ****                         }
 323:quantum/action.c ****                     } else {
 324:quantum/action.c ****                         if (tap_count == 0) {
 325:quantum/action.c ****                             clear_oneshot_mods();
 326:quantum/action.c ****                             unregister_mods(mods);
 327:quantum/action.c ****                         } else if (tap_count == 1) {
 328:quantum/action.c ****                             // Retain Oneshot mods
 329:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 330:quantum/action.c ****                             if (mods & get_mods()) {
 331:quantum/action.c ****                                 clear_oneshot_locked_mods();
 332:quantum/action.c ****                                 clear_oneshot_mods();
 333:quantum/action.c ****                                 unregister_mods(mods);
 334:quantum/action.c ****                             }
 335:quantum/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 336:quantum/action.c ****                             // Toggle Oneshot Layer
 337:quantum/action.c **** #        endif
 338:quantum/action.c ****                         } else {
 339:quantum/action.c ****                             clear_oneshot_mods();
 340:quantum/action.c ****                             unregister_mods(mods);
 341:quantum/action.c ****                         }
 342:quantum/action.c ****                     }
 343:quantum/action.c ****                     break;
 344:quantum/action.c **** #    endif
 345:quantum/action.c ****                 case MODS_TAP_TOGGLE:
 346:quantum/action.c ****                     if (event.pressed) {
 347:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 348:quantum/action.c ****                             register_mods(mods);
 349:quantum/action.c ****                         }
 350:quantum/action.c ****                     } else {
 351:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 352:quantum/action.c ****                             unregister_mods(mods);
 353:quantum/action.c ****                         }
 354:quantum/action.c ****                     }
 355:quantum/action.c ****                     break;
 356:quantum/action.c ****                 default:
 357:quantum/action.c ****                     if (event.pressed) {
 358:quantum/action.c ****                         if (tap_count > 0) {
 359:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 360:quantum/action.c ****                             if (
 361:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 362:quantum/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 363:quantum/action.c **** #        endif
 364:quantum/action.c ****                                 record->tap.interrupted) {
 365:quantum/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 366:quantum/action.c ****                                 // ad hoc: set 0 to cancel tap
 367:quantum/action.c ****                                 record->tap.count = 0;
 368:quantum/action.c ****                                 register_mods(mods);
 369:quantum/action.c ****                             } else
 370:quantum/action.c **** #    endif
 371:quantum/action.c ****                             {
 372:quantum/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 373:quantum/action.c ****                                 register_code(action.key.code);
 374:quantum/action.c ****                             }
 375:quantum/action.c ****                         } else {
 376:quantum/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 377:quantum/action.c ****                             register_mods(mods);
 378:quantum/action.c ****                         }
 379:quantum/action.c ****                     } else {
 380:quantum/action.c ****                         if (tap_count > 0) {
 381:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 382:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 383:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 384:quantum/action.c ****                             } else {
 385:quantum/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 386:quantum/action.c ****                             }
 387:quantum/action.c ****                             unregister_code(action.key.code);
 388:quantum/action.c ****                         } else {
 389:quantum/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 390:quantum/action.c ****                             unregister_mods(mods);
 391:quantum/action.c ****                         }
 392:quantum/action.c ****                     }
 393:quantum/action.c ****                     break;
 394:quantum/action.c ****             }
 395:quantum/action.c ****         } break;
 396:quantum/action.c **** #endif
 397:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 398:quantum/action.c ****         /* other HID usage */
 399:quantum/action.c ****         case ACT_USAGE:
 400:quantum/action.c ****             switch (action.usage.page) {
 401:quantum/action.c ****                 case PAGE_SYSTEM:
 402:quantum/action.c ****                     if (event.pressed) {
 403:quantum/action.c ****                         host_system_send(action.usage.code);
 404:quantum/action.c ****                     } else {
 405:quantum/action.c ****                         host_system_send(0);
 406:quantum/action.c ****                     }
 407:quantum/action.c ****                     break;
 408:quantum/action.c ****                 case PAGE_CONSUMER:
 409:quantum/action.c ****                     if (event.pressed) {
 410:quantum/action.c ****                         host_consumer_send(action.usage.code);
 411:quantum/action.c ****                     } else {
 412:quantum/action.c ****                         host_consumer_send(0);
 413:quantum/action.c ****                     }
 414:quantum/action.c ****                     break;
 415:quantum/action.c ****             }
 416:quantum/action.c ****             break;
 417:quantum/action.c **** #endif
 418:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 419:quantum/action.c ****         /* Mouse key */
 420:quantum/action.c ****         case ACT_MOUSEKEY:
 421:quantum/action.c ****             if (event.pressed) {
 422:quantum/action.c ****                 mousekey_on(action.key.code);
 423:quantum/action.c ****             } else {
 424:quantum/action.c ****                 mousekey_off(action.key.code);
 425:quantum/action.c ****             }
 426:quantum/action.c ****             switch (action.key.code) {
 427:quantum/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 428:quantum/action.c **** #        ifdef POINTING_DEVICE_ENABLE
 429:quantum/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN8:
 430:quantum/action.c **** #        else
 431:quantum/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN3:
 432:quantum/action.c **** #        endif
 433:quantum/action.c ****                     register_button(event.pressed, MOUSE_BTN_MASK(action.key.code - KC_MS_BTN1));
 434:quantum/action.c ****                     break;
 435:quantum/action.c **** #    endif
 436:quantum/action.c ****                 default:
 437:quantum/action.c ****                     mousekey_send();
 438:quantum/action.c ****                     break;
 439:quantum/action.c ****             }
 440:quantum/action.c ****             break;
 441:quantum/action.c **** #endif
 442:quantum/action.c **** #ifndef NO_ACTION_LAYER
 443:quantum/action.c ****         case ACT_LAYER:
 444:quantum/action.c ****             if (action.layer_bitop.on == 0) {
 445:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 446:quantum/action.c ****                 if (!event.pressed) {
 447:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 448:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 449:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 450:quantum/action.c ****                     switch (action.layer_bitop.op) {
 451:quantum/action.c ****                         case OP_BIT_AND:
 452:quantum/action.c ****                             default_layer_and(bits | mask);
 453:quantum/action.c ****                             break;
 454:quantum/action.c ****                         case OP_BIT_OR:
 455:quantum/action.c ****                             default_layer_or(bits | mask);
 456:quantum/action.c ****                             break;
 457:quantum/action.c ****                         case OP_BIT_XOR:
 458:quantum/action.c ****                             default_layer_xor(bits | mask);
 459:quantum/action.c ****                             break;
 460:quantum/action.c ****                         case OP_BIT_SET:
 461:quantum/action.c ****                             default_layer_set(bits | mask);
 462:quantum/action.c ****                             break;
 463:quantum/action.c ****                     }
 464:quantum/action.c ****                 }
 465:quantum/action.c ****             } else {
 466:quantum/action.c ****                 /* Layer Bitwise Operation */
 467:quantum/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 468:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 469:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 470:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 471:quantum/action.c ****                     switch (action.layer_bitop.op) {
 472:quantum/action.c ****                         case OP_BIT_AND:
 473:quantum/action.c ****                             layer_and(bits | mask);
 474:quantum/action.c ****                             break;
 475:quantum/action.c ****                         case OP_BIT_OR:
 476:quantum/action.c ****                             layer_or(bits | mask);
 477:quantum/action.c ****                             break;
 478:quantum/action.c ****                         case OP_BIT_XOR:
 479:quantum/action.c ****                             layer_xor(bits | mask);
 480:quantum/action.c ****                             break;
 481:quantum/action.c ****                         case OP_BIT_SET:
 482:quantum/action.c ****                             layer_state_set(bits | mask);
 483:quantum/action.c ****                             break;
 484:quantum/action.c ****                     }
 485:quantum/action.c ****                 }
 486:quantum/action.c ****             }
 487:quantum/action.c ****             break;
 488:quantum/action.c ****         case ACT_LAYER_MODS:
 489:quantum/action.c ****             if (event.pressed) {
 490:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 491:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 492:quantum/action.c ****             } else {
 493:quantum/action.c ****                 unregister_mods(action.layer_mods.mods);
 494:quantum/action.c ****                 layer_off(action.layer_mods.layer);
 495:quantum/action.c ****             }
 496:quantum/action.c ****             break;
 497:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 498:quantum/action.c ****         case ACT_LAYER_TAP:
 499:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
 500:quantum/action.c ****             switch (action.layer_tap.code) {
 501:quantum/action.c ****                 case OP_TAP_TOGGLE:
 502:quantum/action.c ****                     /* tap toggle */
 503:quantum/action.c ****                     if (event.pressed) {
 504:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 505:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 506:quantum/action.c ****                         }
 507:quantum/action.c ****                     } else {
 508:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 509:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 510:quantum/action.c ****                         }
 511:quantum/action.c ****                     }
 512:quantum/action.c ****                     break;
 513:quantum/action.c ****                 case OP_ON_OFF:
 514:quantum/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 515:quantum/action.c ****                     break;
 516:quantum/action.c ****                 case OP_OFF_ON:
 517:quantum/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 518:quantum/action.c ****                     break;
 519:quantum/action.c ****                 case OP_SET_CLEAR:
 520:quantum/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 521:quantum/action.c ****                     break;
 522:quantum/action.c **** #        ifndef NO_ACTION_ONESHOT
 523:quantum/action.c ****                 case OP_ONESHOT:
 524:quantum/action.c ****                     // Oneshot modifier
 525:quantum/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 526:quantum/action.c ****                     do_release_oneshot = false;
 527:quantum/action.c ****                     if (event.pressed) {
 528:quantum/action.c ****                         del_mods(get_oneshot_locked_mods());
 529:quantum/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 530:quantum/action.c ****                             reset_oneshot_layer();
 531:quantum/action.c ****                             layer_off(action.layer_tap.val);
 532:quantum/action.c ****                             break;
 533:quantum/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 534:quantum/action.c ****                             layer_on(action.layer_tap.val);
 535:quantum/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 536:quantum/action.c ****                         }
 537:quantum/action.c ****                     } else {
 538:quantum/action.c ****                         add_mods(get_oneshot_locked_mods());
 539:quantum/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 540:quantum/action.c ****                             reset_oneshot_layer();
 541:quantum/action.c ****                             clear_oneshot_locked_mods();
 542:quantum/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 543:quantum/action.c ****                         } else {
 544:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 545:quantum/action.c ****                         }
 546:quantum/action.c ****                     }
 547:quantum/action.c **** #            else
 548:quantum/action.c ****                     if (event.pressed) {
 549:quantum/action.c ****                         layer_on(action.layer_tap.val);
 550:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 551:quantum/action.c ****                     } else {
 552:quantum/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 553:quantum/action.c ****                         if (tap_count > 1) {
 554:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 555:quantum/action.c ****                         }
 556:quantum/action.c ****                     }
 557:quantum/action.c **** #            endif
 558:quantum/action.c ****                     break;
 559:quantum/action.c **** #        endif
 560:quantum/action.c ****                 default:
 561:quantum/action.c ****                     /* tap key */
 562:quantum/action.c ****                     if (event.pressed) {
 563:quantum/action.c ****                         if (tap_count > 0) {
 564:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 565:quantum/action.c ****                             register_code(action.layer_tap.code);
 566:quantum/action.c ****                         } else {
 567:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 568:quantum/action.c ****                             layer_on(action.layer_tap.val);
 569:quantum/action.c ****                         }
 570:quantum/action.c ****                     } else {
 571:quantum/action.c ****                         if (tap_count > 0) {
 572:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 573:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 574:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 575:quantum/action.c ****                             } else {
 576:quantum/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 577:quantum/action.c ****                             }
 578:quantum/action.c ****                             unregister_code(action.layer_tap.code);
 579:quantum/action.c ****                         } else {
 580:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 581:quantum/action.c ****                             layer_off(action.layer_tap.val);
 582:quantum/action.c ****                         }
 583:quantum/action.c ****                     }
 584:quantum/action.c ****                     break;
 585:quantum/action.c ****             }
 586:quantum/action.c ****             break;
 587:quantum/action.c **** #    endif
 588:quantum/action.c **** #endif
 589:quantum/action.c ****             /* Extentions */
 590:quantum/action.c **** #ifndef NO_ACTION_MACRO
 591:quantum/action.c ****         case ACT_MACRO:
 592:quantum/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 593:quantum/action.c ****             break;
 594:quantum/action.c **** #endif
 595:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 596:quantum/action.c ****         case ACT_SWAP_HANDS:
 597:quantum/action.c ****             switch (action.swap.code) {
 598:quantum/action.c ****                 case OP_SH_TOGGLE:
 599:quantum/action.c ****                     if (event.pressed) {
 600:quantum/action.c ****                         swap_hands = !swap_hands;
 601:quantum/action.c ****                     }
 602:quantum/action.c ****                     break;
 603:quantum/action.c ****                 case OP_SH_ON_OFF:
 604:quantum/action.c ****                     swap_hands = event.pressed;
 605:quantum/action.c ****                     break;
 606:quantum/action.c ****                 case OP_SH_OFF_ON:
 607:quantum/action.c ****                     swap_hands = !event.pressed;
 608:quantum/action.c ****                     break;
 609:quantum/action.c ****                 case OP_SH_ON:
 610:quantum/action.c ****                     if (!event.pressed) {
 611:quantum/action.c ****                         swap_hands = true;
 612:quantum/action.c ****                     }
 613:quantum/action.c ****                     break;
 614:quantum/action.c ****                 case OP_SH_OFF:
 615:quantum/action.c ****                     if (!event.pressed) {
 616:quantum/action.c ****                         swap_hands = false;
 617:quantum/action.c ****                     }
 618:quantum/action.c ****                     break;
 619:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 620:quantum/action.c ****                 case OP_SH_ONESHOT:
 621:quantum/action.c ****                     if (event.pressed) {
 622:quantum/action.c ****                         set_oneshot_swaphands();
 623:quantum/action.c ****                     } else {
 624:quantum/action.c ****                         release_oneshot_swaphands();
 625:quantum/action.c ****                     }
 626:quantum/action.c ****                     break;
 627:quantum/action.c **** #    endif
 628:quantum/action.c **** 
 629:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 630:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
 631:quantum/action.c ****                     /* tap toggle */
 632:quantum/action.c **** 
 633:quantum/action.c ****                     if (event.pressed) {
 634:quantum/action.c ****                         if (swap_held) {
 635:quantum/action.c ****                             swap_held = false;
 636:quantum/action.c ****                         } else {
 637:quantum/action.c ****                             swap_hands = !swap_hands;
 638:quantum/action.c ****                         }
 639:quantum/action.c ****                     } else {
 640:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 641:quantum/action.c ****                             swap_hands = !swap_hands;
 642:quantum/action.c ****                         }
 643:quantum/action.c ****                     }
 644:quantum/action.c ****                     break;
 645:quantum/action.c ****                 default:
 646:quantum/action.c ****                     /* tap key */
 647:quantum/action.c ****                     if (tap_count > 0) {
 648:quantum/action.c ****                         if (swap_held) {
 649:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 650:quantum/action.c ****                             swap_held  = false;
 651:quantum/action.c ****                         }
 652:quantum/action.c ****                         if (event.pressed) {
 653:quantum/action.c ****                             register_code(action.swap.code);
 654:quantum/action.c ****                         } else {
 655:quantum/action.c ****                             wait_ms(TAP_CODE_DELAY);
 656:quantum/action.c ****                             unregister_code(action.swap.code);
 657:quantum/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 658:quantum/action.c ****                         }
 659:quantum/action.c ****                     } else {
 660:quantum/action.c ****                         if (swap_held && !event.pressed) {
 661:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 662:quantum/action.c ****                             swap_held  = false;
 663:quantum/action.c ****                         }
 664:quantum/action.c ****                     }
 665:quantum/action.c **** #    endif
 666:quantum/action.c ****             }
 667:quantum/action.c **** #endif
 668:quantum/action.c **** #ifndef NO_ACTION_FUNCTION
 669:quantum/action.c ****         case ACT_FUNCTION:
 670:quantum/action.c ****             action_function(record, action.func.id, action.func.opt);
 671:quantum/action.c ****             break;
 672:quantum/action.c **** #endif
 673:quantum/action.c ****         default:
 674:quantum/action.c ****             break;
 675:quantum/action.c ****     }
 676:quantum/action.c **** 
 677:quantum/action.c **** #ifndef NO_ACTION_LAYER
 678:quantum/action.c ****     // if this event is a layer action, update the leds
 679:quantum/action.c ****     switch (action.kind.id) {
 680:quantum/action.c ****         case ACT_LAYER:
 681:quantum/action.c ****         case ACT_LAYER_MODS:
 682:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 683:quantum/action.c ****         case ACT_LAYER_TAP:
 684:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
 685:quantum/action.c **** #    endif
 686:quantum/action.c ****             led_set(host_keyboard_leds());
 687:quantum/action.c ****             break;
 688:quantum/action.c ****         default:
 689:quantum/action.c ****             break;
 690:quantum/action.c ****     }
 691:quantum/action.c **** #endif
 692:quantum/action.c **** 
 693:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 694:quantum/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 695:quantum/action.c ****     if (!is_tap_action(action)) {
 696:quantum/action.c ****         retro_tapping_counter = 0;
 697:quantum/action.c ****     } else {
 698:quantum/action.c ****         if (event.pressed) {
 699:quantum/action.c ****             if (tap_count > 0) {
 700:quantum/action.c ****                 retro_tapping_counter = 0;
 701:quantum/action.c ****             }
 702:quantum/action.c ****         } else {
 703:quantum/action.c ****             if (tap_count > 0) {
 704:quantum/action.c ****                 retro_tapping_counter = 0;
 705:quantum/action.c ****             } else {
 706:quantum/action.c ****                 if (
 707:quantum/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 708:quantum/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 709:quantum/action.c **** #        endif
 710:quantum/action.c ****                     retro_tapping_counter == 2) {
 711:quantum/action.c ****                     tap_code(action.layer_tap.code);
 712:quantum/action.c ****                 }
 713:quantum/action.c ****                 retro_tapping_counter = 0;
 714:quantum/action.c ****             }
 715:quantum/action.c ****         }
 716:quantum/action.c ****     }
 717:quantum/action.c **** #    endif
 718:quantum/action.c **** #endif
 719:quantum/action.c **** 
 720:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 721:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 722:quantum/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 723:quantum/action.c ****         use_oneshot_swaphands();
 724:quantum/action.c ****     }
 725:quantum/action.c **** #    endif
 726:quantum/action.c **** #endif
 727:quantum/action.c **** 
 728:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 729:quantum/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 730:quantum/action.c ****      * key before we leave the layer or no key up event will be generated.
 731:quantum/action.c ****      */
 732:quantum/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 733:quantum/action.c ****         record->event.pressed = false;
 734:quantum/action.c ****         layer_on(get_oneshot_layer());
 735:quantum/action.c ****         process_record(record);
 736:quantum/action.c ****         layer_off(get_oneshot_layer());
 737:quantum/action.c ****     }
 738:quantum/action.c **** #endif
 739:quantum/action.c **** }
 740:quantum/action.c **** 
 741:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 742:quantum/action.c ****  *
 743:quantum/action.c ****  * FIXME: Needs documentation.
 744:quantum/action.c ****  */
 745:quantum/action.c **** void register_code(uint8_t code) {
 212              		.loc 1 745 34 is_stmt 1 view -0
 213              		.cfi_startproc
 214              		@ args = 0, pretend = 0, frame = 0
 215              		@ frame_needed = 0, uses_anonymous_args = 0
 746:quantum/action.c ****     if (code == KC_NO) {
 216              		.loc 1 746 5 view .LVU36
 745:quantum/action.c ****     if (code == KC_NO) {
 217              		.loc 1 745 34 is_stmt 0 view .LVU37
 218 0000 10B5     		push	{r4, lr}
 219              		.cfi_def_cfa_offset 8
 220              		.cfi_offset 4, -8
 221              		.cfi_offset 14, -4
 222              		.loc 1 746 8 view .LVU38
 223 0002 0446     		mov	r4, r0
 224 0004 0028     		cmp	r0, #0
 225 0006 7AD0     		beq	.L16
 747:quantum/action.c ****         return;
 748:quantum/action.c ****     }
 749:quantum/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 750:quantum/action.c ****     else if (KC_LOCKING_CAPS == code) {
 226              		.loc 1 750 10 is_stmt 1 view .LVU39
 227              		.loc 1 750 13 is_stmt 0 view .LVU40
 228 0008 8228     		cmp	r0, #130
 229 000a 13D1     		bne	.L19
 751:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 752:quantum/action.c ****         // Resync: ignore if caps lock already is on
 753:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 230              		.loc 1 753 9 is_stmt 1 view .LVU41
 231              		.loc 1 753 13 is_stmt 0 view .LVU42
 232 000c FFF7FEFF 		bl	host_keyboard_leds
 233              	.LVL15:
 234              		.loc 1 753 12 view .LVU43
 235 0010 8107     		lsls	r1, r0, #30
 236 0012 74D4     		bmi	.L16
 754:quantum/action.c **** #    endif
 755:quantum/action.c ****         add_key(KC_CAPSLOCK);
 237              		.loc 1 755 9 is_stmt 1 view .LVU44
 238 0014 3920     		movs	r0, #57
 239 0016 FFF7FEFF 		bl	add_key
 240              	.LVL16:
 756:quantum/action.c ****         send_keyboard_report();
 241              		.loc 1 756 9 view .LVU45
 242 001a FFF7FEFF 		bl	send_keyboard_report
 243              	.LVL17:
 757:quantum/action.c ****         wait_ms(100);
 244              		.loc 1 757 9 view .LVU46
 245              		.loc 1 757 9 view .LVU47
 246              		.loc 1 757 9 view .LVU48
 247 001e 4FF47A70 		mov	r0, #1000
 248 0022 FFF7FEFF 		bl	chThdSleep
 249              	.LVL18:
 250              		.loc 1 757 9 view .LVU49
 758:quantum/action.c ****         del_key(KC_CAPSLOCK);
 251              		.loc 1 758 9 view .LVU50
 252 0026 3920     		movs	r0, #57
 253              	.L31:
 254              	.LBB25:
 255              	.LBB26:
 759:quantum/action.c ****         send_keyboard_report();
 760:quantum/action.c ****     }
 761:quantum/action.c **** 
 762:quantum/action.c ****     else if (KC_LOCKING_NUM == code) {
 763:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 764:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 765:quantum/action.c **** #    endif
 766:quantum/action.c ****         add_key(KC_NUMLOCK);
 767:quantum/action.c ****         send_keyboard_report();
 768:quantum/action.c ****         wait_ms(100);
 769:quantum/action.c ****         del_key(KC_NUMLOCK);
 256              		.loc 1 769 9 is_stmt 0 view .LVU51
 257 0028 FFF7FEFF 		bl	del_key
 258              	.LVL19:
 259              	.L32:
 770:quantum/action.c ****         send_keyboard_report();
 260              		.loc 1 770 9 is_stmt 1 view .LVU52
 261              	.LBE26:
 262              	.LBE25:
 771:quantum/action.c ****     }
 772:quantum/action.c **** 
 773:quantum/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 774:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 775:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 776:quantum/action.c **** #    endif
 777:quantum/action.c ****         add_key(KC_SCROLLLOCK);
 778:quantum/action.c ****         send_keyboard_report();
 779:quantum/action.c ****         wait_ms(100);
 780:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 781:quantum/action.c ****         send_keyboard_report();
 782:quantum/action.c ****     }
 783:quantum/action.c **** #endif
 784:quantum/action.c **** 
 785:quantum/action.c ****     else if IS_KEY (code) {
 786:quantum/action.c ****         // TODO: should push command_proc out of this block?
 787:quantum/action.c ****         if (command_proc(code)) return;
 788:quantum/action.c **** 
 789:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 790:quantum/action.c **** /* TODO: remove
 791:quantum/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 792:quantum/action.c ****             uint8_t tmp_mods = get_mods();
 793:quantum/action.c ****             add_mods(oneshot_state.mods);
 794:quantum/action.c **** 
 795:quantum/action.c ****             add_key(code);
 796:quantum/action.c ****             send_keyboard_report();
 797:quantum/action.c **** 
 798:quantum/action.c ****             set_mods(tmp_mods);
 799:quantum/action.c ****             send_keyboard_report();
 800:quantum/action.c ****             oneshot_cancel();
 801:quantum/action.c ****         } else
 802:quantum/action.c **** */
 803:quantum/action.c **** #endif
 804:quantum/action.c ****         {
 805:quantum/action.c ****             // Force a new key press if the key is already pressed
 806:quantum/action.c ****             // without this, keys with the same keycode, but different
 807:quantum/action.c ****             // modifiers will be reported incorrectly, see issue #1708
 808:quantum/action.c ****             if (is_key_pressed(keyboard_report, code)) {
 809:quantum/action.c ****                 del_key(code);
 810:quantum/action.c ****                 send_keyboard_report();
 811:quantum/action.c ****             }
 812:quantum/action.c ****             add_key(code);
 813:quantum/action.c ****             send_keyboard_report();
 814:quantum/action.c ****         }
 815:quantum/action.c ****     } else if IS_MOD (code) {
 816:quantum/action.c ****         add_mods(MOD_BIT(code));
 817:quantum/action.c ****         send_keyboard_report();
 818:quantum/action.c ****     }
 819:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 820:quantum/action.c ****     else if IS_SYSTEM (code) {
 821:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 822:quantum/action.c ****     } else if IS_CONSUMER (code) {
 823:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 824:quantum/action.c ****     }
 825:quantum/action.c **** #endif
 826:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 827:quantum/action.c ****     else if IS_MOUSEKEY (code) {
 828:quantum/action.c ****         mousekey_on(code);
 829:quantum/action.c ****         mousekey_send();
 830:quantum/action.c ****     }
 831:quantum/action.c **** #endif
 832:quantum/action.c **** }
 263              		.loc 1 832 1 is_stmt 0 view .LVU53
 264 002c BDE81040 		pop	{r4, lr}
 265              		.cfi_remember_state
 266              		.cfi_restore 14
 267              		.cfi_restore 4
 268              		.cfi_def_cfa_offset 0
 269              	.LBB33:
 270              	.LBB28:
 770:quantum/action.c ****         send_keyboard_report();
 271              		.loc 1 770 9 view .LVU54
 272 0030 FFF7FEBF 		b	send_keyboard_report
 273              	.LVL20:
 274              	.L19:
 275              		.cfi_restore_state
 770:quantum/action.c ****         send_keyboard_report();
 276              		.loc 1 770 9 view .LVU55
 277              	.LBE28:
 278              	.LBI25:
 745:quantum/action.c ****     if (code == KC_NO) {
 279              		.loc 1 745 6 is_stmt 1 view .LVU56
 280              	.LBB29:
 762:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 281              		.loc 1 762 10 view .LVU57
 762:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 282              		.loc 1 762 13 is_stmt 0 view .LVU58
 283 0034 8328     		cmp	r0, #131
 284 0036 0ED1     		bne	.L21
 764:quantum/action.c **** #    endif
 285              		.loc 1 764 9 is_stmt 1 view .LVU59
 764:quantum/action.c **** #    endif
 286              		.loc 1 764 13 is_stmt 0 view .LVU60
 287 0038 FFF7FEFF 		bl	host_keyboard_leds
 288              	.LVL21:
 764:quantum/action.c **** #    endif
 289              		.loc 1 764 12 view .LVU61
 290 003c C207     		lsls	r2, r0, #31
 291 003e 5ED4     		bmi	.L16
 766:quantum/action.c ****         send_keyboard_report();
 292              		.loc 1 766 9 is_stmt 1 view .LVU62
 293 0040 5320     		movs	r0, #83
 294 0042 FFF7FEFF 		bl	add_key
 295              	.LVL22:
 767:quantum/action.c ****         wait_ms(100);
 296              		.loc 1 767 9 view .LVU63
 297 0046 FFF7FEFF 		bl	send_keyboard_report
 298              	.LVL23:
 768:quantum/action.c ****         del_key(KC_NUMLOCK);
 299              		.loc 1 768 9 view .LVU64
 768:quantum/action.c ****         del_key(KC_NUMLOCK);
 300              		.loc 1 768 9 view .LVU65
 768:quantum/action.c ****         del_key(KC_NUMLOCK);
 301              		.loc 1 768 9 view .LVU66
 302 004a 4FF47A70 		mov	r0, #1000
 303 004e FFF7FEFF 		bl	chThdSleep
 304              	.LVL24:
 768:quantum/action.c ****         del_key(KC_NUMLOCK);
 305              		.loc 1 768 9 view .LVU67
 769:quantum/action.c ****         send_keyboard_report();
 306              		.loc 1 769 9 view .LVU68
 307 0052 5320     		movs	r0, #83
 308 0054 E8E7     		b	.L31
 309              	.LVL25:
 310              	.L21:
 773:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 311              		.loc 1 773 10 view .LVU69
 773:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 312              		.loc 1 773 13 is_stmt 0 view .LVU70
 313 0056 8428     		cmp	r0, #132
 314 0058 0ED1     		bne	.L22
 775:quantum/action.c **** #    endif
 315              		.loc 1 775 9 is_stmt 1 view .LVU71
 775:quantum/action.c **** #    endif
 316              		.loc 1 775 13 is_stmt 0 view .LVU72
 317 005a FFF7FEFF 		bl	host_keyboard_leds
 318              	.LVL26:
 775:quantum/action.c **** #    endif
 319              		.loc 1 775 12 view .LVU73
 320 005e 4307     		lsls	r3, r0, #29
 321 0060 4DD4     		bmi	.L16
 777:quantum/action.c ****         send_keyboard_report();
 322              		.loc 1 777 9 is_stmt 1 view .LVU74
 323 0062 4720     		movs	r0, #71
 324 0064 FFF7FEFF 		bl	add_key
 325              	.LVL27:
 778:quantum/action.c ****         wait_ms(100);
 326              		.loc 1 778 9 view .LVU75
 327 0068 FFF7FEFF 		bl	send_keyboard_report
 328              	.LVL28:
 779:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 329              		.loc 1 779 9 view .LVU76
 779:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 330              		.loc 1 779 9 view .LVU77
 779:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 331              		.loc 1 779 9 view .LVU78
 332 006c 4FF47A70 		mov	r0, #1000
 333 0070 FFF7FEFF 		bl	chThdSleep
 334              	.LVL29:
 779:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 335              		.loc 1 779 9 view .LVU79
 780:quantum/action.c ****         send_keyboard_report();
 336              		.loc 1 780 9 view .LVU80
 337 0074 4720     		movs	r0, #71
 338 0076 D7E7     		b	.L31
 339              	.LVL30:
 340              	.L22:
 785:quantum/action.c ****         // TODO: should push command_proc out of this block?
 341              		.loc 1 785 10 view .LVU81
 785:quantum/action.c ****         // TODO: should push command_proc out of this block?
 342              		.loc 1 785 13 is_stmt 0 view .LVU82
 343 0078 031F     		subs	r3, r0, #4
 344 007a DBB2     		uxtb	r3, r3
 345 007c A02B     		cmp	r3, #160
 346 007e 12D8     		bhi	.L23
 787:quantum/action.c **** 
 347              		.loc 1 787 9 is_stmt 1 view .LVU83
 787:quantum/action.c **** 
 348              		.loc 1 787 13 is_stmt 0 view .LVU84
 349 0080 FFF7FEFF 		bl	command_proc
 350              	.LVL31:
 787:quantum/action.c **** 
 351              		.loc 1 787 12 view .LVU85
 352 0084 0028     		cmp	r0, #0
 353 0086 3AD1     		bne	.L16
 808:quantum/action.c ****                 del_key(code);
 354              		.loc 1 808 13 is_stmt 1 view .LVU86
 808:quantum/action.c ****                 del_key(code);
 355              		.loc 1 808 17 is_stmt 0 view .LVU87
 356 0088 1D4B     		ldr	r3, .L33
 357 008a 2146     		mov	r1, r4
 358 008c 1868     		ldr	r0, [r3]
 359 008e FFF7FEFF 		bl	is_key_pressed
 360              	.LVL32:
 808:quantum/action.c ****                 del_key(code);
 361              		.loc 1 808 16 view .LVU88
 362 0092 20B1     		cbz	r0, .L24
 809:quantum/action.c ****                 send_keyboard_report();
 363              		.loc 1 809 17 is_stmt 1 view .LVU89
 364 0094 2046     		mov	r0, r4
 365 0096 FFF7FEFF 		bl	del_key
 366              	.LVL33:
 810:quantum/action.c ****             }
 367              		.loc 1 810 17 view .LVU90
 368 009a FFF7FEFF 		bl	send_keyboard_report
 369              	.LVL34:
 370              	.L24:
 812:quantum/action.c ****             send_keyboard_report();
 371              		.loc 1 812 13 view .LVU91
 372 009e 2046     		mov	r0, r4
 373 00a0 FFF7FEFF 		bl	add_key
 374              	.LVL35:
 813:quantum/action.c ****         }
 375              		.loc 1 813 13 view .LVU92
 376 00a4 C2E7     		b	.L32
 377              	.LVL36:
 378              	.L23:
 815:quantum/action.c ****         add_mods(MOD_BIT(code));
 379              		.loc 1 815 12 view .LVU93
 815:quantum/action.c ****         add_mods(MOD_BIT(code));
 380              		.loc 1 815 15 is_stmt 0 view .LVU94
 381 00a6 00F12003 		add	r3, r0, #32
 382 00aa DBB2     		uxtb	r3, r3
 383 00ac 072B     		cmp	r3, #7
 384 00ae 07D8     		bhi	.L25
 816:quantum/action.c ****         send_keyboard_report();
 385              		.loc 1 816 9 is_stmt 1 view .LVU95
 816:quantum/action.c ****         send_keyboard_report();
 386              		.loc 1 816 18 is_stmt 0 view .LVU96
 387 00b0 00F00704 		and	r4, r0, #7
 388 00b4 0120     		movs	r0, #1
 389              	.LVL37:
 816:quantum/action.c ****         send_keyboard_report();
 390              		.loc 1 816 18 view .LVU97
 391 00b6 A040     		lsls	r0, r0, r4
 816:quantum/action.c ****         send_keyboard_report();
 392              		.loc 1 816 9 view .LVU98
 393 00b8 C0B2     		uxtb	r0, r0
 394 00ba FFF7FEFF 		bl	add_mods
 395              	.LVL38:
 817:quantum/action.c ****     }
 396              		.loc 1 817 9 is_stmt 1 view .LVU99
 397 00be B5E7     		b	.L32
 398              	.LVL39:
 399              	.L25:
 820:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 400              		.loc 1 820 10 view .LVU100
 820:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 401              		.loc 1 820 13 is_stmt 0 view .LVU101
 402 00c0 00F15B03 		add	r3, r0, #91
 403 00c4 DBB2     		uxtb	r3, r3
 404 00c6 022B     		cmp	r3, #2
 405 00c8 05D8     		bhi	.L26
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 406              		.loc 1 821 9 is_stmt 1 view .LVU102
 407 00ca 2438     		subs	r0, r0, #36
 408              	.LVL40:
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 409              		.loc 1 821 9 is_stmt 0 view .LVU103
 410              	.LBE29:
 411              	.LBE33:
 412              		.loc 1 832 1 view .LVU104
 413 00cc BDE81040 		pop	{r4, lr}
 414              		.cfi_remember_state
 415              		.cfi_restore 14
 416              		.cfi_restore 4
 417              		.cfi_def_cfa_offset 0
 418              	.LVL41:
 419              	.LBB34:
 420              	.LBB30:
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 421              		.loc 1 821 9 view .LVU105
 422 00d0 80B2     		uxth	r0, r0
 423              	.LVL42:
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 424              		.loc 1 821 9 view .LVU106
 425 00d2 FFF7FEBF 		b	host_system_send
 426              	.LVL43:
 427              	.L26:
 428              		.cfi_restore_state
 822:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 429              		.loc 1 822 12 is_stmt 1 view .LVU107
 822:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 430              		.loc 1 822 15 is_stmt 0 view .LVU108
 431 00d6 00F15803 		add	r3, r0, #88
 432 00da DBB2     		uxtb	r3, r3
 433 00dc 162B     		cmp	r3, #22
 434 00de 06D8     		bhi	.L27
 823:quantum/action.c ****     }
 435              		.loc 1 823 9 is_stmt 1 view .LVU109
 436              	.LVL44:
 437              	.LBB27:
 438              	.LBI27:
 439              		.file 3 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK,
  34:tmk_core/common/report.h ****     REPORT_ID_DIGITIZER
  35:tmk_core/common/report.h **** };
  36:tmk_core/common/report.h **** 
  37:tmk_core/common/report.h **** /* Mouse buttons */
  38:tmk_core/common/report.h **** #define MOUSE_BTN_MASK(n) (1 << (n))
  39:tmk_core/common/report.h **** enum mouse_buttons {
  40:tmk_core/common/report.h ****     MOUSE_BTN1 = MOUSE_BTN_MASK(0),
  41:tmk_core/common/report.h ****     MOUSE_BTN2 = MOUSE_BTN_MASK(1),
  42:tmk_core/common/report.h ****     MOUSE_BTN3 = MOUSE_BTN_MASK(2),
  43:tmk_core/common/report.h ****     MOUSE_BTN4 = MOUSE_BTN_MASK(3),
  44:tmk_core/common/report.h ****     MOUSE_BTN5 = MOUSE_BTN_MASK(4),
  45:tmk_core/common/report.h ****     MOUSE_BTN6 = MOUSE_BTN_MASK(5),
  46:tmk_core/common/report.h ****     MOUSE_BTN7 = MOUSE_BTN_MASK(6),
  47:tmk_core/common/report.h ****     MOUSE_BTN8 = MOUSE_BTN_MASK(7)
  48:tmk_core/common/report.h **** };
  49:tmk_core/common/report.h **** 
  50:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  51:tmk_core/common/report.h ****  *
  52:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  53:tmk_core/common/report.h ****  */
  54:tmk_core/common/report.h **** enum consumer_usages {
  55:tmk_core/common/report.h ****     // 15.5 Display Controls
  56:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  57:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  58:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  59:tmk_core/common/report.h ****     // 15.7 Transport Controls
  60:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  61:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  62:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  63:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  64:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  65:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  66:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  67:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  68:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  69:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  70:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  71:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  72:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  73:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  74:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  75:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  76:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  77:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  78:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  79:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  80:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  81:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  82:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  83:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  84:tmk_core/common/report.h ****     AC_NEW                 = 0x201,
  85:tmk_core/common/report.h ****     AC_OPEN                = 0x202,
  86:tmk_core/common/report.h ****     AC_CLOSE               = 0x203,
  87:tmk_core/common/report.h ****     AC_EXIT                = 0x204,
  88:tmk_core/common/report.h ****     AC_MAXIMIZE            = 0x205,
  89:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  90:tmk_core/common/report.h ****     AC_SAVE                = 0x207,
  91:tmk_core/common/report.h ****     AC_PRINT               = 0x208,
  92:tmk_core/common/report.h ****     AC_PROPERTIES          = 0x209,
  93:tmk_core/common/report.h ****     AC_UNDO                = 0x21A,
  94:tmk_core/common/report.h ****     AC_COPY                = 0x21B,
  95:tmk_core/common/report.h ****     AC_CUT                 = 0x21C,
  96:tmk_core/common/report.h ****     AC_PASTE               = 0x21D,
  97:tmk_core/common/report.h ****     AC_SELECT_ALL          = 0x21E,
  98:tmk_core/common/report.h ****     AC_FIND                = 0x21F,
  99:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
 100:tmk_core/common/report.h ****     AC_HOME                = 0x223,
 101:tmk_core/common/report.h ****     AC_BACK                = 0x224,
 102:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
 103:tmk_core/common/report.h ****     AC_STOP                = 0x226,
 104:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
 105:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
 106:tmk_core/common/report.h **** };
 107:tmk_core/common/report.h **** 
 108:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
 109:tmk_core/common/report.h ****  *
 110:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
 111:tmk_core/common/report.h ****  */
 112:tmk_core/common/report.h **** enum desktop_usages {
 113:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
 114:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN             = 0x81,
 115:tmk_core/common/report.h ****     SYSTEM_SLEEP                  = 0x82,
 116:tmk_core/common/report.h ****     SYSTEM_WAKE_UP                = 0x83,
 117:tmk_core/common/report.h ****     SYSTEM_RESTART                = 0x8F,
 118:tmk_core/common/report.h ****     // 4.10 System Display Controls
 119:tmk_core/common/report.h ****     SYSTEM_DISPLAY_TOGGLE_INT_EXT = 0xB5
 120:tmk_core/common/report.h **** };
 121:tmk_core/common/report.h **** 
 122:tmk_core/common/report.h **** // clang-format on
 123:tmk_core/common/report.h **** 
 124:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 125:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 126:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 127:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 128:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 129:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 130:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 131:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 132:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 133:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 134:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 135:tmk_core/common/report.h **** #    else
 136:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 137:tmk_core/common/report.h **** #    endif
 138:tmk_core/common/report.h **** #endif
 139:tmk_core/common/report.h **** 
 140:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 141:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 142:tmk_core/common/report.h **** #else
 143:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 144:tmk_core/common/report.h **** #endif
 145:tmk_core/common/report.h **** 
 146:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 147:tmk_core/common/report.h **** 
 148:tmk_core/common/report.h **** #ifdef __cplusplus
 149:tmk_core/common/report.h **** extern "C" {
 150:tmk_core/common/report.h **** #endif
 151:tmk_core/common/report.h **** 
 152:tmk_core/common/report.h **** /*
 153:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 154:tmk_core/common/report.h ****  *
 155:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 156:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 157:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 158:tmk_core/common/report.h ****  *
 159:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 160:tmk_core/common/report.h ****  *
 161:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 162:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 163:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 164:tmk_core/common/report.h ****  *
 165:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 166:tmk_core/common/report.h ****  *
 167:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 168:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 169:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 170:tmk_core/common/report.h ****  *
 171:tmk_core/common/report.h ****  */
 172:tmk_core/common/report.h **** typedef union {
 173:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 174:tmk_core/common/report.h ****     struct {
 175:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 176:tmk_core/common/report.h ****         uint8_t report_id;
 177:tmk_core/common/report.h **** #endif
 178:tmk_core/common/report.h ****         uint8_t mods;
 179:tmk_core/common/report.h ****         uint8_t reserved;
 180:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 181:tmk_core/common/report.h ****     };
 182:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 183:tmk_core/common/report.h ****     struct nkro_report {
 184:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 185:tmk_core/common/report.h ****         uint8_t report_id;
 186:tmk_core/common/report.h **** #    endif
 187:tmk_core/common/report.h ****         uint8_t mods;
 188:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 189:tmk_core/common/report.h ****     } nkro;
 190:tmk_core/common/report.h **** #endif
 191:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 192:tmk_core/common/report.h **** 
 193:tmk_core/common/report.h **** typedef struct {
 194:tmk_core/common/report.h ****     uint8_t  report_id;
 195:tmk_core/common/report.h ****     uint16_t usage;
 196:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 197:tmk_core/common/report.h **** 
 198:tmk_core/common/report.h **** typedef struct {
 199:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 200:tmk_core/common/report.h ****     uint8_t report_id;
 201:tmk_core/common/report.h **** #endif
 202:tmk_core/common/report.h ****     uint8_t buttons;
 203:tmk_core/common/report.h ****     int8_t  x;
 204:tmk_core/common/report.h ****     int8_t  y;
 205:tmk_core/common/report.h ****     int8_t  v;
 206:tmk_core/common/report.h ****     int8_t  h;
 207:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 208:tmk_core/common/report.h **** 
 209:tmk_core/common/report.h **** typedef struct {
 210:tmk_core/common/report.h **** #ifdef DIGITIZER_SHARED_EP
 211:tmk_core/common/report.h ****     uint8_t report_id;
 212:tmk_core/common/report.h **** #endif
 213:tmk_core/common/report.h ****     uint8_t  tip : 1;
 214:tmk_core/common/report.h ****     uint8_t  inrange : 1;
 215:tmk_core/common/report.h ****     uint8_t  pad2 : 6;
 216:tmk_core/common/report.h ****     uint16_t x;
 217:tmk_core/common/report.h ****     uint16_t y;
 218:tmk_core/common/report.h **** } __attribute__((packed)) report_digitizer_t;
 219:tmk_core/common/report.h **** 
 220:tmk_core/common/report.h **** typedef struct {
 221:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 222:tmk_core/common/report.h **** #    if JOYSTICK_AXES_RESOLUTION > 8
 223:tmk_core/common/report.h ****     int16_t axes[JOYSTICK_AXES_COUNT];
 224:tmk_core/common/report.h **** #    else
 225:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 226:tmk_core/common/report.h **** #    endif
 227:tmk_core/common/report.h **** #endif
 228:tmk_core/common/report.h **** 
 229:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 230:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 231:tmk_core/common/report.h **** #endif
 232:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 233:tmk_core/common/report.h **** 
 234:tmk_core/common/report.h **** /* keycode to system usage */
 235:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 236:tmk_core/common/report.h ****     switch (key) {
 237:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 238:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 239:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 240:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 241:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 242:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 243:tmk_core/common/report.h ****         default:
 244:tmk_core/common/report.h ****             return 0;
 245:tmk_core/common/report.h ****     }
 246:tmk_core/common/report.h **** }
 247:tmk_core/common/report.h **** 
 248:tmk_core/common/report.h **** /* keycode to consumer usage */
 249:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 440              		.loc 3 249 24 view .LVU110
 250:tmk_core/common/report.h ****     switch (key) {
 441              		.loc 3 250 5 view .LVU111
 442              		.loc 3 250 5 is_stmt 0 view .LVU112
 443              	.LBE27:
 823:quantum/action.c ****     }
 444              		.loc 1 823 9 view .LVU113
 445 00e0 084A     		ldr	r2, .L33+4
 446              	.LBE30:
 447              	.LBE34:
 448              		.loc 1 832 1 view .LVU114
 449 00e2 BDE81040 		pop	{r4, lr}
 450              		.cfi_remember_state
 451              		.cfi_restore 14
 452              		.cfi_restore 4
 453              		.cfi_def_cfa_offset 0
 454              	.LBB35:
 455              	.LBB31:
 823:quantum/action.c ****     }
 456              		.loc 1 823 9 view .LVU115
 457 00e6 32F81300 		ldrh	r0, [r2, r3, lsl #1]
 458              	.LVL45:
 823:quantum/action.c ****     }
 459              		.loc 1 823 9 view .LVU116
 460 00ea FFF7FEBF 		b	host_consumer_send
 461              	.LVL46:
 462              	.L27:
 463              		.cfi_restore_state
 827:quantum/action.c ****         mousekey_on(code);
 464              		.loc 1 827 10 is_stmt 1 view .LVU117
 827:quantum/action.c ****         mousekey_on(code);
 465              		.loc 1 827 13 is_stmt 0 view .LVU118
 466 00ee EC28     		cmp	r0, #236
 467 00f0 05D9     		bls	.L16
 828:quantum/action.c ****         mousekey_send();
 468              		.loc 1 828 9 is_stmt 1 view .LVU119
 469 00f2 FFF7FEFF 		bl	mousekey_on
 470              	.LVL47:
 829:quantum/action.c ****     }
 471              		.loc 1 829 9 view .LVU120
 472              	.LBE31:
 473              	.LBE35:
 474              		.loc 1 832 1 is_stmt 0 view .LVU121
 475 00f6 BDE81040 		pop	{r4, lr}
 476              		.cfi_remember_state
 477              		.cfi_restore 14
 478              		.cfi_restore 4
 479              		.cfi_def_cfa_offset 0
 480              	.LVL48:
 481              	.LBB36:
 482              	.LBB32:
 829:quantum/action.c ****     }
 483              		.loc 1 829 9 view .LVU122
 484 00fa FFF7FEBF 		b	mousekey_send
 485              	.LVL49:
 486              	.L16:
 487              		.cfi_restore_state
 829:quantum/action.c ****     }
 488              		.loc 1 829 9 view .LVU123
 489              	.LBE32:
 490              	.LBE36:
 491              		.loc 1 832 1 view .LVU124
 492 00fe 10BD     		pop	{r4, pc}
 493              	.L34:
 494              		.align	2
 495              	.L33:
 496 0100 00000000 		.word	keyboard_report
 497 0104 00000000 		.word	CSWTCH.14
 498              		.cfi_endproc
 499              	.LFE300:
 501              		.section	.text.unregister_code,"ax",%progbits
 502              		.align	1
 503              		.global	unregister_code
 504              		.syntax unified
 505              		.thumb
 506              		.thumb_func
 508              	unregister_code:
 509              	.LVL50:
 510              	.LFB301:
 833:quantum/action.c **** 
 834:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 835:quantum/action.c ****  *
 836:quantum/action.c ****  * FIXME: Needs documentation.
 837:quantum/action.c ****  */
 838:quantum/action.c **** void unregister_code(uint8_t code) {
 511              		.loc 1 838 36 is_stmt 1 view -0
 512              		.cfi_startproc
 513              		@ args = 0, pretend = 0, frame = 0
 514              		@ frame_needed = 0, uses_anonymous_args = 0
 839:quantum/action.c ****     if (code == KC_NO) {
 515              		.loc 1 839 5 view .LVU126
 838:quantum/action.c ****     if (code == KC_NO) {
 516              		.loc 1 838 36 is_stmt 0 view .LVU127
 517 0000 08B5     		push	{r3, lr}
 518              		.cfi_def_cfa_offset 8
 519              		.cfi_offset 3, -8
 520              		.cfi_offset 14, -4
 521              		.loc 1 839 8 view .LVU128
 522 0002 0028     		cmp	r0, #0
 523 0004 58D0     		beq	.L35
 840:quantum/action.c ****         return;
 841:quantum/action.c ****     }
 842:quantum/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 843:quantum/action.c ****     else if (KC_LOCKING_CAPS == code) {
 524              		.loc 1 843 10 is_stmt 1 view .LVU129
 525              		.loc 1 843 13 is_stmt 0 view .LVU130
 526 0006 8228     		cmp	r0, #130
 527 0008 0FD1     		bne	.L38
 844:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 845:quantum/action.c ****         // Resync: ignore if caps lock already is off
 846:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 528              		.loc 1 846 9 is_stmt 1 view .LVU131
 529              		.loc 1 846 15 is_stmt 0 view .LVU132
 530 000a FFF7FEFF 		bl	host_keyboard_leds
 531              	.LVL51:
 532              		.loc 1 846 12 view .LVU133
 533 000e 8107     		lsls	r1, r0, #30
 534 0010 52D5     		bpl	.L35
 847:quantum/action.c **** #    endif
 848:quantum/action.c ****         add_key(KC_CAPSLOCK);
 535              		.loc 1 848 9 is_stmt 1 view .LVU134
 536 0012 3920     		movs	r0, #57
 537 0014 FFF7FEFF 		bl	add_key
 538              	.LVL52:
 849:quantum/action.c ****         send_keyboard_report();
 539              		.loc 1 849 9 view .LVU135
 540 0018 FFF7FEFF 		bl	send_keyboard_report
 541              	.LVL53:
 850:quantum/action.c ****         del_key(KC_CAPSLOCK);
 542              		.loc 1 850 9 view .LVU136
 543 001c 3920     		movs	r0, #57
 544              	.L55:
 545              	.LBB39:
 546              	.LBB40:
 851:quantum/action.c ****         send_keyboard_report();
 852:quantum/action.c ****     }
 853:quantum/action.c **** 
 854:quantum/action.c ****     else if (KC_LOCKING_NUM == code) {
 855:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 856:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 857:quantum/action.c **** #    endif
 858:quantum/action.c ****         add_key(KC_NUMLOCK);
 859:quantum/action.c ****         send_keyboard_report();
 860:quantum/action.c ****         del_key(KC_NUMLOCK);
 547              		.loc 1 860 9 is_stmt 0 view .LVU137
 548 001e FFF7FEFF 		bl	del_key
 549              	.LVL54:
 550              	.L56:
 861:quantum/action.c ****         send_keyboard_report();
 551              		.loc 1 861 9 is_stmt 1 view .LVU138
 552              	.LBE40:
 553              	.LBE39:
 862:quantum/action.c ****     }
 863:quantum/action.c **** 
 864:quantum/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 865:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 866:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 867:quantum/action.c **** #    endif
 868:quantum/action.c ****         add_key(KC_SCROLLLOCK);
 869:quantum/action.c ****         send_keyboard_report();
 870:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 871:quantum/action.c ****         send_keyboard_report();
 872:quantum/action.c ****     }
 873:quantum/action.c **** #endif
 874:quantum/action.c **** 
 875:quantum/action.c ****     else if IS_KEY (code) {
 876:quantum/action.c ****         del_key(code);
 877:quantum/action.c ****         send_keyboard_report();
 878:quantum/action.c ****     } else if IS_MOD (code) {
 879:quantum/action.c ****         del_mods(MOD_BIT(code));
 880:quantum/action.c ****         send_keyboard_report();
 881:quantum/action.c ****     } else if IS_SYSTEM (code) {
 882:quantum/action.c ****         host_system_send(0);
 883:quantum/action.c ****     } else if IS_CONSUMER (code) {
 884:quantum/action.c ****         host_consumer_send(0);
 885:quantum/action.c ****     }
 886:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 887:quantum/action.c ****     else if IS_MOUSEKEY (code) {
 888:quantum/action.c ****         mousekey_off(code);
 889:quantum/action.c ****         mousekey_send();
 890:quantum/action.c ****     }
 891:quantum/action.c **** #endif
 892:quantum/action.c **** }
 554              		.loc 1 892 1 is_stmt 0 view .LVU139
 555 0022 BDE80840 		pop	{r3, lr}
 556              		.cfi_remember_state
 557              		.cfi_restore 14
 558              		.cfi_restore 3
 559              		.cfi_def_cfa_offset 0
 560              	.LBB46:
 561              	.LBB41:
 861:quantum/action.c ****         send_keyboard_report();
 562              		.loc 1 861 9 view .LVU140
 563 0026 FFF7FEBF 		b	send_keyboard_report
 564              	.LVL55:
 565              	.L38:
 566              		.cfi_restore_state
 861:quantum/action.c ****         send_keyboard_report();
 567              		.loc 1 861 9 view .LVU141
 568              	.LBE41:
 569              	.LBI39:
 838:quantum/action.c ****     if (code == KC_NO) {
 570              		.loc 1 838 6 is_stmt 1 view .LVU142
 571              	.LBB42:
 854:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 572              		.loc 1 854 10 view .LVU143
 854:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 573              		.loc 1 854 13 is_stmt 0 view .LVU144
 574 002a 8328     		cmp	r0, #131
 575 002c 0AD1     		bne	.L40
 856:quantum/action.c **** #    endif
 576              		.loc 1 856 9 is_stmt 1 view .LVU145
 856:quantum/action.c **** #    endif
 577              		.loc 1 856 15 is_stmt 0 view .LVU146
 578 002e FFF7FEFF 		bl	host_keyboard_leds
 579              	.LVL56:
 856:quantum/action.c **** #    endif
 580              		.loc 1 856 12 view .LVU147
 581 0032 C207     		lsls	r2, r0, #31
 582 0034 40D5     		bpl	.L35
 858:quantum/action.c ****         send_keyboard_report();
 583              		.loc 1 858 9 is_stmt 1 view .LVU148
 584 0036 5320     		movs	r0, #83
 585 0038 FFF7FEFF 		bl	add_key
 586              	.LVL57:
 859:quantum/action.c ****         del_key(KC_NUMLOCK);
 587              		.loc 1 859 9 view .LVU149
 588 003c FFF7FEFF 		bl	send_keyboard_report
 589              	.LVL58:
 860:quantum/action.c ****         send_keyboard_report();
 590              		.loc 1 860 9 view .LVU150
 591 0040 5320     		movs	r0, #83
 592 0042 ECE7     		b	.L55
 593              	.LVL59:
 594              	.L40:
 864:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 595              		.loc 1 864 10 view .LVU151
 864:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 596              		.loc 1 864 13 is_stmt 0 view .LVU152
 597 0044 8428     		cmp	r0, #132
 598 0046 0AD1     		bne	.L41
 866:quantum/action.c **** #    endif
 599              		.loc 1 866 9 is_stmt 1 view .LVU153
 866:quantum/action.c **** #    endif
 600              		.loc 1 866 15 is_stmt 0 view .LVU154
 601 0048 FFF7FEFF 		bl	host_keyboard_leds
 602              	.LVL60:
 866:quantum/action.c **** #    endif
 603              		.loc 1 866 12 view .LVU155
 604 004c 4307     		lsls	r3, r0, #29
 605 004e 33D5     		bpl	.L35
 868:quantum/action.c ****         send_keyboard_report();
 606              		.loc 1 868 9 is_stmt 1 view .LVU156
 607 0050 4720     		movs	r0, #71
 608 0052 FFF7FEFF 		bl	add_key
 609              	.LVL61:
 869:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 610              		.loc 1 869 9 view .LVU157
 611 0056 FFF7FEFF 		bl	send_keyboard_report
 612              	.LVL62:
 870:quantum/action.c ****         send_keyboard_report();
 613              		.loc 1 870 9 view .LVU158
 614 005a 4720     		movs	r0, #71
 615 005c DFE7     		b	.L55
 616              	.LVL63:
 617              	.L41:
 875:quantum/action.c ****         del_key(code);
 618              		.loc 1 875 10 view .LVU159
 875:quantum/action.c ****         del_key(code);
 619              		.loc 1 875 13 is_stmt 0 view .LVU160
 620 005e 021F     		subs	r2, r0, #4
 621 0060 D2B2     		uxtb	r2, r2
 622 0062 A02A     		cmp	r2, #160
 623 0064 DBD9     		bls	.L55
 878:quantum/action.c ****         del_mods(MOD_BIT(code));
 624              		.loc 1 878 12 is_stmt 1 view .LVU161
 878:quantum/action.c ****         del_mods(MOD_BIT(code));
 625              		.loc 1 878 15 is_stmt 0 view .LVU162
 626 0066 00F12002 		add	r2, r0, #32
 627 006a D2B2     		uxtb	r2, r2
 628 006c 072A     		cmp	r2, #7
 629 006e 07D8     		bhi	.L43
 879:quantum/action.c ****         send_keyboard_report();
 630              		.loc 1 879 9 is_stmt 1 view .LVU163
 879:quantum/action.c ****         send_keyboard_report();
 631              		.loc 1 879 18 is_stmt 0 view .LVU164
 632 0070 00F00703 		and	r3, r0, #7
 633 0074 0120     		movs	r0, #1
 634              	.LVL64:
 879:quantum/action.c ****         send_keyboard_report();
 635              		.loc 1 879 18 view .LVU165
 636 0076 9840     		lsls	r0, r0, r3
 879:quantum/action.c ****         send_keyboard_report();
 637              		.loc 1 879 9 view .LVU166
 638 0078 C0B2     		uxtb	r0, r0
 639 007a FFF7FEFF 		bl	del_mods
 640              	.LVL65:
 880:quantum/action.c ****     } else if IS_SYSTEM (code) {
 641              		.loc 1 880 9 is_stmt 1 view .LVU167
 642 007e D0E7     		b	.L56
 643              	.LVL66:
 644              	.L43:
 881:quantum/action.c ****         host_system_send(0);
 645              		.loc 1 881 12 view .LVU168
 881:quantum/action.c ****         host_system_send(0);
 646              		.loc 1 881 15 is_stmt 0 view .LVU169
 647 0080 00F15B02 		add	r2, r0, #91
 648 0084 D2B2     		uxtb	r2, r2
 649 0086 022A     		cmp	r2, #2
 650 0088 04D8     		bhi	.L44
 882:quantum/action.c ****     } else if IS_CONSUMER (code) {
 651              		.loc 1 882 9 is_stmt 1 view .LVU170
 652              	.LBE42:
 653              	.LBE46:
 654              		.loc 1 892 1 is_stmt 0 view .LVU171
 655 008a BDE80840 		pop	{r3, lr}
 656              		.cfi_remember_state
 657              		.cfi_restore 14
 658              		.cfi_restore 3
 659              		.cfi_def_cfa_offset 0
 660              	.LBB47:
 661              	.LBB43:
 882:quantum/action.c ****     } else if IS_CONSUMER (code) {
 662              		.loc 1 882 9 view .LVU172
 663 008e 0020     		movs	r0, #0
 664              	.LVL67:
 882:quantum/action.c ****     } else if IS_CONSUMER (code) {
 665              		.loc 1 882 9 view .LVU173
 666 0090 FFF7FEBF 		b	host_system_send
 667              	.LVL68:
 668              	.L44:
 669              		.cfi_restore_state
 883:quantum/action.c ****         host_consumer_send(0);
 670              		.loc 1 883 12 is_stmt 1 view .LVU174
 883:quantum/action.c ****         host_consumer_send(0);
 671              		.loc 1 883 15 is_stmt 0 view .LVU175
 672 0094 00F15802 		add	r2, r0, #88
 673 0098 D2B2     		uxtb	r2, r2
 674 009a 162A     		cmp	r2, #22
 675 009c 04D8     		bhi	.L45
 884:quantum/action.c ****     }
 676              		.loc 1 884 9 is_stmt 1 view .LVU176
 677              	.LBE43:
 678              	.LBE47:
 679              		.loc 1 892 1 is_stmt 0 view .LVU177
 680 009e BDE80840 		pop	{r3, lr}
 681              		.cfi_remember_state
 682              		.cfi_restore 14
 683              		.cfi_restore 3
 684              		.cfi_def_cfa_offset 0
 685              	.LBB48:
 686              	.LBB44:
 884:quantum/action.c ****     }
 687              		.loc 1 884 9 view .LVU178
 688 00a2 0020     		movs	r0, #0
 689              	.LVL69:
 884:quantum/action.c ****     }
 690              		.loc 1 884 9 view .LVU179
 691 00a4 FFF7FEBF 		b	host_consumer_send
 692              	.LVL70:
 693              	.L45:
 694              		.cfi_restore_state
 887:quantum/action.c ****         mousekey_off(code);
 695              		.loc 1 887 10 is_stmt 1 view .LVU180
 887:quantum/action.c ****         mousekey_off(code);
 696              		.loc 1 887 13 is_stmt 0 view .LVU181
 697 00a8 EC28     		cmp	r0, #236
 698 00aa 05D9     		bls	.L35
 888:quantum/action.c ****         mousekey_send();
 699              		.loc 1 888 9 is_stmt 1 view .LVU182
 700 00ac FFF7FEFF 		bl	mousekey_off
 701              	.LVL71:
 889:quantum/action.c ****     }
 702              		.loc 1 889 9 view .LVU183
 703              	.LBE44:
 704              	.LBE48:
 705              		.loc 1 892 1 is_stmt 0 view .LVU184
 706 00b0 BDE80840 		pop	{r3, lr}
 707              		.cfi_remember_state
 708              		.cfi_restore 14
 709              		.cfi_restore 3
 710              		.cfi_def_cfa_offset 0
 711              	.LBB49:
 712              	.LBB45:
 889:quantum/action.c ****     }
 713              		.loc 1 889 9 view .LVU185
 714 00b4 FFF7FEBF 		b	mousekey_send
 715              	.LVL72:
 716              	.L35:
 717              		.cfi_restore_state
 889:quantum/action.c ****     }
 718              		.loc 1 889 9 view .LVU186
 719              	.LBE45:
 720              	.LBE49:
 721              		.loc 1 892 1 view .LVU187
 722 00b8 08BD     		pop	{r3, pc}
 723              		.cfi_endproc
 724              	.LFE301:
 726              		.section	.text.tap_code_delay,"ax",%progbits
 727              		.align	1
 728              		.global	tap_code_delay
 729              		.syntax unified
 730              		.thumb
 731              		.thumb_func
 733              	tap_code_delay:
 734              	.LVL73:
 735              	.LFB302:
 893:quantum/action.c **** 
 894:quantum/action.c **** /** \brief Tap a keycode with a delay.
 895:quantum/action.c ****  *
 896:quantum/action.c ****  * \param code The basic keycode to tap.
 897:quantum/action.c ****  * \param delay The amount of time in milliseconds to leave the keycode registered, before unregist
 898:quantum/action.c ****  */
 899:quantum/action.c **** void tap_code_delay(uint8_t code, uint16_t delay) {
 736              		.loc 1 899 51 is_stmt 1 view -0
 737              		.cfi_startproc
 738              		@ args = 0, pretend = 0, frame = 0
 739              		@ frame_needed = 0, uses_anonymous_args = 0
 900:quantum/action.c ****     register_code(code);
 740              		.loc 1 900 5 view .LVU189
 899:quantum/action.c ****     register_code(code);
 741              		.loc 1 899 51 is_stmt 0 view .LVU190
 742 0000 38B5     		push	{r3, r4, r5, lr}
 743              		.cfi_def_cfa_offset 16
 744              		.cfi_offset 3, -16
 745              		.cfi_offset 4, -12
 746              		.cfi_offset 5, -8
 747              		.cfi_offset 14, -4
 899:quantum/action.c ****     register_code(code);
 748              		.loc 1 899 51 view .LVU191
 749 0002 0546     		mov	r5, r0
 750 0004 0C46     		mov	r4, r1
 751              		.loc 1 900 5 view .LVU192
 752 0006 FFF7FEFF 		bl	register_code
 753              	.LVL74:
 901:quantum/action.c ****     for (uint16_t i = delay; i > 0; i--) {
 754              		.loc 1 901 5 is_stmt 1 view .LVU193
 755              	.LBB50:
 756              		.loc 1 901 10 view .LVU194
 757              	.L58:
 758              		.loc 1 901 32 discriminator 2 view .LVU195
 759 000a 24B9     		cbnz	r4, .L59
 760              		.loc 1 901 32 is_stmt 0 discriminator 2 view .LVU196
 761              	.LBE50:
 902:quantum/action.c ****         wait_ms(1);
 903:quantum/action.c ****     }
 904:quantum/action.c ****     unregister_code(code);
 762              		.loc 1 904 5 is_stmt 1 view .LVU197
 763 000c 2846     		mov	r0, r5
 905:quantum/action.c **** }
 764              		.loc 1 905 1 is_stmt 0 view .LVU198
 765 000e BDE83840 		pop	{r3, r4, r5, lr}
 766              		.cfi_remember_state
 767              		.cfi_restore 14
 768              		.cfi_restore 5
 769              		.cfi_restore 4
 770              		.cfi_restore 3
 771              		.cfi_def_cfa_offset 0
 772              	.LVL75:
 904:quantum/action.c **** }
 773              		.loc 1 904 5 view .LVU199
 774 0012 FFF7FEBF 		b	unregister_code
 775              	.LVL76:
 776              	.L59:
 777              		.cfi_restore_state
 778              	.LBB51:
 902:quantum/action.c ****         wait_ms(1);
 779              		.loc 1 902 9 is_stmt 1 discriminator 1 view .LVU200
 902:quantum/action.c ****         wait_ms(1);
 780              		.loc 1 902 9 discriminator 1 view .LVU201
 902:quantum/action.c ****         wait_ms(1);
 781              		.loc 1 902 9 discriminator 1 view .LVU202
 782 0016 0A20     		movs	r0, #10
 901:quantum/action.c ****         wait_ms(1);
 783              		.loc 1 901 38 is_stmt 0 discriminator 1 view .LVU203
 784 0018 013C     		subs	r4, r4, #1
 785              	.LVL77:
 902:quantum/action.c ****     }
 786              		.loc 1 902 9 discriminator 1 view .LVU204
 787 001a FFF7FEFF 		bl	chThdSleep
 788              	.LVL78:
 902:quantum/action.c ****     }
 789              		.loc 1 902 9 is_stmt 1 discriminator 1 view .LVU205
 901:quantum/action.c ****         wait_ms(1);
 790              		.loc 1 901 38 discriminator 1 view .LVU206
 791 001e A4B2     		uxth	r4, r4
 792              	.LVL79:
 901:quantum/action.c ****         wait_ms(1);
 793              		.loc 1 901 38 is_stmt 0 discriminator 1 view .LVU207
 794 0020 F3E7     		b	.L58
 795              	.LBE51:
 796              		.cfi_endproc
 797              	.LFE302:
 799              		.section	.text.tap_code,"ax",%progbits
 800              		.align	1
 801              		.global	tap_code
 802              		.syntax unified
 803              		.thumb
 804              		.thumb_func
 806              	tap_code:
 807              	.LVL80:
 808              	.LFB303:
 906:quantum/action.c **** 
 907:quantum/action.c **** /** \brief Tap a keycode with the default delay.
 908:quantum/action.c ****  *
 909:quantum/action.c ****  * \param code The basic keycode to tap. If `code` is `KC_CAPS`, the delay will be `TAP_HOLD_CAPS_D
 910:quantum/action.c ****  */
 911:quantum/action.c **** void tap_code(uint8_t code) { tap_code_delay(code, code == KC_CAPS ? TAP_HOLD_CAPS_DELAY : TAP_CODE
 809              		.loc 1 911 29 is_stmt 1 view -0
 810              		.cfi_startproc
 811              		@ args = 0, pretend = 0, frame = 0
 812              		@ frame_needed = 0, uses_anonymous_args = 0
 813              		@ link register save eliminated.
 814              		.loc 1 911 31 view .LVU209
 815 0000 3928     		cmp	r0, #57
 816 0002 0CBF     		ite	eq
 817 0004 5021     		moveq	r1, #80
 818 0006 0021     		movne	r1, #0
 819 0008 FFF7FEBF 		b	tap_code_delay
 820              	.LVL81:
 821              		.loc 1 911 31 is_stmt 0 view .LVU210
 822              		.cfi_endproc
 823              	.LFE303:
 825              		.section	.text.register_mods,"ax",%progbits
 826              		.align	1
 827              		.global	register_mods
 828              		.syntax unified
 829              		.thumb
 830              		.thumb_func
 832              	register_mods:
 833              	.LVL82:
 834              	.LFB304:
 912:quantum/action.c **** 
 913:quantum/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 914:quantum/action.c ****  *
 915:quantum/action.c ****  * \param mods A bitfield of modifiers to register.
 916:quantum/action.c ****  */
 917:quantum/action.c **** void register_mods(uint8_t mods) {
 835              		.loc 1 917 34 is_stmt 1 view -0
 836              		.cfi_startproc
 837              		@ args = 0, pretend = 0, frame = 0
 838              		@ frame_needed = 0, uses_anonymous_args = 0
 918:quantum/action.c ****     if (mods) {
 839              		.loc 1 918 5 view .LVU212
 917:quantum/action.c ****     if (mods) {
 840              		.loc 1 917 34 is_stmt 0 view .LVU213
 841 0000 08B5     		push	{r3, lr}
 842              		.cfi_def_cfa_offset 8
 843              		.cfi_offset 3, -8
 844              		.cfi_offset 14, -4
 845              		.loc 1 918 8 view .LVU214
 846 0002 28B1     		cbz	r0, .L63
 847              	.LBB54:
 848              	.LBI54:
 917:quantum/action.c ****     if (mods) {
 849              		.loc 1 917 6 is_stmt 1 view .LVU215
 850              	.LBB55:
 919:quantum/action.c ****         add_mods(mods);
 851              		.loc 1 919 9 view .LVU216
 852 0004 FFF7FEFF 		bl	add_mods
 853              	.LVL83:
 920:quantum/action.c ****         send_keyboard_report();
 854              		.loc 1 920 9 view .LVU217
 855              	.LBE55:
 856              	.LBE54:
 921:quantum/action.c ****     }
 922:quantum/action.c **** }
 857              		.loc 1 922 1 is_stmt 0 view .LVU218
 858 0008 BDE80840 		pop	{r3, lr}
 859              		.cfi_remember_state
 860              		.cfi_restore 14
 861              		.cfi_restore 3
 862              		.cfi_def_cfa_offset 0
 863              	.LBB57:
 864              	.LBB56:
 920:quantum/action.c ****         send_keyboard_report();
 865              		.loc 1 920 9 view .LVU219
 866 000c FFF7FEBF 		b	send_keyboard_report
 867              	.LVL84:
 868              	.L63:
 869              		.cfi_restore_state
 920:quantum/action.c ****         send_keyboard_report();
 870              		.loc 1 920 9 view .LVU220
 871              	.LBE56:
 872              	.LBE57:
 873              		.loc 1 922 1 view .LVU221
 874 0010 08BD     		pop	{r3, pc}
 875              		.cfi_endproc
 876              	.LFE304:
 878              		.section	.text.unregister_mods,"ax",%progbits
 879              		.align	1
 880              		.global	unregister_mods
 881              		.syntax unified
 882              		.thumb
 883              		.thumb_func
 885              	unregister_mods:
 886              	.LVL85:
 887              	.LFB305:
 923:quantum/action.c **** 
 924:quantum/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 925:quantum/action.c ****  *
 926:quantum/action.c ****  * \param mods A bitfield of modifiers to unregister.
 927:quantum/action.c ****  */
 928:quantum/action.c **** void unregister_mods(uint8_t mods) {
 888              		.loc 1 928 36 is_stmt 1 view -0
 889              		.cfi_startproc
 890              		@ args = 0, pretend = 0, frame = 0
 891              		@ frame_needed = 0, uses_anonymous_args = 0
 929:quantum/action.c ****     if (mods) {
 892              		.loc 1 929 5 view .LVU223
 928:quantum/action.c ****     if (mods) {
 893              		.loc 1 928 36 is_stmt 0 view .LVU224
 894 0000 08B5     		push	{r3, lr}
 895              		.cfi_def_cfa_offset 8
 896              		.cfi_offset 3, -8
 897              		.cfi_offset 14, -4
 898              		.loc 1 929 8 view .LVU225
 899 0002 28B1     		cbz	r0, .L65
 900              	.LBB60:
 901              	.LBI60:
 928:quantum/action.c ****     if (mods) {
 902              		.loc 1 928 6 is_stmt 1 view .LVU226
 903              	.LBB61:
 930:quantum/action.c ****         del_mods(mods);
 904              		.loc 1 930 9 view .LVU227
 905 0004 FFF7FEFF 		bl	del_mods
 906              	.LVL86:
 931:quantum/action.c ****         send_keyboard_report();
 907              		.loc 1 931 9 view .LVU228
 908              	.LBE61:
 909              	.LBE60:
 932:quantum/action.c ****     }
 933:quantum/action.c **** }
 910              		.loc 1 933 1 is_stmt 0 view .LVU229
 911 0008 BDE80840 		pop	{r3, lr}
 912              		.cfi_remember_state
 913              		.cfi_restore 14
 914              		.cfi_restore 3
 915              		.cfi_def_cfa_offset 0
 916              	.LBB63:
 917              	.LBB62:
 931:quantum/action.c ****         send_keyboard_report();
 918              		.loc 1 931 9 view .LVU230
 919 000c FFF7FEBF 		b	send_keyboard_report
 920              	.LVL87:
 921              	.L65:
 922              		.cfi_restore_state
 931:quantum/action.c ****         send_keyboard_report();
 923              		.loc 1 931 9 view .LVU231
 924              	.LBE62:
 925              	.LBE63:
 926              		.loc 1 933 1 view .LVU232
 927 0010 08BD     		pop	{r3, pc}
 928              		.cfi_endproc
 929              	.LFE305:
 931              		.section	.text.process_action,"ax",%progbits
 932              		.align	1
 933              		.global	process_action
 934              		.syntax unified
 935              		.thumb
 936              		.thumb_func
 938              	process_action:
 939              	.LVL88:
 940              	.LFB299:
 249:quantum/action.c ****     keyevent_t event = record->event;
 941              		.loc 1 249 59 is_stmt 1 view -0
 942              		.cfi_startproc
 943              		@ args = 0, pretend = 0, frame = 0
 944              		@ frame_needed = 0, uses_anonymous_args = 0
 250:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 945              		.loc 1 250 5 view .LVU234
 249:quantum/action.c ****     keyevent_t event = record->event;
 946              		.loc 1 249 59 is_stmt 0 view .LVU235
 947 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 948              		.cfi_def_cfa_offset 32
 949              		.cfi_offset 3, -32
 950              		.cfi_offset 4, -28
 951              		.cfi_offset 5, -24
 952              		.cfi_offset 6, -20
 953              		.cfi_offset 7, -16
 954              		.cfi_offset 8, -12
 955              		.cfi_offset 9, -8
 956              		.cfi_offset 14, -4
 252:quantum/action.c **** #endif
 957              		.loc 1 252 36 view .LVU236
 958 0004 8679     		ldrb	r6, [r0, #6]	@ zero_extendqisi2
 250:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 959              		.loc 1 250 16 view .LVU237
 960 0006 8578     		ldrb	r5, [r0, #2]	@ zero_extendqisi2
 961              	.LVL89:
 252:quantum/action.c **** #endif
 962              		.loc 1 252 5 is_stmt 1 view .LVU238
 249:quantum/action.c ****     keyevent_t event = record->event;
 963              		.loc 1 249 59 is_stmt 0 view .LVU239
 964 0008 8046     		mov	r8, r0
 965 000a 0C46     		mov	r4, r1	@ movhi
 966              	.LVL90:
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 967              		.loc 1 258 9 view .LVU240
 968 000c FFF7FEFF 		bl	is_oneshot_layer_active
 969              	.LVL91:
 252:quantum/action.c **** #endif
 970              		.loc 1 252 13 view .LVU241
 971 0010 3609     		lsrs	r6, r6, #4
 972              	.LVL92:
 256:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 973              		.loc 1 256 5 is_stmt 1 view .LVU242
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 974              		.loc 1 258 5 view .LVU243
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 975              		.loc 1 258 8 is_stmt 0 view .LVU244
 976 0012 0746     		mov	r7, r0
 977 0014 A0B1     		cbz	r0, .L68
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 978              		.loc 1 258 43 discriminator 1 view .LVU245
 979 0016 2F46     		mov	r7, r5
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 980              		.loc 1 258 35 discriminator 1 view .LVU246
 981 0018 95B1     		cbz	r5, .L68
 982              	.LVL93:
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 983              		.loc 1 258 71 discriminator 2 view .LVU247
 984 001a C4F30723 		ubfx	r3, r4, #8, #8
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 985              		.loc 1 258 52 discriminator 2 view .LVU248
 986 001e 03F0F003 		and	r3, r3, #240
 987 0022 402B     		cmp	r3, #64
 988 0024 04D0     		beq	.L69
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 989              		.loc 1 258 87 discriminator 3 view .LVU249
 990 0026 04F12003 		add	r3, r4, #32
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 991              		.loc 1 258 84 discriminator 3 view .LVU250
 992 002a DBB2     		uxtb	r3, r3
 993 002c 072B     		cmp	r3, #7
 994 002e 1DD9     		bls	.L148
 995              	.L69:
 263:quantum/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 996              		.loc 1 263 9 is_stmt 1 view .LVU251
 997 0030 0220     		movs	r0, #2
 998 0032 FFF7FEFF 		bl	clear_oneshot_layer_state
 999              	.LVL94:
 264:quantum/action.c ****     }
 1000              		.loc 1 264 9 view .LVU252
 264:quantum/action.c ****     }
 1001              		.loc 1 264 31 is_stmt 0 view .LVU253
 1002 0036 FFF7FEFF 		bl	is_oneshot_layer_active
 1003              	.LVL95:
 264:quantum/action.c ****     }
 1004              		.loc 1 264 9 view .LVU254
 1005 003a 80F00107 		eor	r7, r0, #1
 1006 003e FFB2     		uxtb	r7, r7
 1007              	.LVL96:
 1008              	.L68:
 268:quantum/action.c ****         /* Key and Mods */
 1009              		.loc 1 268 5 is_stmt 1 view .LVU255
 1010 0040 C4F30333 		ubfx	r3, r4, #12, #4
 1011 0044 0F2B     		cmp	r3, #15
 1012 0046 3ED8     		bhi	.L70
 1013 0048 DFE813F0 		tbh	[pc, r3, lsl #1]
 1014              	.L72:
 1015 004c 1200     		.2byte	(.L80-.L72)/2
 1016 004e 1200     		.2byte	(.L80-.L72)/2
 1017 0050 5800     		.2byte	(.L79-.L72)/2
 1018 0052 5800     		.2byte	(.L79-.L72)/2
 1019 0054 A400     		.2byte	(.L78-.L72)/2
 1020 0056 BB00     		.2byte	(.L77-.L72)/2
 1021 0058 3D00     		.2byte	(.L70-.L72)/2
 1022 005a 3D00     		.2byte	(.L70-.L72)/2
 1023 005c C500     		.2byte	(.L76-.L72)/2
 1024 005e 2101     		.2byte	(.L75-.L72)/2
 1025 0060 3301     		.2byte	(.L74-.L72)/2
 1026 0062 3301     		.2byte	(.L74-.L72)/2
 1027 0064 8B01     		.2byte	(.L73-.L72)/2
 1028 0066 3D00     		.2byte	(.L70-.L72)/2
 1029 0068 3D00     		.2byte	(.L70-.L72)/2
 1030 006a 9401     		.2byte	(.L71-.L72)/2
 1031              	.LVL97:
 1032              		.p2align 1
 1033              	.L148:
 256:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 1034              		.loc 1 256 10 is_stmt 0 view .LVU256
 1035 006c 0027     		movs	r7, #0
 1036 006e E7E7     		b	.L68
 1037              	.LVL98:
 1038              	.L80:
 1039              	.LBB64:
 272:quantum/action.c ****             if (event.pressed) {
 1040              		.loc 1 272 13 is_stmt 1 view .LVU257
 272:quantum/action.c ****             if (event.pressed) {
 1041              		.loc 1 272 21 is_stmt 0 view .LVU258
 1042 0070 C4F30723 		ubfx	r3, r4, #8, #8
 1043 0074 C4F30326 		ubfx	r6, r4, #8, #4
 1044 0078 0F2B     		cmp	r3, #15
 1045 007a 88BF     		it	hi
 1046 007c 3601     		lslhi	r6, r6, #4
 1047              	.LVL99:
 273:quantum/action.c ****                 if (mods) {
 1048              		.loc 1 273 13 is_stmt 1 view .LVU259
 1049              	.LBE64:
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1050              		.loc 1 258 88 is_stmt 0 view .LVU260
 1051 007e E4B2     		uxtb	r4, r4
 1052              	.LVL100:
 1053              	.LBB65:
 273:quantum/action.c ****                 if (mods) {
 1054              		.loc 1 273 16 view .LVU261
 1055 0080 95B1     		cbz	r5, .L82
 274:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1056              		.loc 1 274 17 is_stmt 1 view .LVU262
 274:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1057              		.loc 1 274 20 is_stmt 0 view .LVU263
 1058 0082 56B1     		cbz	r6, .L103
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1059              		.loc 1 275 21 is_stmt 1 view .LVU264
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1060              		.loc 1 275 25 is_stmt 0 view .LVU265
 1061 0084 04F12003 		add	r3, r4, #32
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1062              		.loc 1 275 24 view .LVU266
 1063 0088 DBB2     		uxtb	r3, r3
 1064 008a 072B     		cmp	r3, #7
 279:quantum/action.c ****                     } else {
 1065              		.loc 1 279 25 view .LVU267
 1066 008c 3046     		mov	r0, r6
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1067              		.loc 1 275 24 view .LVU268
 1068 008e 00D9     		bls	.L84
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1069              		.loc 1 275 49 discriminator 1 view .LVU269
 1070 0090 3CB9     		cbnz	r4, .L85
 1071              	.L84:
 279:quantum/action.c ****                     } else {
 1072              		.loc 1 279 25 is_stmt 1 view .LVU270
 1073 0092 FFF7FEFF 		bl	add_mods
 1074              	.LVL101:
 1075              	.L86:
 283:quantum/action.c ****                 }
 1076              		.loc 1 283 21 view .LVU271
 1077 0096 FFF7FEFF 		bl	send_keyboard_report
 1078              	.LVL102:
 285:quantum/action.c ****             } else {
 1079              		.loc 1 285 17 view .LVU272
 1080              	.L103:
 285:quantum/action.c ****             } else {
 1081              		.loc 1 285 17 is_stmt 0 view .LVU273
 1082              	.LBE65:
 1083              	.LBB66:
 372:quantum/action.c ****                                 register_code(action.key.code);
 1084              		.loc 1 372 73 is_stmt 1 view .LVU274
 373:quantum/action.c ****                             }
 1085              		.loc 1 373 33 view .LVU275
 1086 009a 2046     		mov	r0, r4
 1087 009c FFF7FEFF 		bl	register_code
 1088              	.LVL103:
 1089              	.LBE66:
 679:quantum/action.c ****         case ACT_LAYER:
 1090              		.loc 1 679 5 view .LVU276
 1091 00a0 11E0     		b	.L70
 1092              	.LVL104:
 1093              	.L85:
 1094              	.LBB67:
 281:quantum/action.c ****                     }
 1095              		.loc 1 281 25 view .LVU277
 1096 00a2 FFF7FEFF 		bl	add_weak_mods
 1097              	.LVL105:
 1098 00a6 F6E7     		b	.L86
 1099              	.L82:
 287:quantum/action.c ****                 if (mods) {
 1100              		.loc 1 287 17 view .LVU278
 1101 00a8 2046     		mov	r0, r4
 1102 00aa FFF7FEFF 		bl	unregister_code
 1103              	.LVL106:
 288:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1104              		.loc 1 288 17 view .LVU279
 288:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1105              		.loc 1 288 20 is_stmt 0 view .LVU280
 1106 00ae 56B1     		cbz	r6, .L70
 289:quantum/action.c ****                         del_mods(mods);
 1107              		.loc 1 289 21 is_stmt 1 view .LVU281
 289:quantum/action.c ****                         del_mods(mods);
 1108              		.loc 1 289 25 is_stmt 0 view .LVU282
 1109 00b0 04F12003 		add	r3, r4, #32
 289:quantum/action.c ****                         del_mods(mods);
 1110              		.loc 1 289 24 view .LVU283
 1111 00b4 DBB2     		uxtb	r3, r3
 1112 00b6 072B     		cmp	r3, #7
 290:quantum/action.c ****                     } else {
 1113              		.loc 1 290 25 view .LVU284
 1114 00b8 3046     		mov	r0, r6
 289:quantum/action.c ****                         del_mods(mods);
 1115              		.loc 1 289 24 view .LVU285
 1116 00ba 00D9     		bls	.L88
 289:quantum/action.c ****                         del_mods(mods);
 1117              		.loc 1 289 49 discriminator 1 view .LVU286
 1118 00bc DCB9     		cbnz	r4, .L89
 1119              	.L88:
 290:quantum/action.c ****                     } else {
 1120              		.loc 1 290 25 is_stmt 1 view .LVU287
 1121 00be FFF7FEFF 		bl	del_mods
 1122              	.LVL107:
 1123              	.L90:
 294:quantum/action.c ****                 }
 1124              		.loc 1 294 21 view .LVU288
 1125 00c2 FFF7FEFF 		bl	send_keyboard_report
 1126              	.LVL108:
 1127              	.LBE67:
 679:quantum/action.c ****         case ACT_LAYER:
 1128              		.loc 1 679 5 view .LVU289
 1129              	.L70:
 732:quantum/action.c ****         record->event.pressed = false;
 1130              		.loc 1 732 5 view .LVU290
 732:quantum/action.c ****         record->event.pressed = false;
 1131              		.loc 1 732 8 is_stmt 0 view .LVU291
 1132 00c6 002F     		cmp	r7, #0
 1133 00c8 00F05B81 		beq	.L67
 732:quantum/action.c ****         record->event.pressed = false;
 1134              		.loc 1 732 33 discriminator 1 view .LVU292
 1135 00cc FFF7FEFF 		bl	get_oneshot_layer_state
 1136              	.LVL109:
 732:quantum/action.c ****         record->event.pressed = false;
 1137              		.loc 1 732 28 discriminator 1 view .LVU293
 1138 00d0 10F00100 		ands	r0, r0, #1
 1139 00d4 40F05581 		bne	.L67
 733:quantum/action.c ****         layer_on(get_oneshot_layer());
 1140              		.loc 1 733 9 is_stmt 1 view .LVU294
 733:quantum/action.c ****         layer_on(get_oneshot_layer());
 1141              		.loc 1 733 31 is_stmt 0 view .LVU295
 1142 00d8 88F80200 		strb	r0, [r8, #2]
 734:quantum/action.c ****         process_record(record);
 1143              		.loc 1 734 9 is_stmt 1 view .LVU296
 1144 00dc FFF7FEFF 		bl	get_oneshot_layer
 1145              	.LVL110:
 1146 00e0 FFF7FEFF 		bl	layer_on
 1147              	.LVL111:
 735:quantum/action.c ****         layer_off(get_oneshot_layer());
 1148              		.loc 1 735 9 view .LVU297
 1149 00e4 4046     		mov	r0, r8
 1150 00e6 FFF7FEFF 		bl	process_record
 1151              	.LVL112:
 736:quantum/action.c ****     }
 1152              		.loc 1 736 9 view .LVU298
 1153 00ea FFF7FEFF 		bl	get_oneshot_layer
 1154              	.LVL113:
 739:quantum/action.c **** 
 1155              		.loc 1 739 1 is_stmt 0 view .LVU299
 1156 00ee BDE8F843 		pop	{r3, r4, r5, r6, r7, r8, r9, lr}
 1157              		.cfi_remember_state
 1158              		.cfi_restore 14
 1159              		.cfi_restore 9
 1160              		.cfi_restore 8
 1161              		.cfi_restore 7
 1162              		.cfi_restore 6
 1163              		.cfi_restore 5
 1164              		.cfi_restore 4
 1165              		.cfi_restore 3
 1166              		.cfi_def_cfa_offset 0
 1167              	.LVL114:
 736:quantum/action.c ****     }
 1168              		.loc 1 736 9 view .LVU300
 1169 00f2 FFF7FEBF 		b	layer_off
 1170              	.LVL115:
 1171              	.L89:
 1172              		.cfi_restore_state
 1173              	.LBB68:
 292:quantum/action.c ****                     }
 1174              		.loc 1 292 25 is_stmt 1 view .LVU301
 1175 00f6 FFF7FEFF 		bl	del_weak_mods
 1176              	.LVL116:
 1177 00fa E2E7     		b	.L90
 1178              	.LVL117:
 1179              	.L79:
 292:quantum/action.c ****                     }
 1180              		.loc 1 292 25 is_stmt 0 view .LVU302
 1181              	.LBE68:
 1182              	.LBB69:
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1183              		.loc 1 301 13 is_stmt 1 view .LVU303
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1184              		.loc 1 301 44 is_stmt 0 view .LVU304
 1185 00fc C4F30723 		ubfx	r3, r4, #8, #8
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1186              		.loc 1 301 21 view .LVU305
 1187 0100 03F0F003 		and	r3, r3, #240
 1188 0104 C4F30329 		ubfx	r9, r4, #8, #4
 1189 0108 202B     		cmp	r3, #32
 302:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 1190              		.loc 1 302 37 view .LVU306
 1191 010a E4B2     		uxtb	r4, r4
 1192              	.LVL118:
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1193              		.loc 1 301 21 view .LVU307
 1194 010c 18BF     		it	ne
 1195 010e 4FEA0919 		lslne	r9, r9, #4
 1196              	.LVL119:
 302:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 1197              		.loc 1 302 13 is_stmt 1 view .LVU308
 1198 0112 64B1     		cbz	r4, .L92
 1199 0114 012C     		cmp	r4, #1
 1200 0116 28D0     		beq	.L93
 357:quantum/action.c ****                         if (tap_count > 0) {
 1201              		.loc 1 357 21 view .LVU309
 357:quantum/action.c ****                         if (tap_count > 0) {
 1202              		.loc 1 357 24 is_stmt 0 view .LVU310
 1203 0118 7DB3     		cbz	r5, .L101
 358:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1204              		.loc 1 358 25 is_stmt 1 view .LVU311
 358:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1205              		.loc 1 358 28 is_stmt 0 view .LVU312
 1206 011a 4EB3     		cbz	r6, .L102
 360:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1207              		.loc 1 360 29 is_stmt 1 view .LVU313
 364:quantum/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1208              		.loc 1 364 33 is_stmt 0 view .LVU314
 1209 011c 98F80630 		ldrb	r3, [r8, #6]	@ zero_extendqisi2
 360:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1210              		.loc 1 360 32 view .LVU315
 1211 0120 D807     		lsls	r0, r3, #31
 1212 0122 BAD5     		bpl	.L103
 365:quantum/action.c ****                                 // ad hoc: set 0 to cancel tap
 1213              		.loc 1 365 76 is_stmt 1 view .LVU316
 367:quantum/action.c ****                                 register_mods(mods);
 1214              		.loc 1 367 33 view .LVU317
 367:quantum/action.c ****                                 register_mods(mods);
 1215              		.loc 1 367 51 is_stmt 0 view .LVU318
 1216 0124 6FF30713 		bfc	r3, #4, #4
 1217 0128 88F80630 		strb	r3, [r8, #6]
 368:quantum/action.c ****                             } else
 1218              		.loc 1 368 33 is_stmt 1 view .LVU319
 1219 012c 20E0     		b	.L102
 1220              	.L92:
 306:quantum/action.c ****                         if (tap_count == 0) {
 1221              		.loc 1 306 21 view .LVU320
 306:quantum/action.c ****                         if (tap_count == 0) {
 1222              		.loc 1 306 24 is_stmt 0 view .LVU321
 1223 012e 95B1     		cbz	r5, .L95
 307:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1224              		.loc 1 307 25 is_stmt 1 view .LVU322
 307:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1225              		.loc 1 307 28 is_stmt 0 view .LVU323
 1226 0130 3EB9     		cbnz	r6, .L96
 1227              	.L97:
 321:quantum/action.c ****                         }
 1228              		.loc 1 321 29 is_stmt 1 view .LVU324
 321:quantum/action.c ****                         }
 1229              		.loc 1 321 50 is_stmt 0 view .LVU325
 1230 0132 FFF7FEFF 		bl	get_oneshot_mods
 1231              	.LVL120:
 321:quantum/action.c ****                         }
 1232              		.loc 1 321 29 view .LVU326
 1233 0136 40EA0900 		orr	r0, r0, r9
 1234 013a C0B2     		uxtb	r0, r0
 1235              	.L179:
 377:quantum/action.c ****                         }
 1236              		.loc 1 377 29 view .LVU327
 1237 013c FFF7FEFF 		bl	register_mods
 1238              	.LVL121:
 1239              	.LBE69:
 679:quantum/action.c ****         case ACT_LAYER:
 1240              		.loc 1 679 5 is_stmt 1 view .LVU328
 1241 0140 C1E7     		b	.L70
 1242              	.L96:
 1243              	.LBB70:
 310:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1244              		.loc 1 310 32 view .LVU329
 310:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1245              		.loc 1 310 35 is_stmt 0 view .LVU330
 1246 0142 012E     		cmp	r6, #1
 1247 0144 F5D1     		bne	.L97
 311:quantum/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1248              		.loc 1 311 65 is_stmt 1 view .LVU331
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1249              		.loc 1 312 29 view .LVU332
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1250              		.loc 1 312 53 is_stmt 0 view .LVU333
 1251 0146 FFF7FEFF 		bl	get_oneshot_mods
 1252              	.LVL122:
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1253              		.loc 1 312 29 view .LVU334
 1254 014a 40EA0900 		orr	r0, r0, r9
 1255 014e C0B2     		uxtb	r0, r0
 1256 0150 FFF7FEFF 		bl	set_oneshot_mods
 1257              	.LVL123:
 1258              	.LBE70:
 679:quantum/action.c ****         case ACT_LAYER:
 1259              		.loc 1 679 5 is_stmt 1 view .LVU335
 1260 0154 B7E7     		b	.L70
 1261              	.L95:
 1262              	.LBB71:
 324:quantum/action.c ****                             clear_oneshot_mods();
 1263              		.loc 1 324 25 view .LVU336
 324:quantum/action.c ****                             clear_oneshot_mods();
 1264              		.loc 1 324 28 is_stmt 0 view .LVU337
 1265 0156 2EB9     		cbnz	r6, .L98
 1266              	.L180:
 339:quantum/action.c ****                             unregister_mods(mods);
 1267              		.loc 1 339 29 is_stmt 1 view .LVU338
 1268 0158 FFF7FEFF 		bl	clear_oneshot_mods
 1269              	.LVL124:
 340:quantum/action.c ****                         }
 1270              		.loc 1 340 29 view .LVU339
 1271              	.L104:
 389:quantum/action.c ****                             unregister_mods(mods);
 1272              		.loc 1 389 67 view .LVU340
 390:quantum/action.c ****                         }
 1273              		.loc 1 390 29 view .LVU341
 1274 015c 4846     		mov	r0, r9
 1275 015e FFF7FEFF 		bl	unregister_mods
 1276              	.LVL125:
 1277              	.LBE71:
 679:quantum/action.c ****         case ACT_LAYER:
 1278              		.loc 1 679 5 view .LVU342
 1279 0162 B0E7     		b	.L70
 1280              	.L98:
 1281              	.LBB72:
 327:quantum/action.c ****                             // Retain Oneshot mods
 1282              		.loc 1 327 32 view .LVU343
 327:quantum/action.c ****                             // Retain Oneshot mods
 1283              		.loc 1 327 35 is_stmt 0 view .LVU344
 1284 0164 012E     		cmp	r6, #1
 1285 0166 AED0     		beq	.L70
 1286 0168 F6E7     		b	.L180
 1287              	.L93:
 346:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1288              		.loc 1 346 21 is_stmt 1 view .LVU345
 346:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1289              		.loc 1 346 24 is_stmt 0 view .LVU346
 1290 016a 1DB1     		cbz	r5, .L100
 347:quantum/action.c ****                             register_mods(mods);
 1291              		.loc 1 347 25 is_stmt 1 view .LVU347
 347:quantum/action.c ****                             register_mods(mods);
 1292              		.loc 1 347 28 is_stmt 0 view .LVU348
 1293 016c 052E     		cmp	r6, #5
 1294 016e AAD8     		bhi	.L70
 1295              	.L102:
 376:quantum/action.c ****                             register_mods(mods);
 1296              		.loc 1 376 67 is_stmt 1 view .LVU349
 377:quantum/action.c ****                         }
 1297              		.loc 1 377 29 view .LVU350
 1298 0170 4846     		mov	r0, r9
 1299 0172 E3E7     		b	.L179
 1300              	.L100:
 351:quantum/action.c ****                             unregister_mods(mods);
 1301              		.loc 1 351 25 view .LVU351
 351:quantum/action.c ****                             unregister_mods(mods);
 1302              		.loc 1 351 28 is_stmt 0 view .LVU352
 1303 0174 042E     		cmp	r6, #4
 1304 0176 A6D8     		bhi	.L70
 1305 0178 F0E7     		b	.L104
 1306              	.L101:
 380:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1307              		.loc 1 380 25 is_stmt 1 view .LVU353
 380:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1308              		.loc 1 380 28 is_stmt 0 view .LVU354
 1309 017a 002E     		cmp	r6, #0
 1310 017c EED0     		beq	.L104
 381:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1311              		.loc 1 381 71 is_stmt 1 view .LVU355
 382:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1312              		.loc 1 382 29 view .LVU356
 382:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1313              		.loc 1 382 32 is_stmt 0 view .LVU357
 1314 017e 392C     		cmp	r4, #57
 383:quantum/action.c ****                             } else {
 1315              		.loc 1 383 33 is_stmt 1 view .LVU358
 383:quantum/action.c ****                             } else {
 1316              		.loc 1 383 33 view .LVU359
 383:quantum/action.c ****                             } else {
 1317              		.loc 1 383 33 view .LVU360
 1318 0180 0CBF     		ite	eq
 1319 0182 4FF44870 		moveq	r0, #800
 385:quantum/action.c ****                             }
 1320              		.loc 1 385 33 view .LVU361
 385:quantum/action.c ****                             }
 1321              		.loc 1 385 33 view .LVU362
 385:quantum/action.c ****                             }
 1322              		.loc 1 385 33 view .LVU363
 1323 0186 0120     		movne	r0, #1
 1324 0188 FFF7FEFF 		bl	chThdSleep
 1325              	.LVL126:
 385:quantum/action.c ****                             }
 1326              		.loc 1 385 33 view .LVU364
 387:quantum/action.c ****                         } else {
 1327              		.loc 1 387 29 view .LVU365
 1328 018c 2046     		mov	r0, r4
 1329 018e FFF7FEFF 		bl	unregister_code
 1330              	.LVL127:
 1331              	.LBE72:
 679:quantum/action.c ****         case ACT_LAYER:
 1332              		.loc 1 679 5 view .LVU366
 1333 0192 98E7     		b	.L70
 1334              	.LVL128:
 1335              	.L78:
 400:quantum/action.c ****                 case PAGE_SYSTEM:
 1336              		.loc 1 400 13 view .LVU367
 1337 0194 14F4406F 		tst	r4, #3072
 400:quantum/action.c ****                 case PAGE_SYSTEM:
 1338              		.loc 1 400 33 is_stmt 0 view .LVU368
 1339 0198 C4F38123 		ubfx	r3, r4, #10, #2
 1340 019c 07D0     		beq	.L107
 1341 019e 012B     		cmp	r3, #1
 1342 01a0 91D1     		bne	.L70
 409:quantum/action.c ****                         host_consumer_send(action.usage.code);
 1343              		.loc 1 409 21 is_stmt 1 view .LVU369
 409:quantum/action.c ****                         host_consumer_send(action.usage.code);
 1344              		.loc 1 409 24 is_stmt 0 view .LVU370
 1345 01a2 65B1     		cbz	r5, .L110
 410:quantum/action.c ****                     } else {
 1346              		.loc 1 410 25 is_stmt 1 view .LVU371
 1347 01a4 C4F30900 		ubfx	r0, r4, #0, #10
 1348              	.L177:
 412:quantum/action.c ****                     }
 1349              		.loc 1 412 25 is_stmt 0 view .LVU372
 1350 01a8 FFF7FEFF 		bl	host_consumer_send
 1351              	.LVL129:
 679:quantum/action.c ****         case ACT_LAYER:
 1352              		.loc 1 679 5 is_stmt 1 view .LVU373
 1353 01ac 8BE7     		b	.L70
 1354              	.L107:
 402:quantum/action.c ****                         host_system_send(action.usage.code);
 1355              		.loc 1 402 21 view .LVU374
 402:quantum/action.c ****                         host_system_send(action.usage.code);
 1356              		.loc 1 402 24 is_stmt 0 view .LVU375
 1357 01ae 25B1     		cbz	r5, .L109
 403:quantum/action.c ****                     } else {
 1358              		.loc 1 403 25 is_stmt 1 view .LVU376
 1359 01b0 C4F30900 		ubfx	r0, r4, #0, #10
 1360              	.L178:
 405:quantum/action.c ****                     }
 1361              		.loc 1 405 25 is_stmt 0 view .LVU377
 1362 01b4 FFF7FEFF 		bl	host_system_send
 1363              	.LVL130:
 679:quantum/action.c ****         case ACT_LAYER:
 1364              		.loc 1 679 5 is_stmt 1 view .LVU378
 1365 01b8 85E7     		b	.L70
 1366              	.L109:
 405:quantum/action.c ****                     }
 1367              		.loc 1 405 25 view .LVU379
 1368 01ba 2846     		mov	r0, r5
 1369 01bc FAE7     		b	.L178
 1370              	.L110:
 412:quantum/action.c ****                     }
 1371              		.loc 1 412 25 view .LVU380
 1372 01be 2846     		mov	r0, r5
 1373 01c0 F2E7     		b	.L177
 1374              	.L77:
 421:quantum/action.c ****                 mousekey_on(action.key.code);
 1375              		.loc 1 421 13 view .LVU381
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1376              		.loc 1 258 88 is_stmt 0 view .LVU382
 1377 01c2 E0B2     		uxtb	r0, r4
 421:quantum/action.c ****                 mousekey_on(action.key.code);
 1378              		.loc 1 421 16 view .LVU383
 1379 01c4 25B1     		cbz	r5, .L111
 422:quantum/action.c ****             } else {
 1380              		.loc 1 422 17 is_stmt 1 view .LVU384
 1381 01c6 FFF7FEFF 		bl	mousekey_on
 1382              	.LVL131:
 1383              	.L112:
 426:quantum/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 1384              		.loc 1 426 13 view .LVU385
 437:quantum/action.c ****                     break;
 1385              		.loc 1 437 21 view .LVU386
 1386 01ca FFF7FEFF 		bl	mousekey_send
 1387              	.LVL132:
 438:quantum/action.c ****             }
 1388              		.loc 1 438 21 view .LVU387
 679:quantum/action.c ****         case ACT_LAYER:
 1389              		.loc 1 679 5 view .LVU388
 1390 01ce 7AE7     		b	.L70
 1391              	.L111:
 424:quantum/action.c ****             }
 1392              		.loc 1 424 17 view .LVU389
 1393 01d0 FFF7FEFF 		bl	mousekey_off
 1394              	.LVL133:
 1395 01d4 F9E7     		b	.L112
 1396              	.L76:
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1397              		.loc 1 444 13 view .LVU390
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1398              		.loc 1 444 16 is_stmt 0 view .LVU391
 1399 01d6 14F4407F 		tst	r4, #768
 1400 01da 29D1     		bne	.L113
 446:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1401              		.loc 1 446 17 is_stmt 1 view .LVU392
 446:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1402              		.loc 1 446 20 is_stmt 0 view .LVU393
 1403 01dc D5B9     		cbnz	r5, .L119
 1404              	.LBB73:
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1405              		.loc 1 447 21 is_stmt 1 view .LVU394
 1406              	.LVL134:
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1407              		.loc 1 448 21 view .LVU395
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1408              		.loc 1 447 61 is_stmt 0 view .LVU396
 1409 01de C4F34213 		ubfx	r3, r4, #5, #3
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1410              		.loc 1 449 104 view .LVU397
 1411 01e2 E106     		lsls	r1, r4, #27
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1412              		.loc 1 447 35 view .LVU398
 1413 01e4 4FEA8303 		lsl	r3, r3, #2
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1414              		.loc 1 449 94 view .LVU399
 1415 01e8 48BF     		it	mi
 1416 01ea 0F25     		movmi	r5, #15
 1417              	.LVL135:
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1418              		.loc 1 448 84 view .LVU400
 1419 01ec DBB2     		uxtb	r3, r3
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1420              		.loc 1 449 94 view .LVU401
 1421 01ee 48BF     		it	mi
 1422 01f0 9D40     		lslmi	r5, r5, r3
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1423              		.loc 1 448 44 view .LVU402
 1424 01f2 04F00F02 		and	r2, r4, #15
 450:quantum/action.c ****                         case OP_BIT_AND:
 1425              		.loc 1 450 47 view .LVU403
 1426 01f6 C4F38124 		ubfx	r4, r4, #10, #2
 1427              	.LVL136:
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1428              		.loc 1 449 104 view .LVU404
 1429 01fa 48BF     		it	mi
 1430 01fc ED43     		mvnmi	r5, r5
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1431              		.loc 1 448 35 view .LVU405
 1432 01fe 9A40     		lsls	r2, r2, r3
 1433              	.LVL137:
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1434              		.loc 1 449 21 is_stmt 1 view .LVU406
 450:quantum/action.c ****                         case OP_BIT_AND:
 1435              		.loc 1 450 21 view .LVU407
 1436 0200 022C     		cmp	r4, #2
 452:quantum/action.c ****                             break;
 1437              		.loc 1 452 29 is_stmt 0 view .LVU408
 1438 0202 45EA0200 		orr	r0, r5, r2
 1439 0206 0DD0     		beq	.L116
 1440 0208 032C     		cmp	r4, #3
 1441 020a 0ED0     		beq	.L117
 1442 020c 012C     		cmp	r4, #1
 1443 020e 06D0     		beq	.L118
 452:quantum/action.c ****                             break;
 1444              		.loc 1 452 29 is_stmt 1 view .LVU409
 1445 0210 FFF7FEFF 		bl	default_layer_and
 1446              	.LVL138:
 453:quantum/action.c ****                         case OP_BIT_OR:
 1447              		.loc 1 453 29 view .LVU410
 1448              	.LBE73:
 679:quantum/action.c ****         case ACT_LAYER:
 1449              		.loc 1 679 5 view .LVU411
 1450              	.L119:
 686:quantum/action.c ****             break;
 1451              		.loc 1 686 13 view .LVU412
 1452 0214 FFF7FEFF 		bl	host_keyboard_leds
 1453              	.LVL139:
 1454 0218 FFF7FEFF 		bl	led_set
 1455              	.LVL140:
 687:quantum/action.c ****         default:
 1456              		.loc 1 687 13 view .LVU413
 1457 021c 53E7     		b	.L70
 1458              	.LVL141:
 1459              	.L118:
 1460              	.LBB74:
 455:quantum/action.c ****                             break;
 1461              		.loc 1 455 29 view .LVU414
 1462 021e FFF7FEFF 		bl	default_layer_or
 1463              	.LVL142:
 456:quantum/action.c ****                         case OP_BIT_XOR:
 1464              		.loc 1 456 29 view .LVU415
 1465              	.LBE74:
 679:quantum/action.c ****         case ACT_LAYER:
 1466              		.loc 1 679 5 view .LVU416
 1467 0222 F7E7     		b	.L119
 1468              	.LVL143:
 1469              	.L116:
 1470              	.LBB75:
 458:quantum/action.c ****                             break;
 1471              		.loc 1 458 29 view .LVU417
 1472 0224 FFF7FEFF 		bl	default_layer_xor
 1473              	.LVL144:
 459:quantum/action.c ****                         case OP_BIT_SET:
 1474              		.loc 1 459 29 view .LVU418
 1475              	.LBE75:
 679:quantum/action.c ****         case ACT_LAYER:
 1476              		.loc 1 679 5 view .LVU419
 1477 0228 F4E7     		b	.L119
 1478              	.LVL145:
 1479              	.L117:
 1480              	.LBB76:
 461:quantum/action.c ****                             break;
 1481              		.loc 1 461 29 view .LVU420
 1482 022a FFF7FEFF 		bl	default_layer_set
 1483              	.LVL146:
 462:quantum/action.c ****                     }
 1484              		.loc 1 462 29 view .LVU421
 1485              	.LBE76:
 679:quantum/action.c ****         case ACT_LAYER:
 1486              		.loc 1 679 5 view .LVU422
 1487 022e F1E7     		b	.L119
 1488              	.LVL147:
 1489              	.L113:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1490              		.loc 1 467 17 view .LVU423
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1491              		.loc 1 467 56 is_stmt 0 view .LVU424
 1492 0230 C4F30122 		ubfx	r2, r4, #8, #2
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1493              		.loc 1 467 21 view .LVU425
 1494 0234 FDB1     		cbz	r5, .L120
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1495              		.loc 1 467 20 discriminator 1 view .LVU426
 1496 0236 D307     		lsls	r3, r2, #31
 1497 0238 ECD5     		bpl	.L119
 1498              	.L121:
 1499              	.LBB77:
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1500              		.loc 1 468 21 is_stmt 1 view .LVU427
 1501              	.LVL148:
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1502              		.loc 1 469 21 view .LVU428
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1503              		.loc 1 468 61 is_stmt 0 view .LVU429
 1504 023a C4F34213 		ubfx	r3, r4, #5, #3
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1505              		.loc 1 470 104 view .LVU430
 1506 023e 14F01000 		ands	r0, r4, #16
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1507              		.loc 1 468 35 view .LVU431
 1508 0242 4FEA8303 		lsl	r3, r3, #2
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1509              		.loc 1 469 84 view .LVU432
 1510 0246 DBB2     		uxtb	r3, r3
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1511              		.loc 1 470 94 view .LVU433
 1512 0248 1CBF     		itt	ne
 1513 024a 0F20     		movne	r0, #15
 1514 024c 9840     		lslne	r0, r0, r3
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1515              		.loc 1 469 44 view .LVU434
 1516 024e 04F00F02 		and	r2, r4, #15
 471:quantum/action.c ****                         case OP_BIT_AND:
 1517              		.loc 1 471 47 view .LVU435
 1518 0252 C4F38124 		ubfx	r4, r4, #10, #2
 1519              	.LVL149:
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1520              		.loc 1 469 35 view .LVU436
 1521 0256 02FA03F2 		lsl	r2, r2, r3
 1522              	.LVL150:
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1523              		.loc 1 470 21 is_stmt 1 view .LVU437
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1524              		.loc 1 470 104 is_stmt 0 view .LVU438
 1525 025a 14BF     		ite	ne
 1526 025c C343     		mvnne	r3, r0
 1527 025e 0346     		moveq	r3, r0
 1528              	.LVL151:
 471:quantum/action.c ****                         case OP_BIT_AND:
 1529              		.loc 1 471 21 is_stmt 1 view .LVU439
 1530 0260 022C     		cmp	r4, #2
 473:quantum/action.c ****                             break;
 1531              		.loc 1 473 29 is_stmt 0 view .LVU440
 1532 0262 43EA0200 		orr	r0, r3, r2
 1533 0266 0CD0     		beq	.L123
 1534 0268 032C     		cmp	r4, #3
 1535 026a 0DD0     		beq	.L124
 1536 026c 012C     		cmp	r4, #1
 1537 026e 05D0     		beq	.L125
 473:quantum/action.c ****                             break;
 1538              		.loc 1 473 29 is_stmt 1 view .LVU441
 1539 0270 FFF7FEFF 		bl	layer_and
 1540              	.LVL152:
 474:quantum/action.c ****                         case OP_BIT_OR:
 1541              		.loc 1 474 29 view .LVU442
 1542              	.LBE77:
 679:quantum/action.c ****         case ACT_LAYER:
 1543              		.loc 1 679 5 view .LVU443
 1544 0274 CEE7     		b	.L119
 1545              	.LVL153:
 1546              	.L120:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1547              		.loc 1 467 20 is_stmt 0 discriminator 2 view .LVU444
 1548 0276 012A     		cmp	r2, #1
 1549 0278 CCD9     		bls	.L119
 1550 027a DEE7     		b	.L121
 1551              	.LVL154:
 1552              	.L125:
 1553              	.LBB78:
 476:quantum/action.c ****                             break;
 1554              		.loc 1 476 29 is_stmt 1 view .LVU445
 1555 027c FFF7FEFF 		bl	layer_or
 1556              	.LVL155:
 477:quantum/action.c ****                         case OP_BIT_XOR:
 1557              		.loc 1 477 29 view .LVU446
 1558              	.LBE78:
 679:quantum/action.c ****         case ACT_LAYER:
 1559              		.loc 1 679 5 view .LVU447
 1560 0280 C8E7     		b	.L119
 1561              	.LVL156:
 1562              	.L123:
 1563              	.LBB79:
 479:quantum/action.c ****                             break;
 1564              		.loc 1 479 29 view .LVU448
 1565 0282 FFF7FEFF 		bl	layer_xor
 1566              	.LVL157:
 480:quantum/action.c ****                         case OP_BIT_SET:
 1567              		.loc 1 480 29 view .LVU449
 1568              	.LBE79:
 679:quantum/action.c ****         case ACT_LAYER:
 1569              		.loc 1 679 5 view .LVU450
 1570 0286 C5E7     		b	.L119
 1571              	.LVL158:
 1572              	.L124:
 1573              	.LBB80:
 482:quantum/action.c ****                             break;
 1574              		.loc 1 482 29 view .LVU451
 1575 0288 FFF7FEFF 		bl	layer_state_set
 1576              	.LVL159:
 483:quantum/action.c ****                     }
 1577              		.loc 1 483 29 view .LVU452
 1578              	.LBE80:
 679:quantum/action.c ****         case ACT_LAYER:
 1579              		.loc 1 679 5 view .LVU453
 1580 028c C2E7     		b	.L119
 1581              	.LVL160:
 1582              	.L75:
 489:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1583              		.loc 1 489 13 view .LVU454
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1584              		.loc 1 258 88 is_stmt 0 view .LVU455
 1585 028e E6B2     		uxtb	r6, r4
 490:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 1586              		.loc 1 490 17 view .LVU456
 1587 0290 C4F30324 		ubfx	r4, r4, #8, #4
 1588              	.LVL161:
 489:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1589              		.loc 1 489 16 view .LVU457
 1590 0294 35B1     		cbz	r5, .L126
 490:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 1591              		.loc 1 490 17 is_stmt 1 view .LVU458
 1592 0296 2046     		mov	r0, r4
 1593 0298 FFF7FEFF 		bl	layer_on
 1594              	.LVL162:
 491:quantum/action.c ****             } else {
 1595              		.loc 1 491 17 view .LVU459
 1596 029c 3046     		mov	r0, r6
 1597 029e FFF7FEFF 		bl	register_mods
 1598              	.LVL163:
 679:quantum/action.c ****         case ACT_LAYER:
 1599              		.loc 1 679 5 view .LVU460
 1600 02a2 B7E7     		b	.L119
 1601              	.L126:
 493:quantum/action.c ****                 layer_off(action.layer_mods.layer);
 1602              		.loc 1 493 17 view .LVU461
 1603 02a4 3046     		mov	r0, r6
 1604 02a6 FFF7FEFF 		bl	unregister_mods
 1605              	.LVL164:
 494:quantum/action.c ****             }
 1606              		.loc 1 494 17 view .LVU462
 1607 02aa 2046     		mov	r0, r4
 1608              	.LVL165:
 1609              	.L175:
 581:quantum/action.c ****                         }
 1610              		.loc 1 581 29 is_stmt 0 view .LVU463
 1611 02ac FFF7FEFF 		bl	layer_off
 1612              	.LVL166:
 679:quantum/action.c ****         case ACT_LAYER:
 1613              		.loc 1 679 5 is_stmt 1 view .LVU464
 1614 02b0 B0E7     		b	.L119
 1615              	.L74:
 500:quantum/action.c ****                 case OP_TAP_TOGGLE:
 1616              		.loc 1 500 13 view .LVU465
 500:quantum/action.c ****                 case OP_TAP_TOGGLE:
 1617              		.loc 1 500 37 is_stmt 0 view .LVU466
 1618 02b2 5FFA84F9 		uxtb	r9, r4
 1619 02b6 A9F1F003 		sub	r3, r9, #240
 1620 02ba 042B     		cmp	r3, #4
 1621 02bc 38D8     		bhi	.L127
 1622 02be DFE803F0 		tbb	[pc, r3]
 1623              	.L129:
 1624 02c2 03       		.byte	(.L133-.L129)/2
 1625 02c3 0D       		.byte	(.L132-.L129)/2
 1626 02c4 14       		.byte	(.L131-.L129)/2
 1627 02c5 19       		.byte	(.L130-.L129)/2
 1628 02c6 22       		.byte	(.L128-.L129)/2
 1629 02c7 00       		.p2align 1
 1630              	.L133:
 503:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1631              		.loc 1 503 21 is_stmt 1 view .LVU467
 503:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1632              		.loc 1 503 24 is_stmt 0 view .LVU468
 1633 02c8 35B1     		cbz	r5, .L134
 504:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1634              		.loc 1 504 25 is_stmt 1 view .LVU469
 504:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1635              		.loc 1 504 28 is_stmt 0 view .LVU470
 1636 02ca 042E     		cmp	r6, #4
 1637              	.L173:
 1638 02cc A2D8     		bhi	.L119
 505:quantum/action.c ****                         }
 1639              		.loc 1 505 29 is_stmt 1 view .LVU471
 1640 02ce C4F30420 		ubfx	r0, r4, #8, #5
 1641 02d2 FFF7FEFF 		bl	layer_invert
 1642              	.LVL167:
 679:quantum/action.c ****         case ACT_LAYER:
 1643              		.loc 1 679 5 view .LVU472
 1644 02d6 9DE7     		b	.L119
 1645              	.L134:
 508:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1646              		.loc 1 508 25 view .LVU473
 508:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1647              		.loc 1 508 28 is_stmt 0 view .LVU474
 1648 02d8 052E     		cmp	r6, #5
 1649 02da F7E7     		b	.L173
 1650              	.L132:
 514:quantum/action.c ****                     break;
 1651              		.loc 1 514 21 is_stmt 1 view .LVU475
 514:quantum/action.c ****                     break;
 1652              		.loc 1 514 37 is_stmt 0 view .LVU476
 1653 02dc C4F30420 		ubfx	r0, r4, #8, #5
 514:quantum/action.c ****                     break;
 1654              		.loc 1 514 68 view .LVU477
 1655 02e0 002D     		cmp	r5, #0
 1656 02e2 E3D0     		beq	.L175
 1657              	.L176:
 568:quantum/action.c ****                         }
 1658              		.loc 1 568 29 view .LVU478
 1659 02e4 FFF7FEFF 		bl	layer_on
 1660              	.LVL168:
 679:quantum/action.c ****         case ACT_LAYER:
 1661              		.loc 1 679 5 is_stmt 1 view .LVU479
 1662 02e8 94E7     		b	.L119
 1663              	.L131:
 517:quantum/action.c ****                     break;
 1664              		.loc 1 517 21 view .LVU480
 517:quantum/action.c ****                     break;
 1665              		.loc 1 517 37 is_stmt 0 view .LVU481
 1666 02ea C4F30420 		ubfx	r0, r4, #8, #5
 517:quantum/action.c ****                     break;
 1667              		.loc 1 517 69 view .LVU482
 1668 02ee 002D     		cmp	r5, #0
 1669 02f0 F8D0     		beq	.L176
 1670 02f2 DBE7     		b	.L175
 1671              	.L130:
 520:quantum/action.c ****                     break;
 1672              		.loc 1 520 21 is_stmt 1 view .LVU483
 520:quantum/action.c ****                     break;
 1673              		.loc 1 520 70 is_stmt 0 view .LVU484
 1674 02f4 25B1     		cbz	r5, .L138
 520:quantum/action.c ****                     break;
 1675              		.loc 1 520 37 discriminator 1 view .LVU485
 1676 02f6 C4F30420 		ubfx	r0, r4, #8, #5
 1677 02fa FFF7FEFF 		bl	layer_move
 1678              	.LVL169:
 679:quantum/action.c ****         case ACT_LAYER:
 1679              		.loc 1 679 5 is_stmt 1 discriminator 1 view .LVU486
 1680 02fe 89E7     		b	.L119
 1681              	.L138:
 520:quantum/action.c ****                     break;
 1682              		.loc 1 520 72 is_stmt 0 discriminator 2 view .LVU487
 1683 0300 FFF7FEFF 		bl	layer_clear
 1684              	.LVL170:
 679:quantum/action.c ****         case ACT_LAYER:
 1685              		.loc 1 679 5 is_stmt 1 discriminator 2 view .LVU488
 1686 0304 86E7     		b	.L119
 1687              	.L128:
 548:quantum/action.c ****                         layer_on(action.layer_tap.val);
 1688              		.loc 1 548 21 view .LVU489
 548:quantum/action.c ****                         layer_on(action.layer_tap.val);
 1689              		.loc 1 548 24 is_stmt 0 view .LVU490
 1690 0306 4DB1     		cbz	r5, .L139
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1691              		.loc 1 549 25 is_stmt 1 view .LVU491
 1692 0308 C4F30424 		ubfx	r4, r4, #8, #5
 1693              	.LVL171:
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1694              		.loc 1 549 25 is_stmt 0 view .LVU492
 1695 030c 2046     		mov	r0, r4
 1696 030e FFF7FEFF 		bl	layer_on
 1697              	.LVL172:
 550:quantum/action.c ****                     } else {
 1698              		.loc 1 550 25 is_stmt 1 view .LVU493
 1699 0312 0321     		movs	r1, #3
 1700 0314 2046     		mov	r0, r4
 1701 0316 FFF7FEFF 		bl	set_oneshot_layer
 1702              	.LVL173:
 679:quantum/action.c ****         case ACT_LAYER:
 1703              		.loc 1 679 5 view .LVU494
 1704 031a 7BE7     		b	.L119
 1705              	.LVL174:
 1706              	.L139:
 552:quantum/action.c ****                         if (tap_count > 1) {
 1707              		.loc 1 552 25 view .LVU495
 1708 031c 0120     		movs	r0, #1
 1709 031e FFF7FEFF 		bl	clear_oneshot_layer_state
 1710              	.LVL175:
 553:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1711              		.loc 1 553 25 view .LVU496
 553:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1712              		.loc 1 553 28 is_stmt 0 view .LVU497
 1713 0322 012E     		cmp	r6, #1
 1714 0324 7FF676AF 		bls	.L119
 554:quantum/action.c ****                         }
 1715              		.loc 1 554 29 is_stmt 1 view .LVU498
 1716 0328 0220     		movs	r0, #2
 1717 032a FFF7FEFF 		bl	clear_oneshot_layer_state
 1718              	.LVL176:
 679:quantum/action.c ****         case ACT_LAYER:
 1719              		.loc 1 679 5 view .LVU499
 1720 032e 71E7     		b	.L119
 1721              	.L127:
 562:quantum/action.c ****                         if (tap_count > 0) {
 1722              		.loc 1 562 21 view .LVU500
 562:quantum/action.c ****                         if (tap_count > 0) {
 1723              		.loc 1 562 24 is_stmt 0 view .LVU501
 1724 0330 3DB1     		cbz	r5, .L140
 563:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1725              		.loc 1 563 25 is_stmt 1 view .LVU502
 563:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1726              		.loc 1 563 28 is_stmt 0 view .LVU503
 1727 0332 1EB1     		cbz	r6, .L141
 564:quantum/action.c ****                             register_code(action.layer_tap.code);
 1728              		.loc 1 564 75 is_stmt 1 view .LVU504
 565:quantum/action.c ****                         } else {
 1729              		.loc 1 565 29 view .LVU505
 1730 0334 4846     		mov	r0, r9
 1731 0336 FFF7FEFF 		bl	register_code
 1732              	.LVL177:
 679:quantum/action.c ****         case ACT_LAYER:
 1733              		.loc 1 679 5 view .LVU506
 1734 033a 6BE7     		b	.L119
 1735              	.L141:
 567:quantum/action.c ****                             layer_on(action.layer_tap.val);
 1736              		.loc 1 567 76 view .LVU507
 568:quantum/action.c ****                         }
 1737              		.loc 1 568 29 view .LVU508
 1738 033c C4F30420 		ubfx	r0, r4, #8, #5
 1739 0340 D0E7     		b	.L176
 1740              	.L140:
 571:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1741              		.loc 1 571 25 view .LVU509
 571:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1742              		.loc 1 571 28 is_stmt 0 view .LVU510
 1743 0342 5EB1     		cbz	r6, .L142
 572:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1744              		.loc 1 572 77 is_stmt 1 view .LVU511
 573:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1745              		.loc 1 573 29 view .LVU512
 573:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1746              		.loc 1 573 32 is_stmt 0 view .LVU513
 1747 0344 B9F1390F 		cmp	r9, #57
 574:quantum/action.c ****                             } else {
 1748              		.loc 1 574 33 is_stmt 1 view .LVU514
 574:quantum/action.c ****                             } else {
 1749              		.loc 1 574 33 view .LVU515
 574:quantum/action.c ****                             } else {
 1750              		.loc 1 574 33 view .LVU516
 1751 0348 0CBF     		ite	eq
 1752 034a 4FF44870 		moveq	r0, #800
 576:quantum/action.c ****                             }
 1753              		.loc 1 576 33 view .LVU517
 576:quantum/action.c ****                             }
 1754              		.loc 1 576 33 view .LVU518
 576:quantum/action.c ****                             }
 1755              		.loc 1 576 33 view .LVU519
 1756 034e 0120     		movne	r0, #1
 1757 0350 FFF7FEFF 		bl	chThdSleep
 1758              	.LVL178:
 576:quantum/action.c ****                             }
 1759              		.loc 1 576 33 view .LVU520
 578:quantum/action.c ****                         } else {
 1760              		.loc 1 578 29 view .LVU521
 1761 0354 4846     		mov	r0, r9
 1762 0356 FFF7FEFF 		bl	unregister_code
 1763              	.LVL179:
 679:quantum/action.c ****         case ACT_LAYER:
 1764              		.loc 1 679 5 view .LVU522
 1765 035a 5BE7     		b	.L119
 1766              	.L142:
 580:quantum/action.c ****                             layer_off(action.layer_tap.val);
 1767              		.loc 1 580 79 view .LVU523
 581:quantum/action.c ****                         }
 1768              		.loc 1 581 29 view .LVU524
 1769 035c C4F30420 		ubfx	r0, r4, #8, #5
 1770 0360 A4E7     		b	.L175
 1771              	.L73:
 592:quantum/action.c ****             break;
 1772              		.loc 1 592 13 view .LVU525
 1773 0362 C4F30322 		ubfx	r2, r4, #8, #4
 1774 0366 E1B2     		uxtb	r1, r4
 1775 0368 4046     		mov	r0, r8
 1776 036a FFF7FEFF 		bl	action_get_macro
 1777              	.LVL180:
 1778 036e FFF7FEFF 		bl	action_macro_play
 1779              	.LVL181:
 593:quantum/action.c **** #endif
 1780              		.loc 1 593 13 view .LVU526
 679:quantum/action.c ****         case ACT_LAYER:
 1781              		.loc 1 679 5 view .LVU527
 1782 0372 A8E6     		b	.L70
 1783              	.L71:
 670:quantum/action.c ****             break;
 1784              		.loc 1 670 13 view .LVU528
 1785 0374 C4F30322 		ubfx	r2, r4, #8, #4
 1786 0378 E1B2     		uxtb	r1, r4
 1787 037a 4046     		mov	r0, r8
 1788 037c FFF7FEFF 		bl	action_function
 1789              	.LVL182:
 671:quantum/action.c **** #endif
 1790              		.loc 1 671 13 view .LVU529
 679:quantum/action.c ****         case ACT_LAYER:
 1791              		.loc 1 679 5 view .LVU530
 1792 0380 A1E6     		b	.L70
 1793              	.LVL183:
 1794              	.L67:
 739:quantum/action.c **** 
 1795              		.loc 1 739 1 is_stmt 0 view .LVU531
 1796 0382 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 739:quantum/action.c **** 
 1797              		.loc 1 739 1 view .LVU532
 1798              		.cfi_endproc
 1799              	.LFE299:
 1801              		.section	.text.process_record_handler,"ax",%progbits
 1802              		.align	1
 1803              		.global	process_record_handler
 1804              		.syntax unified
 1805              		.thumb
 1806              		.thumb_func
 1808              	process_record_handler:
 1809              	.LVL184:
 1810              	.LFB298:
 208:quantum/action.c **** #ifdef COMBO_ENABLE
 1811              		.loc 1 208 50 is_stmt 1 view -0
 1812              		.cfi_startproc
 1813              		@ args = 0, pretend = 0, frame = 0
 1814              		@ frame_needed = 0, uses_anonymous_args = 0
 217:quantum/action.c **** #endif
 1815              		.loc 1 217 5 view .LVU534
 208:quantum/action.c **** #ifdef COMBO_ENABLE
 1816              		.loc 1 208 50 is_stmt 0 view .LVU535
 1817 0000 38B5     		push	{r3, r4, r5, lr}
 1818              		.cfi_def_cfa_offset 16
 1819              		.cfi_offset 3, -16
 1820              		.cfi_offset 4, -12
 1821              		.cfi_offset 5, -8
 1822              		.cfi_offset 14, -4
 217:quantum/action.c **** #endif
 1823              		.loc 1 217 23 view .LVU536
 1824 0002 0188     		ldrh	r1, [r0]
 208:quantum/action.c **** #ifdef COMBO_ENABLE
 1825              		.loc 1 208 50 view .LVU537
 1826 0004 0446     		mov	r4, r0
 217:quantum/action.c **** #endif
 1827              		.loc 1 217 23 view .LVU538
 1828 0006 8078     		ldrb	r0, [r0, #2]	@ zero_extendqisi2
 1829              	.LVL185:
 217:quantum/action.c **** #endif
 1830              		.loc 1 217 23 view .LVU539
 1831 0008 FFF7FEFF 		bl	store_or_get_action
 1832              	.LVL186:
 1833 000c 0546     		mov	r5, r0	@ movhi
 1834              	.LVL187:
 219:quantum/action.c ****     debug_action(action);
 1835              		.loc 1 219 23 is_stmt 1 view .LVU540
 220:quantum/action.c **** #ifndef NO_ACTION_LAYER
 1836              		.loc 1 220 5 view .LVU541
 222:quantum/action.c ****     layer_debug();
 1837              		.loc 1 222 29 view .LVU542
 223:quantum/action.c ****     dprint(" default_layer_state: ");
 1838              		.loc 1 223 5 view .LVU543
 1839 000e FFF7FEFF 		bl	layer_debug
 1840              	.LVL188:
 224:quantum/action.c ****     default_layer_debug();
 1841              		.loc 1 224 37 view .LVU544
 225:quantum/action.c **** #endif
 1842              		.loc 1 225 5 view .LVU545
 1843 0012 FFF7FEFF 		bl	default_layer_debug
 1844              	.LVL189:
 227:quantum/action.c **** 
 1845              		.loc 1 227 15 view .LVU546
 229:quantum/action.c **** }
 1846              		.loc 1 229 5 view .LVU547
 229:quantum/action.c **** }
 1847              		.loc 1 229 5 is_stmt 0 view .LVU548
 1848 0016 2946     		mov	r1, r5	@ movhi
 1849 0018 2046     		mov	r0, r4
 230:quantum/action.c **** 
 1850              		.loc 1 230 1 view .LVU549
 1851 001a BDE83840 		pop	{r3, r4, r5, lr}
 1852              		.cfi_restore 14
 1853              		.cfi_restore 5
 1854              		.cfi_restore 4
 1855              		.cfi_restore 3
 1856              		.cfi_def_cfa_offset 0
 1857              	.LVL190:
 229:quantum/action.c **** }
 1858              		.loc 1 229 5 view .LVU550
 1859 001e FFF7FEBF 		b	process_action
 1860              	.LVL191:
 229:quantum/action.c **** }
 1861              		.loc 1 229 5 view .LVU551
 1862              		.cfi_endproc
 1863              	.LFE298:
 1865              		.section	.text.process_record,"ax",%progbits
 1866              		.align	1
 1867              		.global	process_record
 1868              		.syntax unified
 1869              		.thumb
 1870              		.thumb_func
 1872              	process_record:
 1873              	.LVL192:
 1874              	.LFB297:
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 1875              		.loc 1 190 42 is_stmt 1 view -0
 1876              		.cfi_startproc
 1877              		@ args = 0, pretend = 0, frame = 8
 1878              		@ frame_needed = 0, uses_anonymous_args = 0
 191:quantum/action.c ****         return;
 1879              		.loc 1 191 5 view .LVU553
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 1880              		.loc 1 190 42 is_stmt 0 view .LVU554
 1881 0000 13B5     		push	{r0, r1, r4, lr}
 1882              		.cfi_def_cfa_offset 16
 1883              		.cfi_offset 4, -8
 1884              		.cfi_offset 14, -4
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 1885              		.loc 1 190 42 view .LVU555
 1886 0002 0446     		mov	r4, r0
 1887 0004 0068     		ldr	r0, [r0]	@ unaligned
 1888              	.LVL193:
 1889              	.LBB87:
 1890              	.LBB88:
 1891              		.loc 2 47 74 view .LVU556
 1892 0006 A388     		ldrh	r3, [r4, #4]
 1893 0008 0090     		str	r0, [sp]
 1894              	.LVL194:
 1895              		.loc 2 47 74 view .LVU557
 1896              	.LBE88:
 1897              	.LBI87:
 1898              		.loc 2 47 20 is_stmt 1 view .LVU558
 1899              	.LBB89:
 1900              		.loc 2 47 51 view .LVU559
 1901              		.loc 2 47 74 is_stmt 0 view .LVU560
 1902 000a D3B1     		cbz	r3, .L182
 1903 000c BDF80020 		ldrh	r2, [sp]
 1904 0010 4FF6FF73 		movw	r3, #65535
 1905 0014 9A42     		cmp	r2, r3
 1906 0016 14D0     		beq	.L182
 1907              	.LVL195:
 1908              		.loc 2 47 74 view .LVU561
 1909              	.LBE89:
 1910              	.LBE87:
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 1911              		.loc 1 195 5 is_stmt 1 view .LVU562
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 1912              		.loc 1 195 10 is_stmt 0 view .LVU563
 1913 0018 2046     		mov	r0, r4
 1914 001a FFF7FEFF 		bl	process_record_quantum
 1915              	.LVL196:
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 1916              		.loc 1 195 8 view .LVU564
 1917 001e 50B9     		cbnz	r0, .L184
 1918              	.LVL197:
 1919              	.LBB90:
 1920              	.LBI90:
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 1921              		.loc 1 190 6 is_stmt 1 view .LVU565
 1922              	.LBB91:
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1923              		.loc 1 197 9 view .LVU566
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1924              		.loc 1 197 13 is_stmt 0 view .LVU567
 1925 0020 FFF7FEFF 		bl	is_oneshot_layer_active
 1926              	.LVL198:
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1927              		.loc 1 197 12 view .LVU568
 1928 0024 68B1     		cbz	r0, .L182
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1929              		.loc 1 197 39 view .LVU569
 1930 0026 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1931 0028 5BB1     		cbz	r3, .L182
 198:quantum/action.c ****         }
 1932              		.loc 1 198 13 is_stmt 1 view .LVU570
 1933 002a 0220     		movs	r0, #2
 1934              	.LBE91:
 1935              	.LBE90:
 206:quantum/action.c **** 
 1936              		.loc 1 206 1 is_stmt 0 view .LVU571
 1937 002c 02B0     		add	sp, sp, #8
 1938              		.cfi_remember_state
 1939              		.cfi_def_cfa_offset 8
 1940              		@ sp needed
 1941 002e BDE81040 		pop	{r4, lr}
 1942              		.cfi_restore 14
 1943              		.cfi_restore 4
 1944              		.cfi_def_cfa_offset 0
 1945              	.LVL199:
 1946              	.LBB93:
 1947              	.LBB92:
 198:quantum/action.c ****         }
 1948              		.loc 1 198 13 view .LVU572
 1949 0032 FFF7FEBF 		b	clear_oneshot_layer_state
 1950              	.LVL200:
 1951              	.L184:
 1952              		.cfi_restore_state
 198:quantum/action.c ****         }
 1953              		.loc 1 198 13 view .LVU573
 1954              	.LBE92:
 1955              	.LBE93:
 204:quantum/action.c ****     post_process_record_quantum(record);
 1956              		.loc 1 204 5 is_stmt 1 view .LVU574
 1957 0036 2046     		mov	r0, r4
 1958 0038 FFF7FEFF 		bl	process_record_handler
 1959              	.LVL201:
 205:quantum/action.c **** }
 1960              		.loc 1 205 5 view .LVU575
 1961 003c 2046     		mov	r0, r4
 1962 003e FFF7FEFF 		bl	post_process_record_quantum
 1963              	.LVL202:
 1964              	.L182:
 206:quantum/action.c **** 
 1965              		.loc 1 206 1 is_stmt 0 view .LVU576
 1966 0042 02B0     		add	sp, sp, #8
 1967              		.cfi_def_cfa_offset 8
 1968              		@ sp needed
 1969 0044 10BD     		pop	{r4, pc}
 206:quantum/action.c **** 
 1970              		.loc 1 206 1 view .LVU577
 1971              		.cfi_endproc
 1972              	.LFE297:
 1974              		.section	.text.process_record_nocache,"ax",%progbits
 1975              		.align	1
 1976              		.global	process_record_nocache
 1977              		.syntax unified
 1978              		.thumb
 1979              		.thumb_func
 1981              	process_record_nocache:
 1982              	.LVL203:
 1983              	.LFB293:
 148:quantum/action.c ****     disable_action_cache = true;
 1984              		.loc 1 148 50 is_stmt 1 view -0
 1985              		.cfi_startproc
 1986              		@ args = 0, pretend = 0, frame = 0
 1987              		@ frame_needed = 0, uses_anonymous_args = 0
 149:quantum/action.c ****     process_record(record);
 1988              		.loc 1 149 5 view .LVU579
 148:quantum/action.c ****     disable_action_cache = true;
 1989              		.loc 1 148 50 is_stmt 0 view .LVU580
 1990 0000 10B5     		push	{r4, lr}
 1991              		.cfi_def_cfa_offset 8
 1992              		.cfi_offset 4, -8
 1993              		.cfi_offset 14, -4
 149:quantum/action.c ****     process_record(record);
 1994              		.loc 1 149 26 view .LVU581
 1995 0002 044C     		ldr	r4, .L197
 1996 0004 0123     		movs	r3, #1
 1997 0006 2370     		strb	r3, [r4]
 150:quantum/action.c ****     disable_action_cache = false;
 1998              		.loc 1 150 5 is_stmt 1 view .LVU582
 1999 0008 FFF7FEFF 		bl	process_record
 2000              	.LVL204:
 151:quantum/action.c **** }
 2001              		.loc 1 151 5 view .LVU583
 151:quantum/action.c **** }
 2002              		.loc 1 151 26 is_stmt 0 view .LVU584
 2003 000c 0023     		movs	r3, #0
 2004 000e 2370     		strb	r3, [r4]
 152:quantum/action.c **** #else
 2005              		.loc 1 152 1 view .LVU585
 2006 0010 10BD     		pop	{r4, pc}
 2007              	.L198:
 2008 0012 00BF     		.align	2
 2009              	.L197:
 2010 0014 00000000 		.word	disable_action_cache
 2011              		.cfi_endproc
 2012              	.LFE293:
 2014              		.section	.text.register_weak_mods,"ax",%progbits
 2015              		.align	1
 2016              		.global	register_weak_mods
 2017              		.syntax unified
 2018              		.thumb
 2019              		.thumb_func
 2021              	register_weak_mods:
 2022              	.LVL205:
 2023              	.LFB306:
 934:quantum/action.c **** 
 935:quantum/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 936:quantum/action.c ****  *
 937:quantum/action.c ****  * \param mods A bitfield of modifiers to register.
 938:quantum/action.c ****  */
 939:quantum/action.c **** void register_weak_mods(uint8_t mods) {
 2024              		.loc 1 939 39 is_stmt 1 view -0
 2025              		.cfi_startproc
 2026              		@ args = 0, pretend = 0, frame = 0
 2027              		@ frame_needed = 0, uses_anonymous_args = 0
 940:quantum/action.c ****     if (mods) {
 2028              		.loc 1 940 5 view .LVU587
 939:quantum/action.c ****     if (mods) {
 2029              		.loc 1 939 39 is_stmt 0 view .LVU588
 2030 0000 08B5     		push	{r3, lr}
 2031              		.cfi_def_cfa_offset 8
 2032              		.cfi_offset 3, -8
 2033              		.cfi_offset 14, -4
 2034              		.loc 1 940 8 view .LVU589
 2035 0002 28B1     		cbz	r0, .L199
 941:quantum/action.c ****         add_weak_mods(mods);
 2036              		.loc 1 941 9 is_stmt 1 view .LVU590
 2037 0004 FFF7FEFF 		bl	add_weak_mods
 2038              	.LVL206:
 942:quantum/action.c ****         send_keyboard_report();
 2039              		.loc 1 942 9 view .LVU591
 943:quantum/action.c ****     }
 944:quantum/action.c **** }
 2040              		.loc 1 944 1 is_stmt 0 view .LVU592
 2041 0008 BDE80840 		pop	{r3, lr}
 2042              		.cfi_remember_state
 2043              		.cfi_restore 14
 2044              		.cfi_restore 3
 2045              		.cfi_def_cfa_offset 0
 942:quantum/action.c ****         send_keyboard_report();
 2046              		.loc 1 942 9 view .LVU593
 2047 000c FFF7FEBF 		b	send_keyboard_report
 2048              	.LVL207:
 2049              	.L199:
 2050              		.cfi_restore_state
 2051              		.loc 1 944 1 view .LVU594
 2052 0010 08BD     		pop	{r3, pc}
 2053              		.cfi_endproc
 2054              	.LFE306:
 2056              		.section	.text.unregister_weak_mods,"ax",%progbits
 2057              		.align	1
 2058              		.global	unregister_weak_mods
 2059              		.syntax unified
 2060              		.thumb
 2061              		.thumb_func
 2063              	unregister_weak_mods:
 2064              	.LVL208:
 2065              	.LFB307:
 945:quantum/action.c **** 
 946:quantum/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 947:quantum/action.c ****  *
 948:quantum/action.c ****  * \param mods A bitfield of modifiers to unregister.
 949:quantum/action.c ****  */
 950:quantum/action.c **** void unregister_weak_mods(uint8_t mods) {
 2066              		.loc 1 950 41 is_stmt 1 view -0
 2067              		.cfi_startproc
 2068              		@ args = 0, pretend = 0, frame = 0
 2069              		@ frame_needed = 0, uses_anonymous_args = 0
 951:quantum/action.c ****     if (mods) {
 2070              		.loc 1 951 5 view .LVU596
 950:quantum/action.c ****     if (mods) {
 2071              		.loc 1 950 41 is_stmt 0 view .LVU597
 2072 0000 08B5     		push	{r3, lr}
 2073              		.cfi_def_cfa_offset 8
 2074              		.cfi_offset 3, -8
 2075              		.cfi_offset 14, -4
 2076              		.loc 1 951 8 view .LVU598
 2077 0002 28B1     		cbz	r0, .L201
 952:quantum/action.c ****         del_weak_mods(mods);
 2078              		.loc 1 952 9 is_stmt 1 view .LVU599
 2079 0004 FFF7FEFF 		bl	del_weak_mods
 2080              	.LVL209:
 953:quantum/action.c ****         send_keyboard_report();
 2081              		.loc 1 953 9 view .LVU600
 954:quantum/action.c ****     }
 955:quantum/action.c **** }
 2082              		.loc 1 955 1 is_stmt 0 view .LVU601
 2083 0008 BDE80840 		pop	{r3, lr}
 2084              		.cfi_remember_state
 2085              		.cfi_restore 14
 2086              		.cfi_restore 3
 2087              		.cfi_def_cfa_offset 0
 953:quantum/action.c ****         send_keyboard_report();
 2088              		.loc 1 953 9 view .LVU602
 2089 000c FFF7FEBF 		b	send_keyboard_report
 2090              	.LVL210:
 2091              	.L201:
 2092              		.cfi_restore_state
 2093              		.loc 1 955 1 view .LVU603
 2094 0010 08BD     		pop	{r3, pc}
 2095              		.cfi_endproc
 2096              	.LFE307:
 2098              		.section	.text.clear_keyboard_but_mods_and_keys,"ax",%progbits
 2099              		.align	1
 2100              		.global	clear_keyboard_but_mods_and_keys
 2101              		.syntax unified
 2102              		.thumb
 2103              		.thumb_func
 2105              	clear_keyboard_but_mods_and_keys:
 2106              	.LFB310:
 956:quantum/action.c **** 
 957:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:quantum/action.c ****  *
 959:quantum/action.c ****  * FIXME: Needs documentation.
 960:quantum/action.c ****  */
 961:quantum/action.c **** void clear_keyboard(void) {
 962:quantum/action.c ****     clear_mods();
 963:quantum/action.c ****     clear_keyboard_but_mods();
 964:quantum/action.c **** }
 965:quantum/action.c **** 
 966:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:quantum/action.c ****  *
 968:quantum/action.c ****  * FIXME: Needs documentation.
 969:quantum/action.c ****  */
 970:quantum/action.c **** void clear_keyboard_but_mods(void) {
 971:quantum/action.c ****     clear_keys();
 972:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 973:quantum/action.c **** }
 974:quantum/action.c **** 
 975:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 976:quantum/action.c ****  *
 977:quantum/action.c ****  * FIXME: Needs documentation.
 978:quantum/action.c ****  */
 979:quantum/action.c **** void clear_keyboard_but_mods_and_keys() {
 2107              		.loc 1 979 41 is_stmt 1 view -0
 2108              		.cfi_startproc
 2109              		@ args = 0, pretend = 0, frame = 0
 2110              		@ frame_needed = 0, uses_anonymous_args = 0
 980:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 981:quantum/action.c ****     host_system_send(0);
 2111              		.loc 1 981 5 view .LVU605
 979:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 2112              		.loc 1 979 41 is_stmt 0 view .LVU606
 2113 0000 08B5     		push	{r3, lr}
 2114              		.cfi_def_cfa_offset 8
 2115              		.cfi_offset 3, -8
 2116              		.cfi_offset 14, -4
 2117              		.loc 1 981 5 view .LVU607
 2118 0002 0020     		movs	r0, #0
 2119 0004 FFF7FEFF 		bl	host_system_send
 2120              	.LVL211:
 982:quantum/action.c ****     host_consumer_send(0);
 2121              		.loc 1 982 5 is_stmt 1 view .LVU608
 2122 0008 0020     		movs	r0, #0
 2123 000a FFF7FEFF 		bl	host_consumer_send
 2124              	.LVL212:
 983:quantum/action.c **** #endif
 984:quantum/action.c ****     clear_weak_mods();
 2125              		.loc 1 984 5 view .LVU609
 2126 000e FFF7FEFF 		bl	clear_weak_mods
 2127              	.LVL213:
 985:quantum/action.c ****     clear_macro_mods();
 2128              		.loc 1 985 5 view .LVU610
 2129 0012 FFF7FEFF 		bl	clear_macro_mods
 2130              	.LVL214:
 986:quantum/action.c ****     send_keyboard_report();
 2131              		.loc 1 986 5 view .LVU611
 2132 0016 FFF7FEFF 		bl	send_keyboard_report
 2133              	.LVL215:
 987:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 988:quantum/action.c ****     mousekey_clear();
 2134              		.loc 1 988 5 view .LVU612
 2135 001a FFF7FEFF 		bl	mousekey_clear
 2136              	.LVL216:
 989:quantum/action.c ****     mousekey_send();
 2137              		.loc 1 989 5 view .LVU613
 990:quantum/action.c **** #endif
 991:quantum/action.c **** }
 2138              		.loc 1 991 1 is_stmt 0 view .LVU614
 2139 001e BDE80840 		pop	{r3, lr}
 2140              		.cfi_restore 14
 2141              		.cfi_restore 3
 2142              		.cfi_def_cfa_offset 0
 989:quantum/action.c ****     mousekey_send();
 2143              		.loc 1 989 5 view .LVU615
 2144 0022 FFF7FEBF 		b	mousekey_send
 2145              	.LVL217:
 2146              		.cfi_endproc
 2147              	.LFE310:
 2149              		.section	.text.clear_keyboard_but_mods,"ax",%progbits
 2150              		.align	1
 2151              		.global	clear_keyboard_but_mods
 2152              		.syntax unified
 2153              		.thumb
 2154              		.thumb_func
 2156              	clear_keyboard_but_mods:
 2157              	.LFB309:
 970:quantum/action.c ****     clear_keys();
 2158              		.loc 1 970 36 is_stmt 1 view -0
 2159              		.cfi_startproc
 2160              		@ args = 0, pretend = 0, frame = 0
 2161              		@ frame_needed = 0, uses_anonymous_args = 0
 971:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 2162              		.loc 1 971 5 view .LVU617
 970:quantum/action.c ****     clear_keys();
 2163              		.loc 1 970 36 is_stmt 0 view .LVU618
 2164 0000 08B5     		push	{r3, lr}
 2165              		.cfi_def_cfa_offset 8
 2166              		.cfi_offset 3, -8
 2167              		.cfi_offset 14, -4
 971:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 2168              		.loc 1 971 5 view .LVU619
 2169 0002 FFF7FEFF 		bl	clear_keys
 2170              	.LVL218:
 972:quantum/action.c **** }
 2171              		.loc 1 972 5 is_stmt 1 view .LVU620
 973:quantum/action.c **** 
 2172              		.loc 1 973 1 is_stmt 0 view .LVU621
 2173 0006 BDE80840 		pop	{r3, lr}
 2174              		.cfi_restore 14
 2175              		.cfi_restore 3
 2176              		.cfi_def_cfa_offset 0
 972:quantum/action.c **** }
 2177              		.loc 1 972 5 view .LVU622
 2178 000a FFF7FEBF 		b	clear_keyboard_but_mods_and_keys
 2179              	.LVL219:
 2180              		.cfi_endproc
 2181              	.LFE309:
 2183              		.section	.text.clear_keyboard,"ax",%progbits
 2184              		.align	1
 2185              		.global	clear_keyboard
 2186              		.syntax unified
 2187              		.thumb
 2188              		.thumb_func
 2190              	clear_keyboard:
 2191              	.LFB308:
 961:quantum/action.c ****     clear_mods();
 2192              		.loc 1 961 27 is_stmt 1 view -0
 2193              		.cfi_startproc
 2194              		@ args = 0, pretend = 0, frame = 0
 2195              		@ frame_needed = 0, uses_anonymous_args = 0
 962:quantum/action.c ****     clear_keyboard_but_mods();
 2196              		.loc 1 962 5 view .LVU624
 961:quantum/action.c ****     clear_mods();
 2197              		.loc 1 961 27 is_stmt 0 view .LVU625
 2198 0000 08B5     		push	{r3, lr}
 2199              		.cfi_def_cfa_offset 8
 2200              		.cfi_offset 3, -8
 2201              		.cfi_offset 14, -4
 962:quantum/action.c ****     clear_keyboard_but_mods();
 2202              		.loc 1 962 5 view .LVU626
 2203 0002 FFF7FEFF 		bl	clear_mods
 2204              	.LVL220:
 963:quantum/action.c **** }
 2205              		.loc 1 963 5 is_stmt 1 view .LVU627
 964:quantum/action.c **** 
 2206              		.loc 1 964 1 is_stmt 0 view .LVU628
 2207 0006 BDE80840 		pop	{r3, lr}
 2208              		.cfi_restore 14
 2209              		.cfi_restore 3
 2210              		.cfi_def_cfa_offset 0
 963:quantum/action.c **** }
 2211              		.loc 1 963 5 view .LVU629
 2212 000a FFF7FEBF 		b	clear_keyboard_but_mods
 2213              	.LVL221:
 2214              		.cfi_endproc
 2215              	.LFE308:
 2217              		.section	.text.is_tap_action,"ax",%progbits
 2218              		.align	1
 2219              		.global	is_tap_action
 2220              		.syntax unified
 2221              		.thumb
 2222              		.thumb_func
 2224              	is_tap_action:
 2225              	.LVL222:
 2226              	.LFB313:
 992:quantum/action.c **** 
 993:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:quantum/action.c ****  *
 995:quantum/action.c ****  * FIXME: Needs documentation.
 996:quantum/action.c ****  */
 997:quantum/action.c **** bool is_tap_key(keypos_t key) {
 998:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 999:quantum/action.c ****     return is_tap_action(action);
1000:quantum/action.c **** }
1001:quantum/action.c **** 
1002:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1003:quantum/action.c ****  *
1004:quantum/action.c ****  * FIXME: Needs documentation.
1005:quantum/action.c ****  */
1006:quantum/action.c **** bool is_tap_record(keyrecord_t *record) {
1007:quantum/action.c **** #ifdef COMBO_ENABLE
1008:quantum/action.c ****     action_t action;
1009:quantum/action.c ****     if (record->keycode) {
1010:quantum/action.c ****         action = action_for_keycode(record->keycode);
1011:quantum/action.c ****     } else {
1012:quantum/action.c ****         action = layer_switch_get_action(record->event.key);
1013:quantum/action.c ****     }
1014:quantum/action.c **** #else
1015:quantum/action.c ****     action_t action = layer_switch_get_action(record->event.key);
1016:quantum/action.c **** #endif
1017:quantum/action.c ****     return is_tap_action(action);
1018:quantum/action.c **** }
1019:quantum/action.c **** 
1020:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1021:quantum/action.c ****  *
1022:quantum/action.c ****  * FIXME: Needs documentation.
1023:quantum/action.c ****  */
1024:quantum/action.c **** bool is_tap_action(action_t action) {
 2227              		.loc 1 1024 37 is_stmt 1 view -0
 2228              		.cfi_startproc
 2229              		@ args = 0, pretend = 0, frame = 0
 2230              		@ frame_needed = 0, uses_anonymous_args = 0
 2231              		@ link register save eliminated.
1025:quantum/action.c ****     switch (action.kind.id) {
 2232              		.loc 1 1025 5 is_stmt 0 view .LVU631
 2233 0000 C0F30332 		ubfx	r2, r0, #12, #4
 2234 0004 023A     		subs	r2, r2, #2
 2235 0006 C3B2     		uxtb	r3, r0
 2236              	.LVL223:
 2237              		.loc 1 1025 5 is_stmt 1 view .LVU632
 2238 0008 0D2A     		cmp	r2, #13
 2239 000a 20D8     		bhi	.L213
 2240 000c DFE802F0 		tbb	[pc, r2]
 2241              	.L209:
 2242 0010 07       		.byte	(.L210-.L209)/2
 2243 0011 07       		.byte	(.L210-.L209)/2
 2244 0012 1F       		.byte	(.L213-.L209)/2
 2245 0013 1F       		.byte	(.L213-.L209)/2
 2246 0014 14       		.byte	(.L211-.L209)/2
 2247 0015 1F       		.byte	(.L213-.L209)/2
 2248 0016 1F       		.byte	(.L213-.L209)/2
 2249 0017 1F       		.byte	(.L213-.L209)/2
 2250 0018 07       		.byte	(.L210-.L209)/2
 2251 0019 07       		.byte	(.L210-.L209)/2
 2252 001a 18       		.byte	(.L208-.L209)/2
 2253 001b 1F       		.byte	(.L213-.L209)/2
 2254 001c 1F       		.byte	(.L213-.L209)/2
 2255 001d 18       		.byte	(.L208-.L209)/2
 2256              		.p2align 1
 2257              	.L210:
1026:quantum/action.c ****         case ACT_LMODS_TAP:
1027:quantum/action.c ****         case ACT_RMODS_TAP:
1028:quantum/action.c ****         case ACT_LAYER_TAP:
1029:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
1030:quantum/action.c ****             switch (action.layer_tap.code) {
 2258              		.loc 1 1030 13 view .LVU633
 2259 001e F02B     		cmp	r3, #240
 2260 0020 17D0     		beq	.L215
 2261 0022 04D8     		bhi	.L212
 2262 0024 E72B     		cmp	r3, #231
 2263 0026 8CBF     		ite	hi
 2264 0028 0020     		movhi	r0, #0
 2265              	.LVL224:
 2266              		.loc 1 1030 13 is_stmt 0 view .LVU634
 2267 002a 0120     		movls	r0, #1
 2268 002c 7047     		bx	lr
 2269              	.LVL225:
 2270              	.L212:
 2271              		.loc 1 1030 13 view .LVU635
 2272 002e F42B     		cmp	r3, #244
 2273              	.L216:
 2274 0030 14BF     		ite	ne
 2275 0032 0020     		movne	r0, #0
 2276              	.LVL226:
 2277              		.loc 1 1030 13 view .LVU636
 2278 0034 0120     		moveq	r0, #1
 2279 0036 7047     		bx	lr
 2280              	.LVL227:
 2281              	.L211:
1031:quantum/action.c ****                 case KC_NO ... KC_RGUI:
1032:quantum/action.c ****                 case OP_TAP_TOGGLE:
1033:quantum/action.c ****                 case OP_ONESHOT:
1034:quantum/action.c ****                     return true;
1035:quantum/action.c ****             }
1036:quantum/action.c ****             return false;
1037:quantum/action.c ****         case ACT_SWAP_HANDS:
1038:quantum/action.c ****             switch (action.swap.code) {
 2282              		.loc 1 1038 13 is_stmt 1 view .LVU637
 2283 0038 E72B     		cmp	r3, #231
 2284 003a 0AD9     		bls	.L215
 2285 003c F12B     		cmp	r3, #241
 2286 003e F7E7     		b	.L216
 2287              	.L208:
1039:quantum/action.c ****                 case KC_NO ... KC_RGUI:
1040:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
1041:quantum/action.c ****                     return true;
1042:quantum/action.c ****             }
1043:quantum/action.c ****             return false;
1044:quantum/action.c ****         case ACT_MACRO:
1045:quantum/action.c ****         case ACT_FUNCTION:
1046:quantum/action.c ****             if (action.func.opt & FUNC_TAP) {
 2288              		.loc 1 1046 13 view .LVU638
 2289              		.loc 1 1046 16 is_stmt 0 view .LVU639
 2290 0040 C0F30320 		ubfx	r0, r0, #8, #4
 2291              	.LVL228:
 2292              		.loc 1 1046 16 view .LVU640
 2293 0044 0728     		cmp	r0, #7
 2294 0046 94BF     		ite	ls
 2295 0048 0020     		movls	r0, #0
 2296 004a 0120     		movhi	r0, #1
 2297 004c 7047     		bx	lr
 2298              	.LVL229:
 2299              	.L213:
1025:quantum/action.c ****         case ACT_LMODS_TAP:
 2300              		.loc 1 1025 5 view .LVU641
 2301 004e 0020     		movs	r0, #0
 2302              	.LVL230:
1025:quantum/action.c ****         case ACT_LMODS_TAP:
 2303              		.loc 1 1025 5 view .LVU642
 2304 0050 7047     		bx	lr
 2305              	.LVL231:
 2306              	.L215:
1034:quantum/action.c ****             }
 2307              		.loc 1 1034 28 view .LVU643
 2308 0052 0120     		movs	r0, #1
 2309              	.LVL232:
1047:quantum/action.c ****                 return true;
1048:quantum/action.c ****             }
1049:quantum/action.c ****             return false;
1050:quantum/action.c ****     }
1051:quantum/action.c ****     return false;
1052:quantum/action.c **** }
 2310              		.loc 1 1052 1 view .LVU644
 2311 0054 7047     		bx	lr
 2312              		.cfi_endproc
 2313              	.LFE313:
 2315              		.section	.text.is_tap_key,"ax",%progbits
 2316              		.align	1
 2317              		.global	is_tap_key
 2318              		.syntax unified
 2319              		.thumb
 2320              		.thumb_func
 2322              	is_tap_key:
 2323              	.LFB311:
 997:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 2324              		.loc 1 997 31 is_stmt 1 view -0
 2325              		.cfi_startproc
 2326              		@ args = 0, pretend = 0, frame = 8
 2327              		@ frame_needed = 0, uses_anonymous_args = 0
 998:quantum/action.c ****     return is_tap_action(action);
 2328              		.loc 1 998 5 view .LVU646
 997:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 2329              		.loc 1 997 31 is_stmt 0 view .LVU647
 2330 0000 07B5     		push	{r0, r1, r2, lr}
 2331              		.cfi_def_cfa_offset 16
 2332              		.cfi_offset 14, -4
 997:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 2333              		.loc 1 997 31 view .LVU648
 2334 0002 ADF80400 		strh	r0, [sp, #4]	@ movhi
 998:quantum/action.c ****     return is_tap_action(action);
 2335              		.loc 1 998 23 view .LVU649
 2336 0006 0198     		ldr	r0, [sp, #4]
 2337 0008 FFF7FEFF 		bl	layer_switch_get_action
 2338              	.LVL233:
 999:quantum/action.c **** }
 2339              		.loc 1 999 5 is_stmt 1 view .LVU650
1000:quantum/action.c **** 
 2340              		.loc 1 1000 1 is_stmt 0 view .LVU651
 2341 000c 03B0     		add	sp, sp, #12
 2342              		.cfi_def_cfa_offset 4
 2343              		@ sp needed
 2344 000e 5DF804EB 		ldr	lr, [sp], #4
 2345              		.cfi_restore 14
 2346              		.cfi_def_cfa_offset 0
 999:quantum/action.c **** }
 2347              		.loc 1 999 12 view .LVU652
 2348 0012 FFF7FEBF 		b	is_tap_action
 2349              	.LVL234:
 2350              		.cfi_endproc
 2351              	.LFE311:
 2353              		.section	.text.is_tap_record,"ax",%progbits
 2354              		.align	1
 2355              		.global	is_tap_record
 2356              		.syntax unified
 2357              		.thumb
 2358              		.thumb_func
 2360              	is_tap_record:
 2361              	.LVL235:
 2362              	.LFB312:
1006:quantum/action.c **** #ifdef COMBO_ENABLE
 2363              		.loc 1 1006 41 is_stmt 1 view -0
 2364              		.cfi_startproc
 2365              		@ args = 0, pretend = 0, frame = 0
 2366              		@ frame_needed = 0, uses_anonymous_args = 0
1015:quantum/action.c **** #endif
 2367              		.loc 1 1015 5 view .LVU654
1006:quantum/action.c **** #ifdef COMBO_ENABLE
 2368              		.loc 1 1006 41 is_stmt 0 view .LVU655
 2369 0000 08B5     		push	{r3, lr}
 2370              		.cfi_def_cfa_offset 8
 2371              		.cfi_offset 3, -8
 2372              		.cfi_offset 14, -4
1015:quantum/action.c **** #endif
 2373              		.loc 1 1015 23 view .LVU656
 2374 0002 0088     		ldrh	r0, [r0]
 2375              	.LVL236:
1015:quantum/action.c **** #endif
 2376              		.loc 1 1015 23 view .LVU657
 2377 0004 FFF7FEFF 		bl	layer_switch_get_action
 2378              	.LVL237:
1017:quantum/action.c **** }
 2379              		.loc 1 1017 5 is_stmt 1 view .LVU658
1018:quantum/action.c **** 
 2380              		.loc 1 1018 1 is_stmt 0 view .LVU659
 2381 0008 BDE80840 		pop	{r3, lr}
 2382              		.cfi_restore 14
 2383              		.cfi_restore 3
 2384              		.cfi_def_cfa_offset 0
1017:quantum/action.c **** }
 2385              		.loc 1 1017 12 view .LVU660
 2386 000c FFF7FEBF 		b	is_tap_action
 2387              	.LVL238:
 2388              		.cfi_endproc
 2389              	.LFE312:
 2391              		.section	.text.debug_event,"ax",%progbits
 2392              		.align	1
 2393              		.global	debug_event
 2394              		.syntax unified
 2395              		.thumb
 2396              		.thumb_func
 2398              	debug_event:
 2399              	.LFB314:
1053:quantum/action.c **** 
1054:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1055:quantum/action.c ****  *
1056:quantum/action.c ****  * FIXME: Needs documentation.
1057:quantum/action.c ****  */
1058:quantum/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2400              		.loc 1 1058 36 is_stmt 1 view -0
 2401              		.cfi_startproc
 2402              		@ args = 0, pretend = 0, frame = 8
 2403              		@ frame_needed = 0, uses_anonymous_args = 0
 2404              		@ link register save eliminated.
 2405              		.loc 1 1058 138 view .LVU662
 2406              		.loc 1 1058 36 is_stmt 0 view .LVU663
 2407 0000 82B0     		sub	sp, sp, #8
 2408              		.cfi_def_cfa_offset 8
 2409              		.loc 1 1058 36 view .LVU664
 2410 0002 02AB     		add	r3, sp, #8
 2411 0004 03E90300 		stmdb	r3, {r0, r1}
 2412              		.loc 1 1058 140 view .LVU665
 2413 0008 02B0     		add	sp, sp, #8
 2414              		.cfi_def_cfa_offset 0
 2415              		@ sp needed
 2416 000a 7047     		bx	lr
 2417              		.cfi_endproc
 2418              	.LFE314:
 2420              		.section	.text.debug_record,"ax",%progbits
 2421              		.align	1
 2422              		.global	debug_record
 2423              		.syntax unified
 2424              		.thumb
 2425              		.thumb_func
 2427              	debug_record:
 2428              	.LFB315:
1059:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1060:quantum/action.c ****  *
1061:quantum/action.c ****  * FIXME: Needs documentation.
1062:quantum/action.c ****  */
1063:quantum/action.c **** void debug_record(keyrecord_t record) {
 2429              		.loc 1 1063 39 is_stmt 1 view -0
 2430              		.cfi_startproc
 2431              		@ args = 0, pretend = 0, frame = 8
 2432              		@ frame_needed = 0, uses_anonymous_args = 0
 2433              		@ link register save eliminated.
1064:quantum/action.c ****     debug_event(record.event);
 2434              		.loc 1 1064 5 view .LVU667
1065:quantum/action.c **** #ifndef NO_ACTION_TAPPING
1066:quantum/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2435              		.loc 1 1066 77 view .LVU668
1063:quantum/action.c ****     debug_event(record.event);
 2436              		.loc 1 1063 39 is_stmt 0 view .LVU669
 2437 0000 82B0     		sub	sp, sp, #8
 2438              		.cfi_def_cfa_offset 8
1063:quantum/action.c ****     debug_event(record.event);
 2439              		.loc 1 1063 39 view .LVU670
 2440 0002 02AB     		add	r3, sp, #8
 2441 0004 03E90300 		stmdb	r3, {r0, r1}
1067:quantum/action.c **** #endif
1068:quantum/action.c **** }
 2442              		.loc 1 1068 1 view .LVU671
 2443 0008 02B0     		add	sp, sp, #8
 2444              		.cfi_def_cfa_offset 0
 2445              		@ sp needed
 2446 000a 7047     		bx	lr
 2447              		.cfi_endproc
 2448              	.LFE315:
 2450              		.section	.text.debug_action,"ax",%progbits
 2451              		.align	1
 2452              		.global	debug_action
 2453              		.syntax unified
 2454              		.thumb
 2455              		.thumb_func
 2457              	debug_action:
 2458              	.LVL239:
 2459              	.LFB316:
1069:quantum/action.c **** 
1070:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1071:quantum/action.c ****  *
1072:quantum/action.c ****  * FIXME: Needs documentation.
1073:quantum/action.c ****  */
1074:quantum/action.c **** void debug_action(action_t action) {
 2460              		.loc 1 1074 36 is_stmt 1 view -0
 2461              		.cfi_startproc
 2462              		@ args = 0, pretend = 0, frame = 0
 2463              		@ frame_needed = 0, uses_anonymous_args = 0
 2464              		@ link register save eliminated.
1075:quantum/action.c ****     switch (action.kind.id) {
 2465              		.loc 1 1075 5 view .LVU673
1076:quantum/action.c ****         case ACT_LMODS:
1077:quantum/action.c ****             dprint("ACT_LMODS");
1078:quantum/action.c ****             break;
1079:quantum/action.c ****         case ACT_RMODS:
1080:quantum/action.c ****             dprint("ACT_RMODS");
1081:quantum/action.c ****             break;
1082:quantum/action.c ****         case ACT_LMODS_TAP:
1083:quantum/action.c ****             dprint("ACT_LMODS_TAP");
1084:quantum/action.c ****             break;
1085:quantum/action.c ****         case ACT_RMODS_TAP:
1086:quantum/action.c ****             dprint("ACT_RMODS_TAP");
1087:quantum/action.c ****             break;
1088:quantum/action.c ****         case ACT_USAGE:
1089:quantum/action.c ****             dprint("ACT_USAGE");
1090:quantum/action.c ****             break;
1091:quantum/action.c ****         case ACT_MOUSEKEY:
1092:quantum/action.c ****             dprint("ACT_MOUSEKEY");
1093:quantum/action.c ****             break;
1094:quantum/action.c ****         case ACT_LAYER:
1095:quantum/action.c ****             dprint("ACT_LAYER");
1096:quantum/action.c ****             break;
1097:quantum/action.c ****         case ACT_LAYER_MODS:
1098:quantum/action.c ****             dprint("ACT_LAYER_MODS");
1099:quantum/action.c ****             break;
1100:quantum/action.c ****         case ACT_LAYER_TAP:
1101:quantum/action.c ****             dprint("ACT_LAYER_TAP");
1102:quantum/action.c ****             break;
1103:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
1104:quantum/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1105:quantum/action.c ****             break;
1106:quantum/action.c ****         case ACT_MACRO:
1107:quantum/action.c ****             dprint("ACT_MACRO");
1108:quantum/action.c ****             break;
1109:quantum/action.c ****         case ACT_FUNCTION:
1110:quantum/action.c ****             dprint("ACT_FUNCTION");
1111:quantum/action.c ****             break;
1112:quantum/action.c ****         case ACT_SWAP_HANDS:
1113:quantum/action.c ****             dprint("ACT_SWAP_HANDS");
1114:quantum/action.c ****             break;
1115:quantum/action.c ****         default:
1116:quantum/action.c ****             dprint("UNKNOWN");
1117:quantum/action.c ****             break;
1118:quantum/action.c ****     }
1119:quantum/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2466              		.loc 1 1119 75 view .LVU674
1120:quantum/action.c **** }
 2467              		.loc 1 1120 1 is_stmt 0 view .LVU675
 2468 0000 7047     		bx	lr
 2469              		.cfi_endproc
 2470              	.LFE316:
 2472              		.section	.rodata.CSWTCH.14,"a"
 2473              		.align	1
 2476              	CSWTCH.14:
 2477 0000 E200     		.short	226
 2478 0002 E900     		.short	233
 2479 0004 EA00     		.short	234
 2480 0006 B500     		.short	181
 2481 0008 B600     		.short	182
 2482 000a B700     		.short	183
 2483 000c CD00     		.short	205
 2484 000e 8301     		.short	387
 2485 0010 CC00     		.short	204
 2486 0012 8A01     		.short	394
 2487 0014 9201     		.short	402
 2488 0016 9401     		.short	404
 2489 0018 2102     		.short	545
 2490 001a 2302     		.short	547
 2491 001c 2402     		.short	548
 2492 001e 2502     		.short	549
 2493 0020 2602     		.short	550
 2494 0022 2702     		.short	551
 2495 0024 2A02     		.short	554
 2496 0026 B300     		.short	179
 2497 0028 B400     		.short	180
 2498 002a 6F00     		.short	111
 2499 002c 7000     		.short	112
 2500              		.global	disable_action_cache
 2501              		.section	.bss.disable_action_cache,"aw",%nobits
 2504              	disable_action_cache:
 2505 0000 00       		.space	1
 2506              		.comm	tp_buttons,4,4
 2507              		.text
 2508              	.Letext0:
 2509              		.file 4 "/usr/arm-none-eabi/include/machine/_default_types.h"
 2510              		.file 5 "/usr/arm-none-eabi/include/sys/_stdint.h"
 2511              		.file 6 "quantum/keycode.h"
 2512              		.file 7 "./lib/chibios/os/rt/include/chtime.h"
 2513              		.file 8 "quantum/action_code.h"
 2514              		.file 9 "quantum/action_macro.h"
 2515              		.file 10 "quantum/action.h"
 2516              		.file 11 "quantum/action_layer.h"
 2517              		.file 12 "quantum/action_util.h"
 2518              		.file 13 "quantum/mousekey.h"
 2519              		.file 14 "quantum/command.h"
 2520              		.file 15 "quantum/led.h"
 2521              		.file 16 "tmk_core/common/host.h"
 2522              		.file 17 "./lib/chibios/os/rt/include/chthreads.h"
 2523              		.file 18 "quantum/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/ccXCY227.s:21     .text.pre_process_record_quantum:0000000000000000 $t
     /tmp/ccXCY227.s:27     .text.pre_process_record_quantum:0000000000000000 pre_process_record_quantum
     /tmp/ccXCY227.s:40     .text.action_exec:0000000000000000 $t
     /tmp/ccXCY227.s:46     .text.action_exec:0000000000000000 action_exec
     /tmp/ccXCY227.s:134    .text.process_record_quantum:0000000000000000 $t
     /tmp/ccXCY227.s:140    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccXCY227.s:158    .text.post_process_record_quantum:0000000000000000 $t
     /tmp/ccXCY227.s:164    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
     /tmp/ccXCY227.s:178    .text.process_record_tap_hint:0000000000000000 $t
     /tmp/ccXCY227.s:184    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/ccXCY227.s:203    .text.register_code:0000000000000000 $t
     /tmp/ccXCY227.s:209    .text.register_code:0000000000000000 register_code
     /tmp/ccXCY227.s:496    .text.register_code:0000000000000100 $d
     /tmp/ccXCY227.s:2476   .rodata.CSWTCH.14:0000000000000000 CSWTCH.14
     /tmp/ccXCY227.s:502    .text.unregister_code:0000000000000000 $t
     /tmp/ccXCY227.s:508    .text.unregister_code:0000000000000000 unregister_code
     /tmp/ccXCY227.s:727    .text.tap_code_delay:0000000000000000 $t
     /tmp/ccXCY227.s:733    .text.tap_code_delay:0000000000000000 tap_code_delay
     /tmp/ccXCY227.s:800    .text.tap_code:0000000000000000 $t
     /tmp/ccXCY227.s:806    .text.tap_code:0000000000000000 tap_code
     /tmp/ccXCY227.s:826    .text.register_mods:0000000000000000 $t
     /tmp/ccXCY227.s:832    .text.register_mods:0000000000000000 register_mods
     /tmp/ccXCY227.s:879    .text.unregister_mods:0000000000000000 $t
     /tmp/ccXCY227.s:885    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/ccXCY227.s:932    .text.process_action:0000000000000000 $t
     /tmp/ccXCY227.s:938    .text.process_action:0000000000000000 process_action
     /tmp/ccXCY227.s:1015   .text.process_action:000000000000004c $d
     /tmp/ccXCY227.s:1032   .text.process_action:000000000000006c $t
     /tmp/ccXCY227.s:1872   .text.process_record:0000000000000000 process_record
     /tmp/ccXCY227.s:1624   .text.process_action:00000000000002c2 $d
     /tmp/ccXCY227.s:1802   .text.process_record_handler:0000000000000000 $t
     /tmp/ccXCY227.s:1808   .text.process_record_handler:0000000000000000 process_record_handler
     /tmp/ccXCY227.s:1866   .text.process_record:0000000000000000 $t
     /tmp/ccXCY227.s:1975   .text.process_record_nocache:0000000000000000 $t
     /tmp/ccXCY227.s:1981   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/ccXCY227.s:2010   .text.process_record_nocache:0000000000000014 $d
     /tmp/ccXCY227.s:2504   .bss.disable_action_cache:0000000000000000 disable_action_cache
     /tmp/ccXCY227.s:2015   .text.register_weak_mods:0000000000000000 $t
     /tmp/ccXCY227.s:2021   .text.register_weak_mods:0000000000000000 register_weak_mods
     /tmp/ccXCY227.s:2057   .text.unregister_weak_mods:0000000000000000 $t
     /tmp/ccXCY227.s:2063   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
     /tmp/ccXCY227.s:2099   .text.clear_keyboard_but_mods_and_keys:0000000000000000 $t
     /tmp/ccXCY227.s:2105   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
     /tmp/ccXCY227.s:2150   .text.clear_keyboard_but_mods:0000000000000000 $t
     /tmp/ccXCY227.s:2156   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/ccXCY227.s:2184   .text.clear_keyboard:0000000000000000 $t
     /tmp/ccXCY227.s:2190   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/ccXCY227.s:2218   .text.is_tap_action:0000000000000000 $t
     /tmp/ccXCY227.s:2224   .text.is_tap_action:0000000000000000 is_tap_action
     /tmp/ccXCY227.s:2242   .text.is_tap_action:0000000000000010 $d
     /tmp/ccXCY227.s:2256   .text.is_tap_action:000000000000001e $t
     /tmp/ccXCY227.s:2316   .text.is_tap_key:0000000000000000 $t
     /tmp/ccXCY227.s:2322   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/ccXCY227.s:2354   .text.is_tap_record:0000000000000000 $t
     /tmp/ccXCY227.s:2360   .text.is_tap_record:0000000000000000 is_tap_record
     /tmp/ccXCY227.s:2392   .text.debug_event:0000000000000000 $t
     /tmp/ccXCY227.s:2398   .text.debug_event:0000000000000000 debug_event
     /tmp/ccXCY227.s:2421   .text.debug_record:0000000000000000 $t
     /tmp/ccXCY227.s:2427   .text.debug_record:0000000000000000 debug_record
     /tmp/ccXCY227.s:2451   .text.debug_action:0000000000000000 $t
     /tmp/ccXCY227.s:2457   .text.debug_action:0000000000000000 debug_action
     /tmp/ccXCY227.s:2473   .rodata.CSWTCH.14:0000000000000000 $d
     /tmp/ccXCY227.s:2505   .bss.disable_action_cache:0000000000000000 $d
                            *COM*:0000000000000004 tp_buttons
     /tmp/ccXCY227.s:1629   .text.process_action:00000000000002c7 $d
     /tmp/ccXCY227.s:1629   .text.process_action:00000000000002c8 $t

UNDEFINED SYMBOLS
clear_weak_mods
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
chThdSleep
del_key
command_proc
is_key_pressed
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
keyboard_report
del_mods
mousekey_off
is_oneshot_layer_active
clear_oneshot_layer_state
add_weak_mods
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
led_set
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
