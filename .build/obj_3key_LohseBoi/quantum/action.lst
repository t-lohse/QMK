   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.process_record_quantum,"ax",@progbits
  11               		.weak	process_record_quantum
  13               	process_record_quantum:
  14               	.LVL0:
  15               	.LFB111:
  16               		.file 1 "quantum/action.c"
   1:quantum/action.c **** /*
   2:quantum/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:quantum/action.c **** 
   4:quantum/action.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/action.c **** it under the terms of the GNU General Public License as published by
   6:quantum/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/action.c **** (at your option) any later version.
   8:quantum/action.c **** 
   9:quantum/action.c **** This program is distributed in the hope that it will be useful,
  10:quantum/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/action.c **** GNU General Public License for more details.
  13:quantum/action.c **** 
  14:quantum/action.c **** You should have received a copy of the GNU General Public License
  15:quantum/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/action.c **** */
  17:quantum/action.c **** #include "host.h"
  18:quantum/action.c **** #include "keycode.h"
  19:quantum/action.c **** #include "keyboard.h"
  20:quantum/action.c **** #include "mousekey.h"
  21:quantum/action.c **** #include "command.h"
  22:quantum/action.c **** #include "led.h"
  23:quantum/action.c **** #include "action_layer.h"
  24:quantum/action.c **** #include "action_tapping.h"
  25:quantum/action.c **** #include "action_macro.h"
  26:quantum/action.c **** #include "action_util.h"
  27:quantum/action.c **** #include "action.h"
  28:quantum/action.c **** #include "wait.h"
  29:quantum/action.c **** 
  30:quantum/action.c **** #ifdef BACKLIGHT_ENABLE
  31:quantum/action.c **** #    include "backlight.h"
  32:quantum/action.c **** #endif
  33:quantum/action.c **** 
  34:quantum/action.c **** #ifdef DEBUG_ACTION
  35:quantum/action.c **** #    include "debug.h"
  36:quantum/action.c **** #else
  37:quantum/action.c **** #    include "nodebug.h"
  38:quantum/action.c **** #endif
  39:quantum/action.c **** 
  40:quantum/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:quantum/action.c **** #    include "pointing_device.h"
  42:quantum/action.c **** #endif
  43:quantum/action.c **** 
  44:quantum/action.c **** int tp_buttons;
  45:quantum/action.c **** 
  46:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:quantum/action.c **** int retro_tapping_counter = 0;
  48:quantum/action.c **** #endif
  49:quantum/action.c **** 
  50:quantum/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:quantum/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:quantum/action.c **** #endif
  53:quantum/action.c **** 
  54:quantum/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  55:quantum/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  56:quantum/action.c **** #endif
  57:quantum/action.c **** 
  58:quantum/action.c **** __attribute__((weak)) bool pre_process_record_quantum(keyrecord_t *record) { return true; }
  59:quantum/action.c **** 
  60:quantum/action.c **** /** \brief Called to execute an action.
  61:quantum/action.c ****  *
  62:quantum/action.c ****  * FIXME: Needs documentation.
  63:quantum/action.c ****  */
  64:quantum/action.c **** void action_exec(keyevent_t event) {
  65:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  66:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:quantum/action.c ****         dprint("EVENT: ");
  68:quantum/action.c ****         debug_event(event);
  69:quantum/action.c ****         dprintln();
  70:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  71:quantum/action.c ****         retro_tapping_counter++;
  72:quantum/action.c **** #endif
  73:quantum/action.c ****     }
  74:quantum/action.c **** 
  75:quantum/action.c ****     if (event.pressed) {
  76:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
  77:quantum/action.c ****         clear_weak_mods();
  78:quantum/action.c ****     }
  79:quantum/action.c **** 
  80:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
  81:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  82:quantum/action.c ****         process_hand_swap(&event);
  83:quantum/action.c ****     }
  84:quantum/action.c **** #endif
  85:quantum/action.c **** 
  86:quantum/action.c ****     keyrecord_t record = {.event = event};
  87:quantum/action.c **** 
  88:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
  89:quantum/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  90:quantum/action.c ****     if (has_oneshot_layer_timed_out()) {
  91:quantum/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  92:quantum/action.c ****     }
  93:quantum/action.c ****     if (has_oneshot_mods_timed_out()) {
  94:quantum/action.c ****         clear_oneshot_mods();
  95:quantum/action.c ****     }
  96:quantum/action.c **** #        ifdef SWAP_HANDS_ENABLE
  97:quantum/action.c ****     if (has_oneshot_swaphands_timed_out()) {
  98:quantum/action.c ****         clear_oneshot_swaphands();
  99:quantum/action.c ****     }
 100:quantum/action.c **** #        endif
 101:quantum/action.c **** #    endif
 102:quantum/action.c **** #endif
 103:quantum/action.c **** 
 104:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 105:quantum/action.c ****     if (IS_NOEVENT(record.event) || pre_process_record_quantum(&record)) {
 106:quantum/action.c ****         action_tapping_process(record);
 107:quantum/action.c ****     }
 108:quantum/action.c **** #else
 109:quantum/action.c ****     if (IS_NOEVENT(record.event) || pre_process_record_quantum(&record)) {
 110:quantum/action.c ****         process_record(&record);
 111:quantum/action.c ****     }
 112:quantum/action.c ****     if (!IS_NOEVENT(record.event)) {
 113:quantum/action.c ****         dprint("processed: ");
 114:quantum/action.c ****         debug_record(record);
 115:quantum/action.c ****         dprintln();
 116:quantum/action.c ****     }
 117:quantum/action.c **** #endif
 118:quantum/action.c **** }
 119:quantum/action.c **** 
 120:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 121:quantum/action.c **** bool swap_hands = false;
 122:quantum/action.c **** bool swap_held  = false;
 123:quantum/action.c **** 
 124:quantum/action.c **** /** \brief Process Hand Swap
 125:quantum/action.c ****  *
 126:quantum/action.c ****  * FIXME: Needs documentation.
 127:quantum/action.c ****  */
 128:quantum/action.c **** void process_hand_swap(keyevent_t *event) {
 129:quantum/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 130:quantum/action.c **** 
 131:quantum/action.c ****     keypos_t         pos     = event->key;
 132:quantum/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 133:quantum/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 134:quantum/action.c **** 
 135:quantum/action.c ****     if (do_swap) {
 136:quantum/action.c ****         event->key.row = pgm_read_byte(&hand_swap_config[pos.row][pos.col].row);
 137:quantum/action.c ****         event->key.col = pgm_read_byte(&hand_swap_config[pos.row][pos.col].col);
 138:quantum/action.c ****         swap_state[pos.row] |= col_bit;
 139:quantum/action.c ****     } else {
 140:quantum/action.c ****         swap_state[pos.row] &= ~(col_bit);
 141:quantum/action.c ****     }
 142:quantum/action.c **** }
 143:quantum/action.c **** #endif
 144:quantum/action.c **** 
 145:quantum/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:quantum/action.c **** bool disable_action_cache = false;
 147:quantum/action.c **** 
 148:quantum/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:quantum/action.c ****     disable_action_cache = true;
 150:quantum/action.c ****     process_record(record);
 151:quantum/action.c ****     disable_action_cache = false;
 152:quantum/action.c **** }
 153:quantum/action.c **** #else
 154:quantum/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:quantum/action.c **** #endif
 156:quantum/action.c **** 
 157:quantum/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  17               		.loc 1 157 72 view -0
  18               		.cfi_startproc
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  23               		.loc 1 157 74 view .LVU1
  24               		.loc 1 157 87 is_stmt 0 view .LVU2
  25 0000 81E0      		ldi r24,lo8(1)
  26               	.LVL1:
  27               	/* epilogue start */
  28               		.loc 1 157 87 view .LVU3
  29 0002 0895      		ret
  30               		.cfi_endproc
  31               	.LFE111:
  33               		.set	process_record_quantum.localalias,process_record_quantum
  34               		.section	.text.pre_process_record_quantum,"ax",@progbits
  35               		.weak	pre_process_record_quantum
  37               	pre_process_record_quantum:
  38               	.LFB135:
  39               		.cfi_startproc
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 0 */
  43               	.L__stack_usage = 0
  44 0000 0C94 0000 		jmp process_record_quantum.localalias
  45               		.cfi_endproc
  46               	.LFE135:
  48               		.section	.text.action_exec,"ax",@progbits
  49               	.global	action_exec
  51               	action_exec:
  52               	.LFB109:
  64:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  53               		.loc 1 64 36 is_stmt 1 view -0
  54               		.cfi_startproc
  55 0000 EF92      		push r14
  56               	.LCFI0:
  57               		.cfi_def_cfa_offset 3
  58               		.cfi_offset 14, -2
  59 0002 FF92      		push r15
  60               	.LCFI1:
  61               		.cfi_def_cfa_offset 4
  62               		.cfi_offset 15, -3
  63 0004 0F93      		push r16
  64               	.LCFI2:
  65               		.cfi_def_cfa_offset 5
  66               		.cfi_offset 16, -4
  67 0006 1F93      		push r17
  68               	.LCFI3:
  69               		.cfi_def_cfa_offset 6
  70               		.cfi_offset 17, -5
  71 0008 CF93      		push r28
  72               	.LCFI4:
  73               		.cfi_def_cfa_offset 7
  74               		.cfi_offset 28, -6
  75 000a DF93      		push r29
  76               	.LCFI5:
  77               		.cfi_def_cfa_offset 8
  78               		.cfi_offset 29, -7
  79 000c CDB7      		in r28,__SP_L__
  80 000e DEB7      		in r29,__SP_H__
  81               	.LCFI6:
  82               		.cfi_def_cfa_register 28
  83 0010 2B97      		sbiw r28,11
  84               	.LCFI7:
  85               		.cfi_def_cfa_offset 19
  86 0012 0FB6      		in __tmp_reg__,__SREG__
  87 0014 F894      		cli
  88 0016 DEBF      		out __SP_H__,r29
  89 0018 0FBE      		out __SREG__,__tmp_reg__
  90 001a CDBF      		out __SP_L__,r28
  91               	/* prologue: function */
  92               	/* frame size = 11 */
  93               	/* stack size = 17 */
  94               	.L__stack_usage = 17
  95 001c 042F      		mov r16,r20
  96 001e 4F83      		std Y+7,r20
  97 0020 152F      		mov r17,r21
  98 0022 5887      		std Y+8,r21
  99 0024 6987      		std Y+9,r22
 100 0026 7A87      		std Y+10,r23
 101 0028 8B87      		std Y+11,r24
 102               	.LVL2:
  65:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
 103               		.loc 1 65 5 view .LVU5
  65:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
 104               		.loc 1 65 5 is_stmt 0 view .LVU6
 105 002a EA84      		ldd r14,Y+10
 106 002c FB84      		ldd r15,Y+11
 107               	.LVL3:
 108               	.LBB29:
 109               	.LBI29:
 110               		.file 2 "quantum/keyboard.h"
   1:quantum/keyboard.h **** /*
   2:quantum/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:quantum/keyboard.h **** 
   4:quantum/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:quantum/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:quantum/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/keyboard.h **** (at your option) any later version.
   8:quantum/keyboard.h **** 
   9:quantum/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:quantum/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/keyboard.h **** GNU General Public License for more details.
  13:quantum/keyboard.h **** 
  14:quantum/keyboard.h **** You should have received a copy of the GNU General Public License
  15:quantum/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/keyboard.h **** */
  17:quantum/keyboard.h **** 
  18:quantum/keyboard.h **** #pragma once
  19:quantum/keyboard.h **** 
  20:quantum/keyboard.h **** #include <stdbool.h>
  21:quantum/keyboard.h **** #include <stdint.h>
  22:quantum/keyboard.h **** 
  23:quantum/keyboard.h **** #ifdef __cplusplus
  24:quantum/keyboard.h **** extern "C" {
  25:quantum/keyboard.h **** #endif
  26:quantum/keyboard.h **** 
  27:quantum/keyboard.h **** /* key matrix position */
  28:quantum/keyboard.h **** typedef struct {
  29:quantum/keyboard.h ****     uint8_t col;
  30:quantum/keyboard.h ****     uint8_t row;
  31:quantum/keyboard.h **** } keypos_t;
  32:quantum/keyboard.h **** 
  33:quantum/keyboard.h **** /* key event */
  34:quantum/keyboard.h **** typedef struct {
  35:quantum/keyboard.h ****     keypos_t key;
  36:quantum/keyboard.h ****     bool     pressed;
  37:quantum/keyboard.h ****     uint16_t time;
  38:quantum/keyboard.h **** } keyevent_t;
  39:quantum/keyboard.h **** 
  40:quantum/keyboard.h **** /* equivalent test of keypos_t */
  41:quantum/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  42:quantum/keyboard.h **** 
  43:quantum/keyboard.h **** /* Rules for No Event:
  44:quantum/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  45:quantum/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  46:quantum/keyboard.h ****  */
  47:quantum/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 111               		.loc 2 47 20 is_stmt 1 view .LVU7
 112               		.loc 2 47 51 view .LVU8
 113               		.loc 2 47 51 is_stmt 0 view .LVU9
 114               	.LBE29:
  69:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 115               		.loc 1 69 19 is_stmt 1 view .LVU10
  75:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
 116               		.loc 1 75 5 view .LVU11
  75:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
 117               		.loc 1 75 8 is_stmt 0 view .LVU12
 118 002e 6111      		cpse r22,__zero_reg__
  77:quantum/action.c ****     }
 119               		.loc 1 77 9 is_stmt 1 view .LVU13
 120 0030 0E94 0000 		call clear_weak_mods
 121               	.LVL4:
 122               	.L4:
  86:quantum/action.c **** 
 123               		.loc 1 86 5 view .LVU14
  86:quantum/action.c **** 
 124               		.loc 1 86 17 is_stmt 0 view .LVU15
 125 0034 1E82      		std Y+6,__zero_reg__
 126 0036 85E0      		ldi r24,lo8(5)
 127 0038 FE01      		movw r30,r28
 128 003a 3796      		adiw r30,7
 129 003c DE01      		movw r26,r28
 130 003e 1196      		adiw r26,1
 131               		0:
 132 0040 0190      		ld r0,Z+
 133 0042 0D92      		st X+,r0
 134 0044 8A95      		dec r24
 135 0046 01F4      		brne 0b
 105:quantum/action.c ****         action_tapping_process(record);
 136               		.loc 1 105 5 is_stmt 1 view .LVU16
 137               	.LVL5:
 138               	.LBB30:
 139               	.LBI30:
 140               		.loc 2 47 20 view .LVU17
 141               	.LBB31:
 142               		.loc 2 47 51 view .LVU18
 143               		.loc 2 47 74 is_stmt 0 view .LVU19
 144 0048 EF28      		or r14,r15
 145 004a 01F4      		brne .L5
 146               	.LVL6:
 147               	.L7:
 148               		.loc 2 47 74 view .LVU20
 149               	.LBE31:
 150               	.LBE30:
 106:quantum/action.c ****     }
 151               		.loc 1 106 9 is_stmt 1 view .LVU21
 152 004c 4981      		ldd r20,Y+1
 153 004e 5A81      		ldd r21,Y+2
 154 0050 6B81      		ldd r22,Y+3
 155 0052 7C81      		ldd r23,Y+4
 156 0054 8D81      		ldd r24,Y+5
 157 0056 9E81      		ldd r25,Y+6
 158 0058 0E94 0000 		call action_tapping_process
 159               	.LVL7:
 160               	.L3:
 161               	/* epilogue start */
 118:quantum/action.c **** 
 162               		.loc 1 118 1 is_stmt 0 view .LVU22
 163 005c 2B96      		adiw r28,11
 164 005e 0FB6      		in __tmp_reg__,__SREG__
 165 0060 F894      		cli
 166 0062 DEBF      		out __SP_H__,r29
 167 0064 0FBE      		out __SREG__,__tmp_reg__
 168 0066 CDBF      		out __SP_L__,r28
 169 0068 DF91      		pop r29
 170 006a CF91      		pop r28
 171 006c 1F91      		pop r17
 172 006e 0F91      		pop r16
 173 0070 FF90      		pop r15
 174 0072 EF90      		pop r14
 175 0074 0895      		ret
 176               	.LVL8:
 177               	.L5:
 178               	.LBB33:
 179               	.LBB32:
 180               		.loc 2 47 74 view .LVU23
 181 0076 1023      		and r17,r16
 182               	.LVL9:
 183               		.loc 2 47 74 view .LVU24
 184 0078 1F3F      		cpi r17,lo8(-1)
 185 007a 01F0      		breq .L7
 186               	.LVL10:
 187               		.loc 2 47 74 view .LVU25
 188               	.LBE32:
 189               	.LBE33:
 105:quantum/action.c ****         action_tapping_process(record);
 190               		.loc 1 105 37 view .LVU26
 191 007c CE01      		movw r24,r28
 192 007e 0196      		adiw r24,1
 193 0080 0E94 0000 		call pre_process_record_quantum
 194               	.LVL11:
 105:quantum/action.c ****         action_tapping_process(record);
 195               		.loc 1 105 34 view .LVU27
 196 0084 8111      		cpse r24,__zero_reg__
 197 0086 00C0      		rjmp .L7
 198 0088 00C0      		rjmp .L3
 199               		.cfi_endproc
 200               	.LFE109:
 202               		.section	.text.post_process_record_quantum,"ax",@progbits
 203               		.weak	post_process_record_quantum
 205               	post_process_record_quantum:
 206               	.LVL12:
 207               	.LFB112:
 158:quantum/action.c **** 
 159:quantum/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 208               		.loc 1 159 77 is_stmt 1 view -0
 209               		.cfi_startproc
 210               	/* prologue: function */
 211               	/* frame size = 0 */
 212               	/* stack size = 0 */
 213               	.L__stack_usage = 0
 214               		.loc 1 159 78 view .LVU29
 215               	/* epilogue start */
 216 0000 0895      		ret
 217               		.cfi_endproc
 218               	.LFE112:
 220               		.section	.text.process_record_tap_hint,"ax",@progbits
 221               	.global	process_record_tap_hint
 223               	process_record_tap_hint:
 224               	.LVL13:
 225               	.LFB113:
 160:quantum/action.c **** 
 161:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 162:quantum/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:quantum/action.c ****  *
 164:quantum/action.c ****  * FIXME: Needs documentation.
 165:quantum/action.c ****  */
 166:quantum/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 226               		.loc 1 166 51 view -0
 227               		.cfi_startproc
 228               	/* prologue: function */
 229               	/* frame size = 0 */
 230               	/* stack size = 0 */
 231               	.L__stack_usage = 0
 167:quantum/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 232               		.loc 1 167 5 view .LVU31
 233               		.loc 1 167 23 is_stmt 0 view .LVU32
 234 0000 FC01      		movw r30,r24
 235 0002 8081      		ld r24,Z
 236 0004 9181      		ldd r25,Z+1
 237               	.LVL14:
 238               		.loc 1 167 23 view .LVU33
 239 0006 0C94 0000 		jmp layer_switch_get_action
 240               	.LVL15:
 241               		.loc 1 167 23 view .LVU34
 242               		.cfi_endproc
 243               	.LFE113:
 245               		.section	.text.register_code,"ax",@progbits
 246               	.global	register_code
 248               	register_code:
 249               	.LVL16:
 250               	.LFB117:
 168:quantum/action.c **** 
 169:quantum/action.c ****     switch (action.kind.id) {
 170:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:quantum/action.c ****         case ACT_SWAP_HANDS:
 172:quantum/action.c ****             switch (action.swap.code) {
 173:quantum/action.c ****                 case OP_SH_ONESHOT:
 174:quantum/action.c ****                     break;
 175:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:quantum/action.c ****                 default:
 177:quantum/action.c ****                     swap_hands = !swap_hands;
 178:quantum/action.c ****                     swap_held  = true;
 179:quantum/action.c ****             }
 180:quantum/action.c ****             break;
 181:quantum/action.c **** #    endif
 182:quantum/action.c ****     }
 183:quantum/action.c **** }
 184:quantum/action.c **** #endif
 185:quantum/action.c **** 
 186:quantum/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:quantum/action.c ****  *
 188:quantum/action.c ****  * FIXME: Needs documentation.
 189:quantum/action.c ****  */
 190:quantum/action.c **** void process_record(keyrecord_t *record) {
 191:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 192:quantum/action.c ****         return;
 193:quantum/action.c ****     }
 194:quantum/action.c **** 
 195:quantum/action.c ****     if (!process_record_quantum(record)) {
 196:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 197:quantum/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:quantum/action.c ****         }
 200:quantum/action.c **** #endif
 201:quantum/action.c ****         return;
 202:quantum/action.c ****     }
 203:quantum/action.c **** 
 204:quantum/action.c ****     process_record_handler(record);
 205:quantum/action.c ****     post_process_record_quantum(record);
 206:quantum/action.c **** }
 207:quantum/action.c **** 
 208:quantum/action.c **** void process_record_handler(keyrecord_t *record) {
 209:quantum/action.c **** #ifdef COMBO_ENABLE
 210:quantum/action.c ****     action_t action;
 211:quantum/action.c ****     if (record->keycode) {
 212:quantum/action.c ****         action = action_for_keycode(record->keycode);
 213:quantum/action.c ****     } else {
 214:quantum/action.c ****         action = store_or_get_action(record->event.pressed, record->event.key);
 215:quantum/action.c ****     }
 216:quantum/action.c **** #else
 217:quantum/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 218:quantum/action.c **** #endif
 219:quantum/action.c ****     dprint("ACTION: ");
 220:quantum/action.c ****     debug_action(action);
 221:quantum/action.c **** #ifndef NO_ACTION_LAYER
 222:quantum/action.c ****     dprint(" layer_state: ");
 223:quantum/action.c ****     layer_debug();
 224:quantum/action.c ****     dprint(" default_layer_state: ");
 225:quantum/action.c ****     default_layer_debug();
 226:quantum/action.c **** #endif
 227:quantum/action.c ****     dprintln();
 228:quantum/action.c **** 
 229:quantum/action.c ****     process_action(record, action);
 230:quantum/action.c **** }
 231:quantum/action.c **** 
 232:quantum/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 233:quantum/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 234:quantum/action.c **** #    ifdef PS2_MOUSE_ENABLE
 235:quantum/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 236:quantum/action.c **** #    endif
 237:quantum/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 238:quantum/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 239:quantum/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 240:quantum/action.c ****     pointing_device_set_report(currentReport);
 241:quantum/action.c **** #    endif
 242:quantum/action.c **** }
 243:quantum/action.c **** #endif
 244:quantum/action.c **** 
 245:quantum/action.c **** /** \brief Take an action and processes it.
 246:quantum/action.c ****  *
 247:quantum/action.c ****  * FIXME: Needs documentation.
 248:quantum/action.c ****  */
 249:quantum/action.c **** void process_action(keyrecord_t *record, action_t action) {
 250:quantum/action.c ****     keyevent_t event = record->event;
 251:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 252:quantum/action.c ****     uint8_t tap_count = record->tap.count;
 253:quantum/action.c **** #endif
 254:quantum/action.c **** 
 255:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 256:quantum/action.c ****     bool do_release_oneshot = false;
 257:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 258:quantum/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 259:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 260:quantum/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 261:quantum/action.c **** #    endif
 262:quantum/action.c ****     ) {
 263:quantum/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 264:quantum/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 265:quantum/action.c ****     }
 266:quantum/action.c **** #endif
 267:quantum/action.c **** 
 268:quantum/action.c ****     switch (action.kind.id) {
 269:quantum/action.c ****         /* Key and Mods */
 270:quantum/action.c ****         case ACT_LMODS:
 271:quantum/action.c ****         case ACT_RMODS: {
 272:quantum/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 273:quantum/action.c ****             if (event.pressed) {
 274:quantum/action.c ****                 if (mods) {
 275:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 276:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 277:quantum/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 278:quantum/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 279:quantum/action.c ****                         add_mods(mods);
 280:quantum/action.c ****                     } else {
 281:quantum/action.c ****                         add_weak_mods(mods);
 282:quantum/action.c ****                     }
 283:quantum/action.c ****                     send_keyboard_report();
 284:quantum/action.c ****                 }
 285:quantum/action.c ****                 register_code(action.key.code);
 286:quantum/action.c ****             } else {
 287:quantum/action.c ****                 unregister_code(action.key.code);
 288:quantum/action.c ****                 if (mods) {
 289:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 290:quantum/action.c ****                         del_mods(mods);
 291:quantum/action.c ****                     } else {
 292:quantum/action.c ****                         del_weak_mods(mods);
 293:quantum/action.c ****                     }
 294:quantum/action.c ****                     send_keyboard_report();
 295:quantum/action.c ****                 }
 296:quantum/action.c ****             }
 297:quantum/action.c ****         } break;
 298:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 299:quantum/action.c ****         case ACT_LMODS_TAP:
 300:quantum/action.c ****         case ACT_RMODS_TAP: {
 301:quantum/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 302:quantum/action.c ****             switch (action.layer_tap.code) {
 303:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 304:quantum/action.c ****                 case MODS_ONESHOT:
 305:quantum/action.c ****                     // Oneshot modifier
 306:quantum/action.c ****                     if (event.pressed) {
 307:quantum/action.c ****                         if (tap_count == 0) {
 308:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 309:quantum/action.c ****                             register_mods(mods | get_oneshot_mods());
 310:quantum/action.c ****                         } else if (tap_count == 1) {
 311:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 312:quantum/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 313:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 314:quantum/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 315:quantum/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 316:quantum/action.c ****                             clear_oneshot_mods();
 317:quantum/action.c ****                             set_oneshot_locked_mods(mods);
 318:quantum/action.c ****                             register_mods(mods);
 319:quantum/action.c **** #        endif
 320:quantum/action.c ****                         } else {
 321:quantum/action.c ****                             register_mods(mods | get_oneshot_mods());
 322:quantum/action.c ****                         }
 323:quantum/action.c ****                     } else {
 324:quantum/action.c ****                         if (tap_count == 0) {
 325:quantum/action.c ****                             clear_oneshot_mods();
 326:quantum/action.c ****                             unregister_mods(mods);
 327:quantum/action.c ****                         } else if (tap_count == 1) {
 328:quantum/action.c ****                             // Retain Oneshot mods
 329:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 330:quantum/action.c ****                             if (mods & get_mods()) {
 331:quantum/action.c ****                                 clear_oneshot_locked_mods();
 332:quantum/action.c ****                                 clear_oneshot_mods();
 333:quantum/action.c ****                                 unregister_mods(mods);
 334:quantum/action.c ****                             }
 335:quantum/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 336:quantum/action.c ****                             // Toggle Oneshot Layer
 337:quantum/action.c **** #        endif
 338:quantum/action.c ****                         } else {
 339:quantum/action.c ****                             clear_oneshot_mods();
 340:quantum/action.c ****                             unregister_mods(mods);
 341:quantum/action.c ****                         }
 342:quantum/action.c ****                     }
 343:quantum/action.c ****                     break;
 344:quantum/action.c **** #    endif
 345:quantum/action.c ****                 case MODS_TAP_TOGGLE:
 346:quantum/action.c ****                     if (event.pressed) {
 347:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 348:quantum/action.c ****                             register_mods(mods);
 349:quantum/action.c ****                         }
 350:quantum/action.c ****                     } else {
 351:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 352:quantum/action.c ****                             unregister_mods(mods);
 353:quantum/action.c ****                         }
 354:quantum/action.c ****                     }
 355:quantum/action.c ****                     break;
 356:quantum/action.c ****                 default:
 357:quantum/action.c ****                     if (event.pressed) {
 358:quantum/action.c ****                         if (tap_count > 0) {
 359:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 360:quantum/action.c ****                             if (
 361:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 362:quantum/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 363:quantum/action.c **** #        endif
 364:quantum/action.c ****                                 record->tap.interrupted) {
 365:quantum/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 366:quantum/action.c ****                                 // ad hoc: set 0 to cancel tap
 367:quantum/action.c ****                                 record->tap.count = 0;
 368:quantum/action.c ****                                 register_mods(mods);
 369:quantum/action.c ****                             } else
 370:quantum/action.c **** #    endif
 371:quantum/action.c ****                             {
 372:quantum/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 373:quantum/action.c ****                                 register_code(action.key.code);
 374:quantum/action.c ****                             }
 375:quantum/action.c ****                         } else {
 376:quantum/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 377:quantum/action.c ****                             register_mods(mods);
 378:quantum/action.c ****                         }
 379:quantum/action.c ****                     } else {
 380:quantum/action.c ****                         if (tap_count > 0) {
 381:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 382:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 383:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 384:quantum/action.c ****                             } else {
 385:quantum/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 386:quantum/action.c ****                             }
 387:quantum/action.c ****                             unregister_code(action.key.code);
 388:quantum/action.c ****                         } else {
 389:quantum/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 390:quantum/action.c ****                             unregister_mods(mods);
 391:quantum/action.c ****                         }
 392:quantum/action.c ****                     }
 393:quantum/action.c ****                     break;
 394:quantum/action.c ****             }
 395:quantum/action.c ****         } break;
 396:quantum/action.c **** #endif
 397:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 398:quantum/action.c ****         /* other HID usage */
 399:quantum/action.c ****         case ACT_USAGE:
 400:quantum/action.c ****             switch (action.usage.page) {
 401:quantum/action.c ****                 case PAGE_SYSTEM:
 402:quantum/action.c ****                     if (event.pressed) {
 403:quantum/action.c ****                         host_system_send(action.usage.code);
 404:quantum/action.c ****                     } else {
 405:quantum/action.c ****                         host_system_send(0);
 406:quantum/action.c ****                     }
 407:quantum/action.c ****                     break;
 408:quantum/action.c ****                 case PAGE_CONSUMER:
 409:quantum/action.c ****                     if (event.pressed) {
 410:quantum/action.c ****                         host_consumer_send(action.usage.code);
 411:quantum/action.c ****                     } else {
 412:quantum/action.c ****                         host_consumer_send(0);
 413:quantum/action.c ****                     }
 414:quantum/action.c ****                     break;
 415:quantum/action.c ****             }
 416:quantum/action.c ****             break;
 417:quantum/action.c **** #endif
 418:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 419:quantum/action.c ****         /* Mouse key */
 420:quantum/action.c ****         case ACT_MOUSEKEY:
 421:quantum/action.c ****             if (event.pressed) {
 422:quantum/action.c ****                 mousekey_on(action.key.code);
 423:quantum/action.c ****             } else {
 424:quantum/action.c ****                 mousekey_off(action.key.code);
 425:quantum/action.c ****             }
 426:quantum/action.c ****             switch (action.key.code) {
 427:quantum/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 428:quantum/action.c **** #        ifdef POINTING_DEVICE_ENABLE
 429:quantum/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN8:
 430:quantum/action.c **** #        else
 431:quantum/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN3:
 432:quantum/action.c **** #        endif
 433:quantum/action.c ****                     register_button(event.pressed, MOUSE_BTN_MASK(action.key.code - KC_MS_BTN1));
 434:quantum/action.c ****                     break;
 435:quantum/action.c **** #    endif
 436:quantum/action.c ****                 default:
 437:quantum/action.c ****                     mousekey_send();
 438:quantum/action.c ****                     break;
 439:quantum/action.c ****             }
 440:quantum/action.c ****             break;
 441:quantum/action.c **** #endif
 442:quantum/action.c **** #ifndef NO_ACTION_LAYER
 443:quantum/action.c ****         case ACT_LAYER:
 444:quantum/action.c ****             if (action.layer_bitop.on == 0) {
 445:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 446:quantum/action.c ****                 if (!event.pressed) {
 447:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 448:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 449:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 450:quantum/action.c ****                     switch (action.layer_bitop.op) {
 451:quantum/action.c ****                         case OP_BIT_AND:
 452:quantum/action.c ****                             default_layer_and(bits | mask);
 453:quantum/action.c ****                             break;
 454:quantum/action.c ****                         case OP_BIT_OR:
 455:quantum/action.c ****                             default_layer_or(bits | mask);
 456:quantum/action.c ****                             break;
 457:quantum/action.c ****                         case OP_BIT_XOR:
 458:quantum/action.c ****                             default_layer_xor(bits | mask);
 459:quantum/action.c ****                             break;
 460:quantum/action.c ****                         case OP_BIT_SET:
 461:quantum/action.c ****                             default_layer_set(bits | mask);
 462:quantum/action.c ****                             break;
 463:quantum/action.c ****                     }
 464:quantum/action.c ****                 }
 465:quantum/action.c ****             } else {
 466:quantum/action.c ****                 /* Layer Bitwise Operation */
 467:quantum/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 468:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 469:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 470:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 471:quantum/action.c ****                     switch (action.layer_bitop.op) {
 472:quantum/action.c ****                         case OP_BIT_AND:
 473:quantum/action.c ****                             layer_and(bits | mask);
 474:quantum/action.c ****                             break;
 475:quantum/action.c ****                         case OP_BIT_OR:
 476:quantum/action.c ****                             layer_or(bits | mask);
 477:quantum/action.c ****                             break;
 478:quantum/action.c ****                         case OP_BIT_XOR:
 479:quantum/action.c ****                             layer_xor(bits | mask);
 480:quantum/action.c ****                             break;
 481:quantum/action.c ****                         case OP_BIT_SET:
 482:quantum/action.c ****                             layer_state_set(bits | mask);
 483:quantum/action.c ****                             break;
 484:quantum/action.c ****                     }
 485:quantum/action.c ****                 }
 486:quantum/action.c ****             }
 487:quantum/action.c ****             break;
 488:quantum/action.c ****         case ACT_LAYER_MODS:
 489:quantum/action.c ****             if (event.pressed) {
 490:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 491:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 492:quantum/action.c ****             } else {
 493:quantum/action.c ****                 unregister_mods(action.layer_mods.mods);
 494:quantum/action.c ****                 layer_off(action.layer_mods.layer);
 495:quantum/action.c ****             }
 496:quantum/action.c ****             break;
 497:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 498:quantum/action.c ****         case ACT_LAYER_TAP:
 499:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
 500:quantum/action.c ****             switch (action.layer_tap.code) {
 501:quantum/action.c ****                 case OP_TAP_TOGGLE:
 502:quantum/action.c ****                     /* tap toggle */
 503:quantum/action.c ****                     if (event.pressed) {
 504:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 505:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 506:quantum/action.c ****                         }
 507:quantum/action.c ****                     } else {
 508:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 509:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 510:quantum/action.c ****                         }
 511:quantum/action.c ****                     }
 512:quantum/action.c ****                     break;
 513:quantum/action.c ****                 case OP_ON_OFF:
 514:quantum/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 515:quantum/action.c ****                     break;
 516:quantum/action.c ****                 case OP_OFF_ON:
 517:quantum/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 518:quantum/action.c ****                     break;
 519:quantum/action.c ****                 case OP_SET_CLEAR:
 520:quantum/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 521:quantum/action.c ****                     break;
 522:quantum/action.c **** #        ifndef NO_ACTION_ONESHOT
 523:quantum/action.c ****                 case OP_ONESHOT:
 524:quantum/action.c ****                     // Oneshot modifier
 525:quantum/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 526:quantum/action.c ****                     do_release_oneshot = false;
 527:quantum/action.c ****                     if (event.pressed) {
 528:quantum/action.c ****                         del_mods(get_oneshot_locked_mods());
 529:quantum/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 530:quantum/action.c ****                             reset_oneshot_layer();
 531:quantum/action.c ****                             layer_off(action.layer_tap.val);
 532:quantum/action.c ****                             break;
 533:quantum/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 534:quantum/action.c ****                             layer_on(action.layer_tap.val);
 535:quantum/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 536:quantum/action.c ****                         }
 537:quantum/action.c ****                     } else {
 538:quantum/action.c ****                         add_mods(get_oneshot_locked_mods());
 539:quantum/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 540:quantum/action.c ****                             reset_oneshot_layer();
 541:quantum/action.c ****                             clear_oneshot_locked_mods();
 542:quantum/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 543:quantum/action.c ****                         } else {
 544:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 545:quantum/action.c ****                         }
 546:quantum/action.c ****                     }
 547:quantum/action.c **** #            else
 548:quantum/action.c ****                     if (event.pressed) {
 549:quantum/action.c ****                         layer_on(action.layer_tap.val);
 550:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 551:quantum/action.c ****                     } else {
 552:quantum/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 553:quantum/action.c ****                         if (tap_count > 1) {
 554:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 555:quantum/action.c ****                         }
 556:quantum/action.c ****                     }
 557:quantum/action.c **** #            endif
 558:quantum/action.c ****                     break;
 559:quantum/action.c **** #        endif
 560:quantum/action.c ****                 default:
 561:quantum/action.c ****                     /* tap key */
 562:quantum/action.c ****                     if (event.pressed) {
 563:quantum/action.c ****                         if (tap_count > 0) {
 564:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 565:quantum/action.c ****                             register_code(action.layer_tap.code);
 566:quantum/action.c ****                         } else {
 567:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 568:quantum/action.c ****                             layer_on(action.layer_tap.val);
 569:quantum/action.c ****                         }
 570:quantum/action.c ****                     } else {
 571:quantum/action.c ****                         if (tap_count > 0) {
 572:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 573:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 574:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 575:quantum/action.c ****                             } else {
 576:quantum/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 577:quantum/action.c ****                             }
 578:quantum/action.c ****                             unregister_code(action.layer_tap.code);
 579:quantum/action.c ****                         } else {
 580:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 581:quantum/action.c ****                             layer_off(action.layer_tap.val);
 582:quantum/action.c ****                         }
 583:quantum/action.c ****                     }
 584:quantum/action.c ****                     break;
 585:quantum/action.c ****             }
 586:quantum/action.c ****             break;
 587:quantum/action.c **** #    endif
 588:quantum/action.c **** #endif
 589:quantum/action.c ****             /* Extentions */
 590:quantum/action.c **** #ifndef NO_ACTION_MACRO
 591:quantum/action.c ****         case ACT_MACRO:
 592:quantum/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 593:quantum/action.c ****             break;
 594:quantum/action.c **** #endif
 595:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 596:quantum/action.c ****         case ACT_SWAP_HANDS:
 597:quantum/action.c ****             switch (action.swap.code) {
 598:quantum/action.c ****                 case OP_SH_TOGGLE:
 599:quantum/action.c ****                     if (event.pressed) {
 600:quantum/action.c ****                         swap_hands = !swap_hands;
 601:quantum/action.c ****                     }
 602:quantum/action.c ****                     break;
 603:quantum/action.c ****                 case OP_SH_ON_OFF:
 604:quantum/action.c ****                     swap_hands = event.pressed;
 605:quantum/action.c ****                     break;
 606:quantum/action.c ****                 case OP_SH_OFF_ON:
 607:quantum/action.c ****                     swap_hands = !event.pressed;
 608:quantum/action.c ****                     break;
 609:quantum/action.c ****                 case OP_SH_ON:
 610:quantum/action.c ****                     if (!event.pressed) {
 611:quantum/action.c ****                         swap_hands = true;
 612:quantum/action.c ****                     }
 613:quantum/action.c ****                     break;
 614:quantum/action.c ****                 case OP_SH_OFF:
 615:quantum/action.c ****                     if (!event.pressed) {
 616:quantum/action.c ****                         swap_hands = false;
 617:quantum/action.c ****                     }
 618:quantum/action.c ****                     break;
 619:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 620:quantum/action.c ****                 case OP_SH_ONESHOT:
 621:quantum/action.c ****                     if (event.pressed) {
 622:quantum/action.c ****                         set_oneshot_swaphands();
 623:quantum/action.c ****                     } else {
 624:quantum/action.c ****                         release_oneshot_swaphands();
 625:quantum/action.c ****                     }
 626:quantum/action.c ****                     break;
 627:quantum/action.c **** #    endif
 628:quantum/action.c **** 
 629:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 630:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
 631:quantum/action.c ****                     /* tap toggle */
 632:quantum/action.c **** 
 633:quantum/action.c ****                     if (event.pressed) {
 634:quantum/action.c ****                         if (swap_held) {
 635:quantum/action.c ****                             swap_held = false;
 636:quantum/action.c ****                         } else {
 637:quantum/action.c ****                             swap_hands = !swap_hands;
 638:quantum/action.c ****                         }
 639:quantum/action.c ****                     } else {
 640:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 641:quantum/action.c ****                             swap_hands = !swap_hands;
 642:quantum/action.c ****                         }
 643:quantum/action.c ****                     }
 644:quantum/action.c ****                     break;
 645:quantum/action.c ****                 default:
 646:quantum/action.c ****                     /* tap key */
 647:quantum/action.c ****                     if (tap_count > 0) {
 648:quantum/action.c ****                         if (swap_held) {
 649:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 650:quantum/action.c ****                             swap_held  = false;
 651:quantum/action.c ****                         }
 652:quantum/action.c ****                         if (event.pressed) {
 653:quantum/action.c ****                             register_code(action.swap.code);
 654:quantum/action.c ****                         } else {
 655:quantum/action.c ****                             wait_ms(TAP_CODE_DELAY);
 656:quantum/action.c ****                             unregister_code(action.swap.code);
 657:quantum/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 658:quantum/action.c ****                         }
 659:quantum/action.c ****                     } else {
 660:quantum/action.c ****                         if (swap_held && !event.pressed) {
 661:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 662:quantum/action.c ****                             swap_held  = false;
 663:quantum/action.c ****                         }
 664:quantum/action.c ****                     }
 665:quantum/action.c **** #    endif
 666:quantum/action.c ****             }
 667:quantum/action.c **** #endif
 668:quantum/action.c **** #ifndef NO_ACTION_FUNCTION
 669:quantum/action.c ****         case ACT_FUNCTION:
 670:quantum/action.c ****             action_function(record, action.func.id, action.func.opt);
 671:quantum/action.c ****             break;
 672:quantum/action.c **** #endif
 673:quantum/action.c ****         default:
 674:quantum/action.c ****             break;
 675:quantum/action.c ****     }
 676:quantum/action.c **** 
 677:quantum/action.c **** #ifndef NO_ACTION_LAYER
 678:quantum/action.c ****     // if this event is a layer action, update the leds
 679:quantum/action.c ****     switch (action.kind.id) {
 680:quantum/action.c ****         case ACT_LAYER:
 681:quantum/action.c ****         case ACT_LAYER_MODS:
 682:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 683:quantum/action.c ****         case ACT_LAYER_TAP:
 684:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
 685:quantum/action.c **** #    endif
 686:quantum/action.c ****             led_set(host_keyboard_leds());
 687:quantum/action.c ****             break;
 688:quantum/action.c ****         default:
 689:quantum/action.c ****             break;
 690:quantum/action.c ****     }
 691:quantum/action.c **** #endif
 692:quantum/action.c **** 
 693:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 694:quantum/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 695:quantum/action.c ****     if (!is_tap_action(action)) {
 696:quantum/action.c ****         retro_tapping_counter = 0;
 697:quantum/action.c ****     } else {
 698:quantum/action.c ****         if (event.pressed) {
 699:quantum/action.c ****             if (tap_count > 0) {
 700:quantum/action.c ****                 retro_tapping_counter = 0;
 701:quantum/action.c ****             }
 702:quantum/action.c ****         } else {
 703:quantum/action.c ****             if (tap_count > 0) {
 704:quantum/action.c ****                 retro_tapping_counter = 0;
 705:quantum/action.c ****             } else {
 706:quantum/action.c ****                 if (
 707:quantum/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 708:quantum/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 709:quantum/action.c **** #        endif
 710:quantum/action.c ****                     retro_tapping_counter == 2) {
 711:quantum/action.c ****                     tap_code(action.layer_tap.code);
 712:quantum/action.c ****                 }
 713:quantum/action.c ****                 retro_tapping_counter = 0;
 714:quantum/action.c ****             }
 715:quantum/action.c ****         }
 716:quantum/action.c ****     }
 717:quantum/action.c **** #    endif
 718:quantum/action.c **** #endif
 719:quantum/action.c **** 
 720:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 721:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 722:quantum/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 723:quantum/action.c ****         use_oneshot_swaphands();
 724:quantum/action.c ****     }
 725:quantum/action.c **** #    endif
 726:quantum/action.c **** #endif
 727:quantum/action.c **** 
 728:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 729:quantum/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 730:quantum/action.c ****      * key before we leave the layer or no key up event will be generated.
 731:quantum/action.c ****      */
 732:quantum/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 733:quantum/action.c ****         record->event.pressed = false;
 734:quantum/action.c ****         layer_on(get_oneshot_layer());
 735:quantum/action.c ****         process_record(record);
 736:quantum/action.c ****         layer_off(get_oneshot_layer());
 737:quantum/action.c ****     }
 738:quantum/action.c **** #endif
 739:quantum/action.c **** }
 740:quantum/action.c **** 
 741:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 742:quantum/action.c ****  *
 743:quantum/action.c ****  * FIXME: Needs documentation.
 744:quantum/action.c ****  */
 745:quantum/action.c **** void register_code(uint8_t code) {
 251               		.loc 1 745 34 is_stmt 1 view -0
 252               		.cfi_startproc
 253               		.loc 1 745 34 is_stmt 0 view .LVU36
 254 0000 CF93      		push r28
 255               	.LCFI8:
 256               		.cfi_def_cfa_offset 3
 257               		.cfi_offset 28, -2
 258               	/* prologue: function */
 259               	/* frame size = 0 */
 260               	/* stack size = 1 */
 261               	.L__stack_usage = 1
 262 0002 C82F      		mov r28,r24
 746:quantum/action.c ****     if (code == KC_NO) {
 263               		.loc 1 746 5 is_stmt 1 view .LVU37
 264               		.loc 1 746 8 is_stmt 0 view .LVU38
 265 0004 8823      		tst r24
 266 0006 01F4      		brne .+2
 267 0008 00C0      		rjmp .L17
 747:quantum/action.c ****         return;
 748:quantum/action.c ****     }
 749:quantum/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 750:quantum/action.c ****     else if (KC_LOCKING_CAPS == code) {
 268               		.loc 1 750 10 is_stmt 1 view .LVU39
 269               		.loc 1 750 13 is_stmt 0 view .LVU40
 270 000a 8238      		cpi r24,lo8(-126)
 271 000c 01F4      		brne .L20
 751:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 752:quantum/action.c ****         // Resync: ignore if caps lock already is on
 753:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 272               		.loc 1 753 9 is_stmt 1 view .LVU41
 273               		.loc 1 753 13 is_stmt 0 view .LVU42
 274 000e 0E94 0000 		call host_keyboard_leds
 275               	.LVL17:
 276               		.loc 1 753 12 view .LVU43
 277 0012 81FD      		sbrc r24,1
 278 0014 00C0      		rjmp .L17
 754:quantum/action.c **** #    endif
 755:quantum/action.c ****         add_key(KC_CAPSLOCK);
 279               		.loc 1 755 9 is_stmt 1 view .LVU44
 280 0016 89E3      		ldi r24,lo8(57)
 281 0018 0E94 0000 		call add_key
 282               	.LVL18:
 756:quantum/action.c ****         send_keyboard_report();
 283               		.loc 1 756 9 view .LVU45
 284 001c 0E94 0000 		call send_keyboard_report
 285               	.LVL19:
 757:quantum/action.c ****         wait_ms(100);
 286               		.loc 1 757 9 view .LVU46
 287               		.loc 1 757 9 view .LVU47
 288               		.loc 1 757 9 view .LVU48
 289               	.LBB44:
 290               	.LBI44:
 291               		.file 3 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 292               		.loc 3 166 1 view .LVU49
 293               	.LBB45:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 294               		.loc 3 168 2 view .LVU50
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 295               		.loc 3 172 2 view .LVU51
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 296               		.loc 3 173 2 view .LVU52
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 297               		.loc 3 174 2 view .LVU53
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 298               		.loc 3 184 3 view .LVU54
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 299               		.loc 3 187 2 view .LVU55
 300 0020 2FEF      		ldi r18,lo8(319999)
 301 0022 31EE      		ldi r19,hi8(319999)
 302 0024 84E0      		ldi r24,hlo8(319999)
 303 0026 2150      	1:	subi r18,1
 304 0028 3040      		sbci r19,0
 305 002a 8040      		sbci r24,0
 306 002c 01F4      		brne 1b
 307 002e 00C0      		rjmp .
 308 0030 0000      		nop
 309               	.LVL20:
 310               		.loc 3 187 2 is_stmt 0 view .LVU56
 311               	.LBE45:
 312               	.LBE44:
 313               		.loc 1 757 9 is_stmt 1 view .LVU57
 758:quantum/action.c ****         del_key(KC_CAPSLOCK);
 314               		.loc 1 758 9 view .LVU58
 315 0032 89E3      		ldi r24,lo8(57)
 316               	.L32:
 759:quantum/action.c ****         send_keyboard_report();
 760:quantum/action.c ****     }
 761:quantum/action.c **** 
 762:quantum/action.c ****     else if (KC_LOCKING_NUM == code) {
 763:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 764:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 765:quantum/action.c **** #    endif
 766:quantum/action.c ****         add_key(KC_NUMLOCK);
 767:quantum/action.c ****         send_keyboard_report();
 768:quantum/action.c ****         wait_ms(100);
 769:quantum/action.c ****         del_key(KC_NUMLOCK);
 317               		.loc 1 769 9 is_stmt 0 view .LVU59
 318 0034 0E94 0000 		call del_key
 319               	.LVL21:
 320               	.L33:
 770:quantum/action.c ****         send_keyboard_report();
 321               		.loc 1 770 9 is_stmt 1 view .LVU60
 322               	/* epilogue start */
 771:quantum/action.c ****     }
 772:quantum/action.c **** 
 773:quantum/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 774:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 775:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 776:quantum/action.c **** #    endif
 777:quantum/action.c ****         add_key(KC_SCROLLLOCK);
 778:quantum/action.c ****         send_keyboard_report();
 779:quantum/action.c ****         wait_ms(100);
 780:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 781:quantum/action.c ****         send_keyboard_report();
 782:quantum/action.c ****     }
 783:quantum/action.c **** #endif
 784:quantum/action.c **** 
 785:quantum/action.c ****     else if IS_KEY (code) {
 786:quantum/action.c ****         // TODO: should push command_proc out of this block?
 787:quantum/action.c ****         if (command_proc(code)) return;
 788:quantum/action.c **** 
 789:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 790:quantum/action.c **** /* TODO: remove
 791:quantum/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 792:quantum/action.c ****             uint8_t tmp_mods = get_mods();
 793:quantum/action.c ****             add_mods(oneshot_state.mods);
 794:quantum/action.c **** 
 795:quantum/action.c ****             add_key(code);
 796:quantum/action.c ****             send_keyboard_report();
 797:quantum/action.c **** 
 798:quantum/action.c ****             set_mods(tmp_mods);
 799:quantum/action.c ****             send_keyboard_report();
 800:quantum/action.c ****             oneshot_cancel();
 801:quantum/action.c ****         } else
 802:quantum/action.c **** */
 803:quantum/action.c **** #endif
 804:quantum/action.c ****         {
 805:quantum/action.c ****             // Force a new key press if the key is already pressed
 806:quantum/action.c ****             // without this, keys with the same keycode, but different
 807:quantum/action.c ****             // modifiers will be reported incorrectly, see issue #1708
 808:quantum/action.c ****             if (is_key_pressed(keyboard_report, code)) {
 809:quantum/action.c ****                 del_key(code);
 810:quantum/action.c ****                 send_keyboard_report();
 811:quantum/action.c ****             }
 812:quantum/action.c ****             add_key(code);
 813:quantum/action.c ****             send_keyboard_report();
 814:quantum/action.c ****         }
 815:quantum/action.c ****     } else if IS_MOD (code) {
 816:quantum/action.c ****         add_mods(MOD_BIT(code));
 817:quantum/action.c ****         send_keyboard_report();
 818:quantum/action.c ****     }
 819:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 820:quantum/action.c ****     else if IS_SYSTEM (code) {
 821:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 822:quantum/action.c ****     } else if IS_CONSUMER (code) {
 823:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 824:quantum/action.c ****     }
 825:quantum/action.c **** #endif
 826:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 827:quantum/action.c ****     else if IS_MOUSEKEY (code) {
 828:quantum/action.c ****         mousekey_on(code);
 829:quantum/action.c ****         mousekey_send();
 830:quantum/action.c ****     }
 831:quantum/action.c **** #endif
 832:quantum/action.c **** }
 323               		.loc 1 832 1 is_stmt 0 view .LVU61
 324 0038 CF91      		pop r28
 770:quantum/action.c ****         send_keyboard_report();
 325               		.loc 1 770 9 view .LVU62
 326 003a 0C94 0000 		jmp send_keyboard_report
 327               	.LVL22:
 328               	.L20:
 762:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 329               		.loc 1 762 10 is_stmt 1 view .LVU63
 762:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 330               		.loc 1 762 13 is_stmt 0 view .LVU64
 331 003e 8338      		cpi r24,lo8(-125)
 332 0040 01F4      		brne .L22
 764:quantum/action.c **** #    endif
 333               		.loc 1 764 9 is_stmt 1 view .LVU65
 764:quantum/action.c **** #    endif
 334               		.loc 1 764 13 is_stmt 0 view .LVU66
 335 0042 0E94 0000 		call host_keyboard_leds
 336               	.LVL23:
 764:quantum/action.c **** #    endif
 337               		.loc 1 764 12 view .LVU67
 338 0046 80FD      		sbrc r24,0
 339 0048 00C0      		rjmp .L17
 766:quantum/action.c ****         send_keyboard_report();
 340               		.loc 1 766 9 is_stmt 1 view .LVU68
 341 004a 83E5      		ldi r24,lo8(83)
 342 004c 0E94 0000 		call add_key
 343               	.LVL24:
 767:quantum/action.c ****         wait_ms(100);
 344               		.loc 1 767 9 view .LVU69
 345 0050 0E94 0000 		call send_keyboard_report
 346               	.LVL25:
 768:quantum/action.c ****         del_key(KC_NUMLOCK);
 347               		.loc 1 768 9 view .LVU70
 768:quantum/action.c ****         del_key(KC_NUMLOCK);
 348               		.loc 1 768 9 view .LVU71
 768:quantum/action.c ****         del_key(KC_NUMLOCK);
 349               		.loc 1 768 9 view .LVU72
 350               	.LBB46:
 351               	.LBI46:
 166:/usr/avr/include/util/delay.h **** {
 352               		.loc 3 166 1 view .LVU73
 353               	.LBB47:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 354               		.loc 3 168 2 view .LVU74
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 355               		.loc 3 172 2 view .LVU75
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 356               		.loc 3 173 2 view .LVU76
 174:/usr/avr/include/util/delay.h **** 
 357               		.loc 3 174 2 view .LVU77
 184:/usr/avr/include/util/delay.h **** 	#endif
 358               		.loc 3 184 3 view .LVU78
 359               		.loc 3 187 2 view .LVU79
 360 0054 9FEF      		ldi r25,lo8(319999)
 361 0056 21EE      		ldi r18,hi8(319999)
 362 0058 34E0      		ldi r19,hlo8(319999)
 363 005a 9150      	1:	subi r25,1
 364 005c 2040      		sbci r18,0
 365 005e 3040      		sbci r19,0
 366 0060 01F4      		brne 1b
 367 0062 00C0      		rjmp .
 368 0064 0000      		nop
 369               	.LVL26:
 370               		.loc 3 187 2 is_stmt 0 view .LVU80
 371               	.LBE47:
 372               	.LBE46:
 768:quantum/action.c ****         del_key(KC_NUMLOCK);
 373               		.loc 1 768 9 is_stmt 1 view .LVU81
 769:quantum/action.c ****         send_keyboard_report();
 374               		.loc 1 769 9 view .LVU82
 375 0066 83E5      		ldi r24,lo8(83)
 376 0068 00C0      		rjmp .L32
 377               	.LVL27:
 378               	.L22:
 773:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 379               		.loc 1 773 10 view .LVU83
 773:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 380               		.loc 1 773 13 is_stmt 0 view .LVU84
 381 006a 8438      		cpi r24,lo8(-124)
 382 006c 01F4      		brne .L23
 775:quantum/action.c **** #    endif
 383               		.loc 1 775 9 is_stmt 1 view .LVU85
 775:quantum/action.c **** #    endif
 384               		.loc 1 775 13 is_stmt 0 view .LVU86
 385 006e 0E94 0000 		call host_keyboard_leds
 386               	.LVL28:
 775:quantum/action.c **** #    endif
 387               		.loc 1 775 12 view .LVU87
 388 0072 82FD      		sbrc r24,2
 389 0074 00C0      		rjmp .L17
 777:quantum/action.c ****         send_keyboard_report();
 390               		.loc 1 777 9 is_stmt 1 view .LVU88
 391 0076 87E4      		ldi r24,lo8(71)
 392 0078 0E94 0000 		call add_key
 393               	.LVL29:
 778:quantum/action.c ****         wait_ms(100);
 394               		.loc 1 778 9 view .LVU89
 395 007c 0E94 0000 		call send_keyboard_report
 396               	.LVL30:
 779:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 397               		.loc 1 779 9 view .LVU90
 779:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 398               		.loc 1 779 9 view .LVU91
 779:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 399               		.loc 1 779 9 view .LVU92
 400               	.LBB48:
 401               	.LBI48:
 166:/usr/avr/include/util/delay.h **** {
 402               		.loc 3 166 1 view .LVU93
 403               	.LBB49:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 404               		.loc 3 168 2 view .LVU94
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 405               		.loc 3 172 2 view .LVU95
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 406               		.loc 3 173 2 view .LVU96
 174:/usr/avr/include/util/delay.h **** 
 407               		.loc 3 174 2 view .LVU97
 184:/usr/avr/include/util/delay.h **** 	#endif
 408               		.loc 3 184 3 view .LVU98
 409               		.loc 3 187 2 view .LVU99
 410 0080 8FEF      		ldi r24,lo8(319999)
 411 0082 91EE      		ldi r25,hi8(319999)
 412 0084 24E0      		ldi r18,hlo8(319999)
 413 0086 8150      	1:	subi r24,1
 414 0088 9040      		sbci r25,0
 415 008a 2040      		sbci r18,0
 416 008c 01F4      		brne 1b
 417 008e 00C0      		rjmp .
 418 0090 0000      		nop
 419               	.LVL31:
 420               		.loc 3 187 2 is_stmt 0 view .LVU100
 421               	.LBE49:
 422               	.LBE48:
 779:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 423               		.loc 1 779 9 is_stmt 1 view .LVU101
 780:quantum/action.c ****         send_keyboard_report();
 424               		.loc 1 780 9 view .LVU102
 425 0092 87E4      		ldi r24,lo8(71)
 426 0094 00C0      		rjmp .L32
 427               	.LVL32:
 428               	.L23:
 785:quantum/action.c ****         // TODO: should push command_proc out of this block?
 429               		.loc 1 785 10 view .LVU103
 785:quantum/action.c ****         // TODO: should push command_proc out of this block?
 430               		.loc 1 785 13 is_stmt 0 view .LVU104
 431 0096 8CEF      		ldi r24,lo8(-4)
 432               	.LVL33:
 785:quantum/action.c ****         // TODO: should push command_proc out of this block?
 433               		.loc 1 785 13 view .LVU105
 434 0098 8C0F      		add r24,r28
 435 009a 813A      		cpi r24,lo8(-95)
 436 009c 00F4      		brsh .L24
 787:quantum/action.c **** 
 437               		.loc 1 787 9 is_stmt 1 view .LVU106
 808:quantum/action.c ****                 del_key(code);
 438               		.loc 1 808 13 view .LVU107
 808:quantum/action.c ****                 del_key(code);
 439               		.loc 1 808 17 is_stmt 0 view .LVU108
 440 009e 6C2F      		mov r22,r28
 441 00a0 8091 0000 		lds r24,keyboard_report
 442 00a4 9091 0000 		lds r25,keyboard_report+1
 443 00a8 0E94 0000 		call is_key_pressed
 444               	.LVL34:
 808:quantum/action.c ****                 del_key(code);
 445               		.loc 1 808 16 view .LVU109
 446 00ac 8823      		tst r24
 447 00ae 01F0      		breq .L25
 809:quantum/action.c ****                 send_keyboard_report();
 448               		.loc 1 809 17 is_stmt 1 view .LVU110
 449 00b0 8C2F      		mov r24,r28
 450 00b2 0E94 0000 		call del_key
 451               	.LVL35:
 810:quantum/action.c ****             }
 452               		.loc 1 810 17 view .LVU111
 453 00b6 0E94 0000 		call send_keyboard_report
 454               	.LVL36:
 455               	.L25:
 812:quantum/action.c ****             send_keyboard_report();
 456               		.loc 1 812 13 view .LVU112
 457 00ba 8C2F      		mov r24,r28
 458 00bc 0E94 0000 		call add_key
 459               	.LVL37:
 813:quantum/action.c ****         }
 460               		.loc 1 813 13 view .LVU113
 461 00c0 00C0      		rjmp .L33
 462               	.L24:
 815:quantum/action.c ****         add_mods(MOD_BIT(code));
 463               		.loc 1 815 12 view .LVU114
 815:quantum/action.c ****         add_mods(MOD_BIT(code));
 464               		.loc 1 815 15 is_stmt 0 view .LVU115
 465 00c2 80E2      		ldi r24,lo8(32)
 466 00c4 8C0F      		add r24,r28
 467 00c6 8830      		cpi r24,lo8(8)
 468 00c8 00F4      		brsh .L26
 816:quantum/action.c ****         send_keyboard_report();
 469               		.loc 1 816 9 is_stmt 1 view .LVU116
 816:quantum/action.c ****         send_keyboard_report();
 470               		.loc 1 816 18 is_stmt 0 view .LVU117
 471 00ca C770      		andi r28,lo8(7)
 472               	.LVL38:
 816:quantum/action.c ****         send_keyboard_report();
 473               		.loc 1 816 9 view .LVU118
 474 00cc 81E0      		ldi r24,lo8(1)
 475 00ce 00C0      		rjmp 2f
 476               		1:
 477 00d0 880F      		lsl r24
 478               		2:
 479 00d2 CA95      		dec r28
 480 00d4 02F4      		brpl 1b
 481 00d6 0E94 0000 		call add_mods
 482               	.LVL39:
 817:quantum/action.c ****     }
 483               		.loc 1 817 9 is_stmt 1 view .LVU119
 484 00da 00C0      		rjmp .L33
 485               	.LVL40:
 486               	.L26:
 820:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 487               		.loc 1 820 10 view .LVU120
 820:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 488               		.loc 1 820 13 is_stmt 0 view .LVU121
 489 00dc 8BE5      		ldi r24,lo8(91)
 490 00de 8C0F      		add r24,r28
 491 00e0 8330      		cpi r24,lo8(3)
 492 00e2 00F4      		brsh .L27
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 493               		.loc 1 821 9 is_stmt 1 view .LVU122
 494 00e4 2C2F      		mov r18,r28
 495 00e6 2452      		subi r18,36
 496 00e8 330B      		sbc r19,r19
 497 00ea C901      		movw r24,r18
 498               	/* epilogue start */
 499               		.loc 1 832 1 is_stmt 0 view .LVU123
 500 00ec CF91      		pop r28
 501               	.LVL41:
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 502               		.loc 1 821 9 view .LVU124
 503 00ee 0C94 0000 		jmp host_system_send
 504               	.LVL42:
 505               	.L27:
 822:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 506               		.loc 1 822 12 is_stmt 1 view .LVU125
 822:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 507               		.loc 1 822 15 is_stmt 0 view .LVU126
 508 00f2 E8E5      		ldi r30,lo8(88)
 509 00f4 EC0F      		add r30,r28
 510 00f6 E731      		cpi r30,lo8(23)
 511 00f8 00F4      		brsh .L28
 823:quantum/action.c ****     }
 512               		.loc 1 823 9 is_stmt 1 view .LVU127
 513               	.LVL43:
 514               	.LBB50:
 515               	.LBI50:
 516               		.file 4 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK,
  34:tmk_core/common/report.h ****     REPORT_ID_DIGITIZER
  35:tmk_core/common/report.h **** };
  36:tmk_core/common/report.h **** 
  37:tmk_core/common/report.h **** /* Mouse buttons */
  38:tmk_core/common/report.h **** #define MOUSE_BTN_MASK(n) (1 << (n))
  39:tmk_core/common/report.h **** enum mouse_buttons {
  40:tmk_core/common/report.h ****     MOUSE_BTN1 = MOUSE_BTN_MASK(0),
  41:tmk_core/common/report.h ****     MOUSE_BTN2 = MOUSE_BTN_MASK(1),
  42:tmk_core/common/report.h ****     MOUSE_BTN3 = MOUSE_BTN_MASK(2),
  43:tmk_core/common/report.h ****     MOUSE_BTN4 = MOUSE_BTN_MASK(3),
  44:tmk_core/common/report.h ****     MOUSE_BTN5 = MOUSE_BTN_MASK(4),
  45:tmk_core/common/report.h ****     MOUSE_BTN6 = MOUSE_BTN_MASK(5),
  46:tmk_core/common/report.h ****     MOUSE_BTN7 = MOUSE_BTN_MASK(6),
  47:tmk_core/common/report.h ****     MOUSE_BTN8 = MOUSE_BTN_MASK(7)
  48:tmk_core/common/report.h **** };
  49:tmk_core/common/report.h **** 
  50:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  51:tmk_core/common/report.h ****  *
  52:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  53:tmk_core/common/report.h ****  */
  54:tmk_core/common/report.h **** enum consumer_usages {
  55:tmk_core/common/report.h ****     // 15.5 Display Controls
  56:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  57:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  58:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  59:tmk_core/common/report.h ****     // 15.7 Transport Controls
  60:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  61:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  62:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  63:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  64:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  65:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  66:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  67:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  68:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  69:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  70:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  71:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  72:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  73:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  74:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  75:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  76:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  77:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  78:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  79:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  80:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  81:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  82:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  83:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  84:tmk_core/common/report.h ****     AC_NEW                 = 0x201,
  85:tmk_core/common/report.h ****     AC_OPEN                = 0x202,
  86:tmk_core/common/report.h ****     AC_CLOSE               = 0x203,
  87:tmk_core/common/report.h ****     AC_EXIT                = 0x204,
  88:tmk_core/common/report.h ****     AC_MAXIMIZE            = 0x205,
  89:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  90:tmk_core/common/report.h ****     AC_SAVE                = 0x207,
  91:tmk_core/common/report.h ****     AC_PRINT               = 0x208,
  92:tmk_core/common/report.h ****     AC_PROPERTIES          = 0x209,
  93:tmk_core/common/report.h ****     AC_UNDO                = 0x21A,
  94:tmk_core/common/report.h ****     AC_COPY                = 0x21B,
  95:tmk_core/common/report.h ****     AC_CUT                 = 0x21C,
  96:tmk_core/common/report.h ****     AC_PASTE               = 0x21D,
  97:tmk_core/common/report.h ****     AC_SELECT_ALL          = 0x21E,
  98:tmk_core/common/report.h ****     AC_FIND                = 0x21F,
  99:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
 100:tmk_core/common/report.h ****     AC_HOME                = 0x223,
 101:tmk_core/common/report.h ****     AC_BACK                = 0x224,
 102:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
 103:tmk_core/common/report.h ****     AC_STOP                = 0x226,
 104:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
 105:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
 106:tmk_core/common/report.h **** };
 107:tmk_core/common/report.h **** 
 108:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
 109:tmk_core/common/report.h ****  *
 110:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
 111:tmk_core/common/report.h ****  */
 112:tmk_core/common/report.h **** enum desktop_usages {
 113:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
 114:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN             = 0x81,
 115:tmk_core/common/report.h ****     SYSTEM_SLEEP                  = 0x82,
 116:tmk_core/common/report.h ****     SYSTEM_WAKE_UP                = 0x83,
 117:tmk_core/common/report.h ****     SYSTEM_RESTART                = 0x8F,
 118:tmk_core/common/report.h ****     // 4.10 System Display Controls
 119:tmk_core/common/report.h ****     SYSTEM_DISPLAY_TOGGLE_INT_EXT = 0xB5
 120:tmk_core/common/report.h **** };
 121:tmk_core/common/report.h **** 
 122:tmk_core/common/report.h **** // clang-format on
 123:tmk_core/common/report.h **** 
 124:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 125:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 126:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 127:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 128:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 129:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 130:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 131:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 132:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 133:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 134:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 135:tmk_core/common/report.h **** #    else
 136:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 137:tmk_core/common/report.h **** #    endif
 138:tmk_core/common/report.h **** #endif
 139:tmk_core/common/report.h **** 
 140:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 141:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 142:tmk_core/common/report.h **** #else
 143:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 144:tmk_core/common/report.h **** #endif
 145:tmk_core/common/report.h **** 
 146:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 147:tmk_core/common/report.h **** 
 148:tmk_core/common/report.h **** #ifdef __cplusplus
 149:tmk_core/common/report.h **** extern "C" {
 150:tmk_core/common/report.h **** #endif
 151:tmk_core/common/report.h **** 
 152:tmk_core/common/report.h **** /*
 153:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 154:tmk_core/common/report.h ****  *
 155:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 156:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 157:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 158:tmk_core/common/report.h ****  *
 159:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 160:tmk_core/common/report.h ****  *
 161:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 162:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 163:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 164:tmk_core/common/report.h ****  *
 165:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 166:tmk_core/common/report.h ****  *
 167:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 168:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 169:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 170:tmk_core/common/report.h ****  *
 171:tmk_core/common/report.h ****  */
 172:tmk_core/common/report.h **** typedef union {
 173:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 174:tmk_core/common/report.h ****     struct {
 175:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 176:tmk_core/common/report.h ****         uint8_t report_id;
 177:tmk_core/common/report.h **** #endif
 178:tmk_core/common/report.h ****         uint8_t mods;
 179:tmk_core/common/report.h ****         uint8_t reserved;
 180:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 181:tmk_core/common/report.h ****     };
 182:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 183:tmk_core/common/report.h ****     struct nkro_report {
 184:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 185:tmk_core/common/report.h ****         uint8_t report_id;
 186:tmk_core/common/report.h **** #    endif
 187:tmk_core/common/report.h ****         uint8_t mods;
 188:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 189:tmk_core/common/report.h ****     } nkro;
 190:tmk_core/common/report.h **** #endif
 191:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 192:tmk_core/common/report.h **** 
 193:tmk_core/common/report.h **** typedef struct {
 194:tmk_core/common/report.h ****     uint8_t  report_id;
 195:tmk_core/common/report.h ****     uint16_t usage;
 196:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 197:tmk_core/common/report.h **** 
 198:tmk_core/common/report.h **** typedef struct {
 199:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 200:tmk_core/common/report.h ****     uint8_t report_id;
 201:tmk_core/common/report.h **** #endif
 202:tmk_core/common/report.h ****     uint8_t buttons;
 203:tmk_core/common/report.h ****     int8_t  x;
 204:tmk_core/common/report.h ****     int8_t  y;
 205:tmk_core/common/report.h ****     int8_t  v;
 206:tmk_core/common/report.h ****     int8_t  h;
 207:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 208:tmk_core/common/report.h **** 
 209:tmk_core/common/report.h **** typedef struct {
 210:tmk_core/common/report.h **** #ifdef DIGITIZER_SHARED_EP
 211:tmk_core/common/report.h ****     uint8_t report_id;
 212:tmk_core/common/report.h **** #endif
 213:tmk_core/common/report.h ****     uint8_t  tip : 1;
 214:tmk_core/common/report.h ****     uint8_t  inrange : 1;
 215:tmk_core/common/report.h ****     uint8_t  pad2 : 6;
 216:tmk_core/common/report.h ****     uint16_t x;
 217:tmk_core/common/report.h ****     uint16_t y;
 218:tmk_core/common/report.h **** } __attribute__((packed)) report_digitizer_t;
 219:tmk_core/common/report.h **** 
 220:tmk_core/common/report.h **** typedef struct {
 221:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 222:tmk_core/common/report.h **** #    if JOYSTICK_AXES_RESOLUTION > 8
 223:tmk_core/common/report.h ****     int16_t axes[JOYSTICK_AXES_COUNT];
 224:tmk_core/common/report.h **** #    else
 225:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 226:tmk_core/common/report.h **** #    endif
 227:tmk_core/common/report.h **** #endif
 228:tmk_core/common/report.h **** 
 229:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 230:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 231:tmk_core/common/report.h **** #endif
 232:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 233:tmk_core/common/report.h **** 
 234:tmk_core/common/report.h **** /* keycode to system usage */
 235:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 236:tmk_core/common/report.h ****     switch (key) {
 237:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 238:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 239:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 240:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 241:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 242:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 243:tmk_core/common/report.h ****         default:
 244:tmk_core/common/report.h ****             return 0;
 245:tmk_core/common/report.h ****     }
 246:tmk_core/common/report.h **** }
 247:tmk_core/common/report.h **** 
 248:tmk_core/common/report.h **** /* keycode to consumer usage */
 249:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 517               		.loc 4 249 24 view .LVU128
 250:tmk_core/common/report.h ****     switch (key) {
 518               		.loc 4 250 5 view .LVU129
 519               		.loc 4 250 5 is_stmt 0 view .LVU130
 520               	.LBE50:
 823:quantum/action.c ****     }
 521               		.loc 1 823 9 view .LVU131
 522 00fa F0E0      		ldi r31,0
 523 00fc EE0F      		lsl r30
 524 00fe FF1F      		rol r31
 525 0100 E050      		subi r30,lo8(-(CSWTCH.14))
 526 0102 F040      		sbci r31,hi8(-(CSWTCH.14))
 527 0104 8081      		ld r24,Z
 528 0106 9181      		ldd r25,Z+1
 529               	/* epilogue start */
 530               		.loc 1 832 1 view .LVU132
 531 0108 CF91      		pop r28
 532               	.LVL44:
 823:quantum/action.c ****     }
 533               		.loc 1 823 9 view .LVU133
 534 010a 0C94 0000 		jmp host_consumer_send
 535               	.LVL45:
 536               	.L28:
 827:quantum/action.c ****         mousekey_on(code);
 537               		.loc 1 827 10 is_stmt 1 view .LVU134
 827:quantum/action.c ****         mousekey_on(code);
 538               		.loc 1 827 13 is_stmt 0 view .LVU135
 539 010e CD3E      		cpi r28,lo8(-19)
 540 0110 00F0      		brlo .L17
 828:quantum/action.c ****         mousekey_send();
 541               		.loc 1 828 9 is_stmt 1 view .LVU136
 542 0112 8C2F      		mov r24,r28
 543 0114 0E94 0000 		call mousekey_on
 544               	.LVL46:
 829:quantum/action.c ****     }
 545               		.loc 1 829 9 view .LVU137
 546               	/* epilogue start */
 547               		.loc 1 832 1 is_stmt 0 view .LVU138
 548 0118 CF91      		pop r28
 549               	.LVL47:
 829:quantum/action.c ****     }
 550               		.loc 1 829 9 view .LVU139
 551 011a 0C94 0000 		jmp mousekey_send
 552               	.LVL48:
 553               	.L17:
 554               	/* epilogue start */
 555               		.loc 1 832 1 view .LVU140
 556 011e CF91      		pop r28
 557               	.LVL49:
 558               		.loc 1 832 1 view .LVU141
 559 0120 0895      		ret
 560               		.cfi_endproc
 561               	.LFE117:
 563               		.section	.text.unregister_code,"ax",@progbits
 564               	.global	unregister_code
 566               	unregister_code:
 567               	.LVL50:
 568               	.LFB118:
 833:quantum/action.c **** 
 834:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 835:quantum/action.c ****  *
 836:quantum/action.c ****  * FIXME: Needs documentation.
 837:quantum/action.c ****  */
 838:quantum/action.c **** void unregister_code(uint8_t code) {
 569               		.loc 1 838 36 is_stmt 1 view -0
 570               		.cfi_startproc
 571               	/* prologue: function */
 572               	/* frame size = 0 */
 573               	/* stack size = 0 */
 574               	.L__stack_usage = 0
 839:quantum/action.c ****     if (code == KC_NO) {
 575               		.loc 1 839 5 view .LVU143
 576               		.loc 1 839 8 is_stmt 0 view .LVU144
 577 0000 8823      		tst r24
 578 0002 01F4      		brne .+2
 579 0004 00C0      		rjmp .L34
 840:quantum/action.c ****         return;
 841:quantum/action.c ****     }
 842:quantum/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 843:quantum/action.c ****     else if (KC_LOCKING_CAPS == code) {
 580               		.loc 1 843 10 is_stmt 1 view .LVU145
 581               		.loc 1 843 13 is_stmt 0 view .LVU146
 582 0006 8238      		cpi r24,lo8(-126)
 583 0008 01F4      		brne .L37
 844:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 845:quantum/action.c ****         // Resync: ignore if caps lock already is off
 846:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 584               		.loc 1 846 9 is_stmt 1 view .LVU147
 585               		.loc 1 846 15 is_stmt 0 view .LVU148
 586 000a 0E94 0000 		call host_keyboard_leds
 587               	.LVL51:
 588               		.loc 1 846 12 view .LVU149
 589 000e 81FF      		sbrs r24,1
 590 0010 00C0      		rjmp .L34
 847:quantum/action.c **** #    endif
 848:quantum/action.c ****         add_key(KC_CAPSLOCK);
 591               		.loc 1 848 9 is_stmt 1 view .LVU150
 592 0012 89E3      		ldi r24,lo8(57)
 593 0014 0E94 0000 		call add_key
 594               	.LVL52:
 849:quantum/action.c ****         send_keyboard_report();
 595               		.loc 1 849 9 view .LVU151
 596 0018 0E94 0000 		call send_keyboard_report
 597               	.LVL53:
 850:quantum/action.c ****         del_key(KC_CAPSLOCK);
 598               		.loc 1 850 9 view .LVU152
 599 001c 89E3      		ldi r24,lo8(57)
 600               	.L54:
 851:quantum/action.c ****         send_keyboard_report();
 852:quantum/action.c ****     }
 853:quantum/action.c **** 
 854:quantum/action.c ****     else if (KC_LOCKING_NUM == code) {
 855:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 856:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 857:quantum/action.c **** #    endif
 858:quantum/action.c ****         add_key(KC_NUMLOCK);
 859:quantum/action.c ****         send_keyboard_report();
 860:quantum/action.c ****         del_key(KC_NUMLOCK);
 601               		.loc 1 860 9 is_stmt 0 view .LVU153
 602 001e 0E94 0000 		call del_key
 603               	.LVL54:
 604               	.L55:
 861:quantum/action.c ****         send_keyboard_report();
 605               		.loc 1 861 9 is_stmt 1 view .LVU154
 606 0022 0C94 0000 		jmp send_keyboard_report
 607               	.LVL55:
 608               	.L37:
 854:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 609               		.loc 1 854 10 view .LVU155
 854:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 610               		.loc 1 854 13 is_stmt 0 view .LVU156
 611 0026 8338      		cpi r24,lo8(-125)
 612 0028 01F4      		brne .L39
 856:quantum/action.c **** #    endif
 613               		.loc 1 856 9 is_stmt 1 view .LVU157
 856:quantum/action.c **** #    endif
 614               		.loc 1 856 15 is_stmt 0 view .LVU158
 615 002a 0E94 0000 		call host_keyboard_leds
 616               	.LVL56:
 856:quantum/action.c **** #    endif
 617               		.loc 1 856 12 view .LVU159
 618 002e 80FF      		sbrs r24,0
 619 0030 00C0      		rjmp .L34
 858:quantum/action.c ****         send_keyboard_report();
 620               		.loc 1 858 9 is_stmt 1 view .LVU160
 621 0032 83E5      		ldi r24,lo8(83)
 622 0034 0E94 0000 		call add_key
 623               	.LVL57:
 859:quantum/action.c ****         del_key(KC_NUMLOCK);
 624               		.loc 1 859 9 view .LVU161
 625 0038 0E94 0000 		call send_keyboard_report
 626               	.LVL58:
 860:quantum/action.c ****         send_keyboard_report();
 627               		.loc 1 860 9 view .LVU162
 628 003c 83E5      		ldi r24,lo8(83)
 629 003e 00C0      		rjmp .L54
 630               	.LVL59:
 631               	.L39:
 862:quantum/action.c ****     }
 863:quantum/action.c **** 
 864:quantum/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 632               		.loc 1 864 10 view .LVU163
 633               		.loc 1 864 13 is_stmt 0 view .LVU164
 634 0040 8438      		cpi r24,lo8(-124)
 635 0042 01F4      		brne .L40
 865:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 866:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 636               		.loc 1 866 9 is_stmt 1 view .LVU165
 637               		.loc 1 866 15 is_stmt 0 view .LVU166
 638 0044 0E94 0000 		call host_keyboard_leds
 639               	.LVL60:
 640               		.loc 1 866 12 view .LVU167
 641 0048 82FF      		sbrs r24,2
 642 004a 00C0      		rjmp .L34
 867:quantum/action.c **** #    endif
 868:quantum/action.c ****         add_key(KC_SCROLLLOCK);
 643               		.loc 1 868 9 is_stmt 1 view .LVU168
 644 004c 87E4      		ldi r24,lo8(71)
 645 004e 0E94 0000 		call add_key
 646               	.LVL61:
 869:quantum/action.c ****         send_keyboard_report();
 647               		.loc 1 869 9 view .LVU169
 648 0052 0E94 0000 		call send_keyboard_report
 649               	.LVL62:
 870:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 650               		.loc 1 870 9 view .LVU170
 651 0056 87E4      		ldi r24,lo8(71)
 652 0058 00C0      		rjmp .L54
 653               	.LVL63:
 654               	.L40:
 871:quantum/action.c ****         send_keyboard_report();
 872:quantum/action.c ****     }
 873:quantum/action.c **** #endif
 874:quantum/action.c **** 
 875:quantum/action.c ****     else if IS_KEY (code) {
 655               		.loc 1 875 10 view .LVU171
 656               		.loc 1 875 13 is_stmt 0 view .LVU172
 657 005a 9CEF      		ldi r25,lo8(-4)
 658 005c 980F      		add r25,r24
 659 005e 913A      		cpi r25,lo8(-95)
 660 0060 00F0      		brlo .L54
 876:quantum/action.c ****         del_key(code);
 877:quantum/action.c ****         send_keyboard_report();
 878:quantum/action.c ****     } else if IS_MOD (code) {
 661               		.loc 1 878 12 is_stmt 1 view .LVU173
 662               		.loc 1 878 15 is_stmt 0 view .LVU174
 663 0062 90E2      		ldi r25,lo8(32)
 664 0064 980F      		add r25,r24
 665 0066 9830      		cpi r25,lo8(8)
 666 0068 00F4      		brsh .L42
 879:quantum/action.c ****         del_mods(MOD_BIT(code));
 667               		.loc 1 879 9 is_stmt 1 view .LVU175
 668               		.loc 1 879 18 is_stmt 0 view .LVU176
 669 006a 8770      		andi r24,lo8(7)
 670               	.LVL64:
 671               		.loc 1 879 9 view .LVU177
 672 006c 91E0      		ldi r25,lo8(1)
 673 006e 00C0      		rjmp 2f
 674               		1:
 675 0070 990F      		lsl r25
 676               		2:
 677 0072 8A95      		dec r24
 678 0074 02F4      		brpl 1b
 679 0076 892F      		mov r24,r25
 680 0078 0E94 0000 		call del_mods
 681               	.LVL65:
 880:quantum/action.c ****         send_keyboard_report();
 682               		.loc 1 880 9 is_stmt 1 view .LVU178
 683 007c 00C0      		rjmp .L55
 684               	.LVL66:
 685               	.L42:
 881:quantum/action.c ****     } else if IS_SYSTEM (code) {
 686               		.loc 1 881 12 view .LVU179
 687               		.loc 1 881 15 is_stmt 0 view .LVU180
 688 007e 9BE5      		ldi r25,lo8(91)
 689 0080 980F      		add r25,r24
 690 0082 9330      		cpi r25,lo8(3)
 691 0084 00F4      		brsh .L43
 882:quantum/action.c ****         host_system_send(0);
 692               		.loc 1 882 9 is_stmt 1 view .LVU181
 693 0086 90E0      		ldi r25,0
 694 0088 80E0      		ldi r24,0
 695               	.LVL67:
 696               		.loc 1 882 9 is_stmt 0 view .LVU182
 697 008a 0C94 0000 		jmp host_system_send
 698               	.LVL68:
 699               	.L43:
 883:quantum/action.c ****     } else if IS_CONSUMER (code) {
 700               		.loc 1 883 12 is_stmt 1 view .LVU183
 701               		.loc 1 883 15 is_stmt 0 view .LVU184
 702 008e 98E5      		ldi r25,lo8(88)
 703 0090 980F      		add r25,r24
 704 0092 9731      		cpi r25,lo8(23)
 705 0094 00F4      		brsh .L44
 884:quantum/action.c ****         host_consumer_send(0);
 706               		.loc 1 884 9 is_stmt 1 view .LVU185
 707 0096 90E0      		ldi r25,0
 708 0098 80E0      		ldi r24,0
 709               	.LVL69:
 710               		.loc 1 884 9 is_stmt 0 view .LVU186
 711 009a 0C94 0000 		jmp host_consumer_send
 712               	.LVL70:
 713               	.L44:
 885:quantum/action.c ****     }
 886:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 887:quantum/action.c ****     else if IS_MOUSEKEY (code) {
 714               		.loc 1 887 10 is_stmt 1 view .LVU187
 715               		.loc 1 887 13 is_stmt 0 view .LVU188
 716 009e 8D3E      		cpi r24,lo8(-19)
 717 00a0 00F0      		brlo .L34
 888:quantum/action.c ****         mousekey_off(code);
 718               		.loc 1 888 9 is_stmt 1 view .LVU189
 719 00a2 0E94 0000 		call mousekey_off
 720               	.LVL71:
 889:quantum/action.c ****         mousekey_send();
 721               		.loc 1 889 9 view .LVU190
 722 00a6 0C94 0000 		jmp mousekey_send
 723               	.LVL72:
 724               	.L34:
 725               	/* epilogue start */
 890:quantum/action.c ****     }
 891:quantum/action.c **** #endif
 892:quantum/action.c **** }
 726               		.loc 1 892 1 is_stmt 0 view .LVU191
 727 00aa 0895      		ret
 728               		.cfi_endproc
 729               	.LFE118:
 731               		.section	.text.tap_code_delay,"ax",@progbits
 732               	.global	tap_code_delay
 734               	tap_code_delay:
 735               	.LVL73:
 736               	.LFB119:
 893:quantum/action.c **** 
 894:quantum/action.c **** /** \brief Tap a keycode with a delay.
 895:quantum/action.c ****  *
 896:quantum/action.c ****  * \param code The basic keycode to tap.
 897:quantum/action.c ****  * \param delay The amount of time in milliseconds to leave the keycode registered, before unregist
 898:quantum/action.c ****  */
 899:quantum/action.c **** void tap_code_delay(uint8_t code, uint16_t delay) {
 737               		.loc 1 899 51 is_stmt 1 view -0
 738               		.cfi_startproc
 739               		.loc 1 899 51 is_stmt 0 view .LVU193
 740 0000 1F93      		push r17
 741               	.LCFI9:
 742               		.cfi_def_cfa_offset 3
 743               		.cfi_offset 17, -2
 744 0002 CF93      		push r28
 745               	.LCFI10:
 746               		.cfi_def_cfa_offset 4
 747               		.cfi_offset 28, -3
 748 0004 DF93      		push r29
 749               	.LCFI11:
 750               		.cfi_def_cfa_offset 5
 751               		.cfi_offset 29, -4
 752               	/* prologue: function */
 753               	/* frame size = 0 */
 754               	/* stack size = 3 */
 755               	.L__stack_usage = 3
 756 0006 182F      		mov r17,r24
 757 0008 EB01      		movw r28,r22
 900:quantum/action.c ****     register_code(code);
 758               		.loc 1 900 5 is_stmt 1 view .LVU194
 759 000a 0E94 0000 		call register_code
 760               	.LVL74:
 901:quantum/action.c ****     for (uint16_t i = delay; i > 0; i--) {
 761               		.loc 1 901 5 view .LVU195
 762               	.LBB51:
 763               		.loc 1 901 10 view .LVU196
 764               	.L57:
 765               		.loc 1 901 32 discriminator 2 view .LVU197
 766 000e 2097      		sbiw r28,0
 767 0010 01F4      		brne .L58
 768               		.loc 1 901 32 is_stmt 0 discriminator 2 view .LVU198
 769               	.LBE51:
 902:quantum/action.c ****         wait_ms(1);
 903:quantum/action.c ****     }
 904:quantum/action.c ****     unregister_code(code);
 770               		.loc 1 904 5 is_stmt 1 view .LVU199
 771 0012 812F      		mov r24,r17
 772               	/* epilogue start */
 905:quantum/action.c **** }
 773               		.loc 1 905 1 is_stmt 0 view .LVU200
 774 0014 DF91      		pop r29
 775 0016 CF91      		pop r28
 776               	.LVL75:
 777               		.loc 1 905 1 view .LVU201
 778 0018 1F91      		pop r17
 779               	.LVL76:
 904:quantum/action.c **** }
 780               		.loc 1 904 5 view .LVU202
 781 001a 0C94 0000 		jmp unregister_code
 782               	.LVL77:
 783               	.L58:
 784               	.LBB54:
 902:quantum/action.c ****         wait_ms(1);
 785               		.loc 1 902 9 is_stmt 1 view .LVU203
 902:quantum/action.c ****         wait_ms(1);
 786               		.loc 1 902 9 view .LVU204
 902:quantum/action.c ****         wait_ms(1);
 787               		.loc 1 902 9 view .LVU205
 788               	.LBB52:
 789               	.LBI52:
 166:/usr/avr/include/util/delay.h **** {
 790               		.loc 3 166 1 view .LVU206
 791               	.LBB53:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 792               		.loc 3 168 2 view .LVU207
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 793               		.loc 3 172 2 view .LVU208
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 794               		.loc 3 173 2 view .LVU209
 174:/usr/avr/include/util/delay.h **** 
 795               		.loc 3 174 2 view .LVU210
 184:/usr/avr/include/util/delay.h **** 	#endif
 796               		.loc 3 184 3 view .LVU211
 797               		.loc 3 187 2 view .LVU212
 798 001e 8FE9      		ldi r24,lo8(3999)
 799 0020 9FE0      		ldi r25,hi8(3999)
 800 0022 0197      	1:	sbiw r24,1
 801 0024 01F4      		brne 1b
 802 0026 00C0      		rjmp .
 803 0028 0000      		nop
 804               	.LVL78:
 805               		.loc 3 187 2 is_stmt 0 view .LVU213
 806               	.LBE53:
 807               	.LBE52:
 902:quantum/action.c ****     }
 808               		.loc 1 902 9 is_stmt 1 view .LVU214
 901:quantum/action.c ****         wait_ms(1);
 809               		.loc 1 901 38 view .LVU215
 810 002a 2197      		sbiw r28,1
 811               	.LVL79:
 901:quantum/action.c ****         wait_ms(1);
 812               		.loc 1 901 38 is_stmt 0 view .LVU216
 813 002c 00C0      		rjmp .L57
 814               	.LBE54:
 815               		.cfi_endproc
 816               	.LFE119:
 818               		.section	.text.tap_code,"ax",@progbits
 819               	.global	tap_code
 821               	tap_code:
 822               	.LVL80:
 823               	.LFB120:
 906:quantum/action.c **** 
 907:quantum/action.c **** /** \brief Tap a keycode with the default delay.
 908:quantum/action.c ****  *
 909:quantum/action.c ****  * \param code The basic keycode to tap. If `code` is `KC_CAPS`, the delay will be `TAP_HOLD_CAPS_D
 910:quantum/action.c ****  */
 911:quantum/action.c **** void tap_code(uint8_t code) { tap_code_delay(code, code == KC_CAPS ? TAP_HOLD_CAPS_DELAY : TAP_CODE
 824               		.loc 1 911 29 is_stmt 1 view -0
 825               		.cfi_startproc
 826               	/* prologue: function */
 827               	/* frame size = 0 */
 828               	/* stack size = 0 */
 829               	.L__stack_usage = 0
 830               		.loc 1 911 31 view .LVU218
 831 0000 70E0      		ldi r23,0
 832 0002 60E0      		ldi r22,0
 833 0004 8933      		cpi r24,lo8(57)
 834 0006 01F4      		brne .L60
 835 0008 60E5      		ldi r22,lo8(80)
 836 000a 70E0      		ldi r23,0
 837               	.L60:
 838               		.loc 1 911 31 is_stmt 0 discriminator 4 view .LVU219
 839 000c 0C94 0000 		jmp tap_code_delay
 840               	.LVL81:
 841               		.loc 1 911 31 discriminator 4 view .LVU220
 842               		.cfi_endproc
 843               	.LFE120:
 845               		.section	.text.register_mods,"ax",@progbits
 846               	.global	register_mods
 848               	register_mods:
 849               	.LVL82:
 850               	.LFB121:
 912:quantum/action.c **** 
 913:quantum/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 914:quantum/action.c ****  *
 915:quantum/action.c ****  * \param mods A bitfield of modifiers to register.
 916:quantum/action.c ****  */
 917:quantum/action.c **** void register_mods(uint8_t mods) {
 851               		.loc 1 917 34 is_stmt 1 view -0
 852               		.cfi_startproc
 853               	/* prologue: function */
 854               	/* frame size = 0 */
 855               	/* stack size = 0 */
 856               	.L__stack_usage = 0
 918:quantum/action.c ****     if (mods) {
 857               		.loc 1 918 5 view .LVU222
 858               		.loc 1 918 8 is_stmt 0 view .LVU223
 859 0000 8823      		tst r24
 860 0002 01F0      		breq .L62
 919:quantum/action.c ****         add_mods(mods);
 861               		.loc 1 919 9 is_stmt 1 view .LVU224
 862 0004 0E94 0000 		call add_mods
 863               	.LVL83:
 920:quantum/action.c ****         send_keyboard_report();
 864               		.loc 1 920 9 view .LVU225
 865 0008 0C94 0000 		jmp send_keyboard_report
 866               	.LVL84:
 867               	.L62:
 868               	/* epilogue start */
 921:quantum/action.c ****     }
 922:quantum/action.c **** }
 869               		.loc 1 922 1 is_stmt 0 view .LVU226
 870 000c 0895      		ret
 871               		.cfi_endproc
 872               	.LFE121:
 874               		.section	.text.unregister_mods,"ax",@progbits
 875               	.global	unregister_mods
 877               	unregister_mods:
 878               	.LVL85:
 879               	.LFB122:
 923:quantum/action.c **** 
 924:quantum/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 925:quantum/action.c ****  *
 926:quantum/action.c ****  * \param mods A bitfield of modifiers to unregister.
 927:quantum/action.c ****  */
 928:quantum/action.c **** void unregister_mods(uint8_t mods) {
 880               		.loc 1 928 36 is_stmt 1 view -0
 881               		.cfi_startproc
 882               	/* prologue: function */
 883               	/* frame size = 0 */
 884               	/* stack size = 0 */
 885               	.L__stack_usage = 0
 929:quantum/action.c ****     if (mods) {
 886               		.loc 1 929 5 view .LVU228
 887               		.loc 1 929 8 is_stmt 0 view .LVU229
 888 0000 8823      		tst r24
 889 0002 01F0      		breq .L64
 930:quantum/action.c ****         del_mods(mods);
 890               		.loc 1 930 9 is_stmt 1 view .LVU230
 891 0004 0E94 0000 		call del_mods
 892               	.LVL86:
 931:quantum/action.c ****         send_keyboard_report();
 893               		.loc 1 931 9 view .LVU231
 894 0008 0C94 0000 		jmp send_keyboard_report
 895               	.LVL87:
 896               	.L64:
 897               	/* epilogue start */
 932:quantum/action.c ****     }
 933:quantum/action.c **** }
 898               		.loc 1 933 1 is_stmt 0 view .LVU232
 899 000c 0895      		ret
 900               		.cfi_endproc
 901               	.LFE122:
 903               		.section	.text.process_action,"ax",@progbits
 904               	.global	process_action
 906               	process_action:
 907               	.LVL88:
 908               	.LFB116:
 249:quantum/action.c ****     keyevent_t event = record->event;
 909               		.loc 1 249 59 is_stmt 1 view -0
 910               		.cfi_startproc
 249:quantum/action.c ****     keyevent_t event = record->event;
 911               		.loc 1 249 59 is_stmt 0 view .LVU234
 912 0000 AF92      		push r10
 913               	.LCFI12:
 914               		.cfi_def_cfa_offset 3
 915               		.cfi_offset 10, -2
 916 0002 BF92      		push r11
 917               	.LCFI13:
 918               		.cfi_def_cfa_offset 4
 919               		.cfi_offset 11, -3
 920 0004 CF92      		push r12
 921               	.LCFI14:
 922               		.cfi_def_cfa_offset 5
 923               		.cfi_offset 12, -4
 924 0006 DF92      		push r13
 925               	.LCFI15:
 926               		.cfi_def_cfa_offset 6
 927               		.cfi_offset 13, -5
 928 0008 EF92      		push r14
 929               	.LCFI16:
 930               		.cfi_def_cfa_offset 7
 931               		.cfi_offset 14, -6
 932 000a FF92      		push r15
 933               	.LCFI17:
 934               		.cfi_def_cfa_offset 8
 935               		.cfi_offset 15, -7
 936 000c 0F93      		push r16
 937               	.LCFI18:
 938               		.cfi_def_cfa_offset 9
 939               		.cfi_offset 16, -8
 940 000e 1F93      		push r17
 941               	.LCFI19:
 942               		.cfi_def_cfa_offset 10
 943               		.cfi_offset 17, -9
 944 0010 CF93      		push r28
 945               	.LCFI20:
 946               		.cfi_def_cfa_offset 11
 947               		.cfi_offset 28, -10
 948 0012 DF93      		push r29
 949               	.LCFI21:
 950               		.cfi_def_cfa_offset 12
 951               		.cfi_offset 29, -11
 952 0014 00D0      		rcall .
 953 0016 00D0      		rcall .
 954 0018 0F92      		push __tmp_reg__
 955               	.LCFI22:
 956               		.cfi_def_cfa_offset 17
 957 001a CDB7      		in r28,__SP_L__
 958 001c DEB7      		in r29,__SP_H__
 959               	.LCFI23:
 960               		.cfi_def_cfa_register 28
 961               	/* prologue: function */
 962               	/* frame size = 5 */
 963               	/* stack size = 15 */
 964               	.L__stack_usage = 15
 965 001e 6C01      		movw r12,r24
 966 0020 6D83      		std Y+5,r22
 967 0022 7983      		std Y+1,r23
 250:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 968               		.loc 1 250 5 is_stmt 1 view .LVU235
 250:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 969               		.loc 1 250 16 is_stmt 0 view .LVU236
 970 0024 FC01      		movw r30,r24
 971 0026 1281      		ldd r17,Z+2
 972               	.LVL89:
 252:quantum/action.c **** #endif
 973               		.loc 1 252 5 is_stmt 1 view .LVU237
 252:quantum/action.c **** #endif
 974               		.loc 1 252 36 is_stmt 0 view .LVU238
 975 0028 0581      		ldd r16,Z+5
 976 002a 0295      		swap r16
 977 002c 0F70      		andi r16,lo8(15)
 978               	.LVL90:
 256:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 979               		.loc 1 256 5 is_stmt 1 view .LVU239
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 980               		.loc 1 258 5 view .LVU240
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 981               		.loc 1 258 9 is_stmt 0 view .LVU241
 982 002e 0E94 0000 		call is_oneshot_layer_active
 983               	.LVL91:
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 984               		.loc 1 258 9 view .LVU242
 985 0032 E82E      		mov r14,r24
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 986               		.loc 1 258 8 view .LVU243
 987 0034 8823      		tst r24
 988 0036 01F0      		breq .L67
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 989               		.loc 1 258 43 discriminator 1 view .LVU244
 990 0038 E12E      		mov r14,r17
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 991               		.loc 1 258 35 discriminator 1 view .LVU245
 992 003a 1123      		tst r17
 993 003c 01F0      		breq .L67
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 994               		.loc 1 258 71 discriminator 2 view .LVU246
 995 003e 8981      		ldd r24,Y+1
 996 0040 807F      		andi r24,lo8(-16)
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 997               		.loc 1 258 52 discriminator 2 view .LVU247
 998 0042 8034      		cpi r24,lo8(64)
 999 0044 01F0      		breq .L68
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1000               		.loc 1 258 87 discriminator 3 view .LVU248
 1001 0046 8D81      		ldd r24,Y+5
 1002 0048 805E      		subi r24,lo8(-(32))
 256:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 1003               		.loc 1 256 10 discriminator 3 view .LVU249
 1004 004a E12C      		mov r14,__zero_reg__
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1005               		.loc 1 258 84 discriminator 3 view .LVU250
 1006 004c 8830      		cpi r24,lo8(8)
 1007 004e 00F0      		brlo .L67
 1008               	.L68:
 263:quantum/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 1009               		.loc 1 263 9 is_stmt 1 view .LVU251
 1010 0050 82E0      		ldi r24,lo8(2)
 1011 0052 0E94 0000 		call clear_oneshot_layer_state
 1012               	.LVL92:
 264:quantum/action.c ****     }
 1013               		.loc 1 264 9 view .LVU252
 264:quantum/action.c ****     }
 1014               		.loc 1 264 31 is_stmt 0 view .LVU253
 1015 0056 0E94 0000 		call is_oneshot_layer_active
 1016               	.LVL93:
 264:quantum/action.c ****     }
 1017               		.loc 1 264 9 view .LVU254
 1018 005a 91E0      		ldi r25,lo8(1)
 1019 005c E82E      		mov r14,r24
 1020 005e E926      		eor r14,r25
 1021               	.LVL94:
 1022               	.L67:
 268:quantum/action.c ****         /* Key and Mods */
 1023               		.loc 1 268 5 is_stmt 1 view .LVU255
 268:quantum/action.c ****         /* Key and Mods */
 1024               		.loc 1 268 24 is_stmt 0 view .LVU256
 1025 0060 A980      		ldd r10,Y+1
 1026 0062 A294      		swap r10
 1027 0064 9FE0      		ldi r25,lo8(15)
 1028 0066 A922      		and r10,r25
 268:quantum/action.c ****         /* Key and Mods */
 1029               		.loc 1 268 5 view .LVU257
 1030 0068 B12C      		mov r11,__zero_reg__
 1031 006a F501      		movw r30,r10
 1032 006c E050      		subi r30,lo8(-(gs(.L71)))
 1033 006e F040      		sbci r31,hi8(-(gs(.L71)))
 1034 0070 0C94 0000 		jmp __tablejump2__
 1035               		.section	.jumptables.gcc.process_action,"a",@progbits
 1036               		.p2align	1
 1037               	.L71:
 1038 0000 0000      		.word gs(.L79)
 1039 0002 0000      		.word gs(.L79)
 1040 0004 0000      		.word gs(.L78)
 1041 0006 0000      		.word gs(.L78)
 1042 0008 0000      		.word gs(.L77)
 1043 000a 0000      		.word gs(.L76)
 1044 000c 0000      		.word gs(.L69)
 1045 000e 0000      		.word gs(.L69)
 1046 0010 0000      		.word gs(.L75)
 1047 0012 0000      		.word gs(.L74)
 1048 0014 0000      		.word gs(.L73)
 1049 0016 0000      		.word gs(.L73)
 1050 0018 0000      		.word gs(.L72)
 1051 001a 0000      		.word gs(.L69)
 1052 001c 0000      		.word gs(.L69)
 1053 001e 0000      		.word gs(.L70)
 1054               		.section	.text.process_action
 1055               	.L79:
 1056               	.LBB55:
 272:quantum/action.c ****             if (event.pressed) {
 1057               		.loc 1 272 13 is_stmt 1 view .LVU258
 272:quantum/action.c ****             if (event.pressed) {
 1058               		.loc 1 272 70 is_stmt 0 view .LVU259
 1059 0074 0981      		ldd r16,Y+1
 1060               	.LVL95:
 272:quantum/action.c ****             if (event.pressed) {
 1061               		.loc 1 272 70 view .LVU260
 1062 0076 0F70      		andi r16,lo8(15)
 272:quantum/action.c ****             if (event.pressed) {
 1063               		.loc 1 272 44 view .LVU261
 1064 0078 F981      		ldd r31,Y+1
 1065 007a F07F      		andi r31,lo8(-16)
 272:quantum/action.c ****             if (event.pressed) {
 1066               		.loc 1 272 21 view .LVU262
 1067 007c 01F0      		breq .L80
 272:quantum/action.c ****             if (event.pressed) {
 1068               		.loc 1 272 21 discriminator 2 view .LVU263
 1069 007e 0295      		swap r16
 1070 0080 007F      		andi r16,lo8(-16)
 1071               	.L80:
 1072               	.LVL96:
 273:quantum/action.c ****                 if (mods) {
 1073               		.loc 1 273 13 is_stmt 1 discriminator 4 view .LVU264
 273:quantum/action.c ****                 if (mods) {
 1074               		.loc 1 273 16 is_stmt 0 discriminator 4 view .LVU265
 1075 0082 1123      		tst r17
 1076 0084 01F0      		breq .L81
 274:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1077               		.loc 1 274 17 is_stmt 1 view .LVU266
 274:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1078               		.loc 1 274 20 is_stmt 0 view .LVU267
 1079 0086 0023      		tst r16
 1080 0088 01F0      		breq .L177
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1081               		.loc 1 275 21 is_stmt 1 view .LVU268
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1082               		.loc 1 275 25 is_stmt 0 view .LVU269
 1083 008a 8D81      		ldd r24,Y+5
 1084 008c 805E      		subi r24,lo8(-(32))
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1085               		.loc 1 275 24 view .LVU270
 1086 008e 8830      		cpi r24,lo8(8)
 1087 0090 00F0      		brlo .L83
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1088               		.loc 1 275 49 discriminator 1 view .LVU271
 1089 0092 1D81      		ldd r17,Y+5
 1090               	.LVL97:
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1091               		.loc 1 275 49 discriminator 1 view .LVU272
 1092 0094 1111      		cpse r17,__zero_reg__
 1093 0096 00C0      		rjmp .L84
 1094               	.L83:
 279:quantum/action.c ****                     } else {
 1095               		.loc 1 279 25 is_stmt 1 view .LVU273
 1096 0098 802F      		mov r24,r16
 1097 009a 0E94 0000 		call add_mods
 1098               	.LVL98:
 1099               	.L85:
 283:quantum/action.c ****                 }
 1100               		.loc 1 283 21 view .LVU274
 1101 009e 0E94 0000 		call send_keyboard_report
 1102               	.LVL99:
 285:quantum/action.c ****             } else {
 1103               		.loc 1 285 17 view .LVU275
 1104               	.L177:
 285:quantum/action.c ****             } else {
 1105               		.loc 1 285 17 is_stmt 0 view .LVU276
 1106               	.LBE55:
 564:quantum/action.c ****                             register_code(action.layer_tap.code);
 1107               		.loc 1 564 75 is_stmt 1 view .LVU277
 565:quantum/action.c ****                         } else {
 1108               		.loc 1 565 29 view .LVU278
 1109 00a2 8D81      		ldd r24,Y+5
 1110 00a4 0E94 0000 		call register_code
 1111               	.LVL100:
 1112 00a8 00C0      		rjmp .L69
 1113               	.LVL101:
 1114               	.L84:
 1115               	.LBB56:
 281:quantum/action.c ****                     }
 1116               		.loc 1 281 25 view .LVU279
 1117 00aa 802F      		mov r24,r16
 1118 00ac 0E94 0000 		call add_weak_mods
 1119               	.LVL102:
 1120 00b0 00C0      		rjmp .L85
 1121               	.LVL103:
 1122               	.L81:
 287:quantum/action.c ****                 if (mods) {
 1123               		.loc 1 287 17 view .LVU280
 1124 00b2 8D81      		ldd r24,Y+5
 1125 00b4 0E94 0000 		call unregister_code
 1126               	.LVL104:
 288:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1127               		.loc 1 288 17 view .LVU281
 288:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1128               		.loc 1 288 20 is_stmt 0 view .LVU282
 1129 00b8 0023      		tst r16
 1130 00ba 01F0      		breq .L69
 289:quantum/action.c ****                         del_mods(mods);
 1131               		.loc 1 289 21 is_stmt 1 view .LVU283
 289:quantum/action.c ****                         del_mods(mods);
 1132               		.loc 1 289 25 is_stmt 0 view .LVU284
 1133 00bc 8D81      		ldd r24,Y+5
 1134 00be 805E      		subi r24,lo8(-(32))
 289:quantum/action.c ****                         del_mods(mods);
 1135               		.loc 1 289 24 view .LVU285
 1136 00c0 8830      		cpi r24,lo8(8)
 1137 00c2 00F0      		brlo .L87
 289:quantum/action.c ****                         del_mods(mods);
 1138               		.loc 1 289 49 discriminator 1 view .LVU286
 1139 00c4 1D81      		ldd r17,Y+5
 1140               	.LVL105:
 289:quantum/action.c ****                         del_mods(mods);
 1141               		.loc 1 289 49 discriminator 1 view .LVU287
 1142 00c6 1111      		cpse r17,__zero_reg__
 1143 00c8 00C0      		rjmp .L88
 1144               	.L87:
 290:quantum/action.c ****                     } else {
 1145               		.loc 1 290 25 is_stmt 1 view .LVU288
 1146 00ca 802F      		mov r24,r16
 1147 00cc 0E94 0000 		call del_mods
 1148               	.LVL106:
 1149               	.L89:
 294:quantum/action.c ****                 }
 1150               		.loc 1 294 21 view .LVU289
 1151 00d0 0E94 0000 		call send_keyboard_report
 1152               	.LVL107:
 1153               	.L69:
 294:quantum/action.c ****                 }
 1154               		.loc 1 294 21 is_stmt 0 view .LVU290
 1155               	.LBE56:
 679:quantum/action.c ****         case ACT_LAYER:
 1156               		.loc 1 679 5 is_stmt 1 view .LVU291
 1157 00d4 98E0      		ldi r25,8
 1158 00d6 A91A      		sub r10,r25
 1159 00d8 B108      		sbc r11,__zero_reg__
 1160 00da E4E0      		ldi r30,4
 1161 00dc AE16      		cp r10,r30
 1162 00de B104      		cpc r11,__zero_reg__
 1163 00e0 00F4      		brsh .L142
 686:quantum/action.c ****             break;
 1164               		.loc 1 686 13 view .LVU292
 1165 00e2 0E94 0000 		call host_keyboard_leds
 1166               	.LVL108:
 1167 00e6 0E94 0000 		call led_set
 1168               	.LVL109:
 687:quantum/action.c ****         default:
 1169               		.loc 1 687 13 view .LVU293
 1170               	.L142:
 732:quantum/action.c ****         record->event.pressed = false;
 1171               		.loc 1 732 5 view .LVU294
 732:quantum/action.c ****         record->event.pressed = false;
 1172               		.loc 1 732 8 is_stmt 0 view .LVU295
 1173 00ea EE20      		tst r14
 1174 00ec 01F4      		brne .+2
 1175 00ee 00C0      		rjmp .L66
 732:quantum/action.c ****         record->event.pressed = false;
 1176               		.loc 1 732 33 discriminator 1 view .LVU296
 1177 00f0 0E94 0000 		call get_oneshot_layer_state
 1178               	.LVL110:
 732:quantum/action.c ****         record->event.pressed = false;
 1179               		.loc 1 732 28 discriminator 1 view .LVU297
 1180 00f4 80FD      		sbrc r24,0
 1181 00f6 00C0      		rjmp .L66
 733:quantum/action.c ****         layer_on(get_oneshot_layer());
 1182               		.loc 1 733 9 is_stmt 1 view .LVU298
 733:quantum/action.c ****         layer_on(get_oneshot_layer());
 1183               		.loc 1 733 31 is_stmt 0 view .LVU299
 1184 00f8 F601      		movw r30,r12
 1185 00fa 1282      		std Z+2,__zero_reg__
 734:quantum/action.c ****         process_record(record);
 1186               		.loc 1 734 9 is_stmt 1 view .LVU300
 1187 00fc 0E94 0000 		call get_oneshot_layer
 1188               	.LVL111:
 1189 0100 0E94 0000 		call layer_on
 1190               	.LVL112:
 735:quantum/action.c ****         layer_off(get_oneshot_layer());
 1191               		.loc 1 735 9 view .LVU301
 1192 0104 C601      		movw r24,r12
 1193 0106 0E94 0000 		call process_record
 1194               	.LVL113:
 736:quantum/action.c ****     }
 1195               		.loc 1 736 9 view .LVU302
 1196 010a 0E94 0000 		call get_oneshot_layer
 1197               	.LVL114:
 1198               	/* epilogue start */
 739:quantum/action.c **** 
 1199               		.loc 1 739 1 is_stmt 0 view .LVU303
 1200 010e 0F90      		pop __tmp_reg__
 1201 0110 0F90      		pop __tmp_reg__
 1202 0112 0F90      		pop __tmp_reg__
 1203 0114 0F90      		pop __tmp_reg__
 1204 0116 0F90      		pop __tmp_reg__
 1205 0118 DF91      		pop r29
 1206 011a CF91      		pop r28
 1207 011c 1F91      		pop r17
 1208 011e 0F91      		pop r16
 1209 0120 FF90      		pop r15
 1210 0122 EF90      		pop r14
 1211               	.LVL115:
 739:quantum/action.c **** 
 1212               		.loc 1 739 1 view .LVU304
 1213 0124 DF90      		pop r13
 1214 0126 CF90      		pop r12
 1215               	.LVL116:
 739:quantum/action.c **** 
 1216               		.loc 1 739 1 view .LVU305
 1217 0128 BF90      		pop r11
 1218 012a AF90      		pop r10
 736:quantum/action.c ****     }
 1219               		.loc 1 736 9 view .LVU306
 1220 012c 0C94 0000 		jmp layer_off
 1221               	.LVL117:
 1222               	.L88:
 1223               	.LBB57:
 292:quantum/action.c ****                     }
 1224               		.loc 1 292 25 is_stmt 1 view .LVU307
 1225 0130 802F      		mov r24,r16
 1226 0132 0E94 0000 		call del_weak_mods
 1227               	.LVL118:
 1228 0136 00C0      		rjmp .L89
 1229               	.LVL119:
 1230               	.L78:
 292:quantum/action.c ****                     }
 1231               		.loc 1 292 25 is_stmt 0 view .LVU308
 1232               	.LBE57:
 1233               	.LBB58:
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1234               		.loc 1 301 13 is_stmt 1 view .LVU309
 1235               	.LBE58:
 1236               	.LBB61:
 272:quantum/action.c ****             if (event.pressed) {
 1237               		.loc 1 272 70 is_stmt 0 view .LVU310
 1238 0138 2981      		ldd r18,Y+1
 1239 013a 2F70      		andi r18,lo8(15)
 1240 013c F22E      		mov r15,r18
 1241               	.LBE61:
 1242               	.LBB62:
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1243               		.loc 1 301 44 view .LVU311
 1244 013e 3981      		ldd r19,Y+1
 1245 0140 307F      		andi r19,lo8(-16)
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1246               		.loc 1 301 21 view .LVU312
 1247 0142 3032      		cpi r19,lo8(32)
 1248 0144 01F0      		breq .L90
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1249               		.loc 1 301 21 discriminator 2 view .LVU313
 1250 0146 F294      		swap r15
 1251 0148 80EF      		ldi r24,lo8(-16)
 1252 014a F822      		and r15,r24
 1253               	.L90:
 1254               	.LVL120:
 302:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 1255               		.loc 1 302 13 is_stmt 1 discriminator 4 view .LVU314
 1256 014c 8D81      		ldd r24,Y+5
 1257 014e 8823      		tst r24
 1258 0150 01F0      		breq .L91
 1259 0152 8130      		cpi r24,lo8(1)
 1260 0154 01F0      		breq .L92
 357:quantum/action.c ****                         if (tap_count > 0) {
 1261               		.loc 1 357 21 view .LVU315
 357:quantum/action.c ****                         if (tap_count > 0) {
 1262               		.loc 1 357 24 is_stmt 0 view .LVU316
 1263 0156 1123      		tst r17
 1264 0158 01F0      		breq .L100
 358:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1265               		.loc 1 358 25 is_stmt 1 view .LVU317
 358:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1266               		.loc 1 358 28 is_stmt 0 view .LVU318
 1267 015a 0023      		tst r16
 1268 015c 01F0      		breq .L101
 360:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1269               		.loc 1 360 29 is_stmt 1 view .LVU319
 364:quantum/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1270               		.loc 1 364 33 is_stmt 0 view .LVU320
 1271 015e F601      		movw r30,r12
 1272 0160 8581      		ldd r24,Z+5
 360:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1273               		.loc 1 360 32 view .LVU321
 1274 0162 80FF      		sbrs r24,0
 1275 0164 00C0      		rjmp .L177
 365:quantum/action.c ****                                 // ad hoc: set 0 to cancel tap
 1276               		.loc 1 365 76 is_stmt 1 view .LVU322
 367:quantum/action.c ****                                 register_mods(mods);
 1277               		.loc 1 367 33 view .LVU323
 367:quantum/action.c ****                                 register_mods(mods);
 1278               		.loc 1 367 51 is_stmt 0 view .LVU324
 1279 0166 8F70      		andi r24,lo8(15)
 1280 0168 8583      		std Z+5,r24
 368:quantum/action.c ****                             } else
 1281               		.loc 1 368 33 is_stmt 1 view .LVU325
 1282 016a 00C0      		rjmp .L101
 1283               	.L91:
 306:quantum/action.c ****                         if (tap_count == 0) {
 1284               		.loc 1 306 21 view .LVU326
 306:quantum/action.c ****                         if (tap_count == 0) {
 1285               		.loc 1 306 24 is_stmt 0 view .LVU327
 1286 016c 1123      		tst r17
 1287 016e 01F0      		breq .L94
 307:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1288               		.loc 1 307 25 is_stmt 1 view .LVU328
 307:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1289               		.loc 1 307 28 is_stmt 0 view .LVU329
 1290 0170 0111      		cpse r16,__zero_reg__
 1291 0172 00C0      		rjmp .L95
 1292               	.L96:
 321:quantum/action.c ****                         }
 1293               		.loc 1 321 29 is_stmt 1 view .LVU330
 321:quantum/action.c ****                         }
 1294               		.loc 1 321 50 is_stmt 0 view .LVU331
 1295 0174 0E94 0000 		call get_oneshot_mods
 1296               	.LVL121:
 321:quantum/action.c ****                         }
 1297               		.loc 1 321 29 view .LVU332
 1298 0178 8F29      		or r24,r15
 1299               	.LVL122:
 1300               	.L176:
 321:quantum/action.c ****                         }
 1301               		.loc 1 321 29 view .LVU333
 1302               	.LBE62:
 491:quantum/action.c ****             } else {
 1303               		.loc 1 491 17 view .LVU334
 1304 017a 0E94 0000 		call register_mods
 1305               	.LVL123:
 1306 017e 00C0      		rjmp .L69
 1307               	.LVL124:
 1308               	.L95:
 1309               	.LBB63:
 310:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1310               		.loc 1 310 32 is_stmt 1 view .LVU335
 310:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1311               		.loc 1 310 35 is_stmt 0 view .LVU336
 1312 0180 0130      		cpi r16,lo8(1)
 1313 0182 01F4      		brne .L96
 311:quantum/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1314               		.loc 1 311 65 is_stmt 1 view .LVU337
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1315               		.loc 1 312 29 view .LVU338
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1316               		.loc 1 312 53 is_stmt 0 view .LVU339
 1317 0184 0E94 0000 		call get_oneshot_mods
 1318               	.LVL125:
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1319               		.loc 1 312 29 view .LVU340
 1320 0188 8F29      		or r24,r15
 1321 018a 0E94 0000 		call set_oneshot_mods
 1322               	.LVL126:
 1323 018e 00C0      		rjmp .L69
 1324               	.L94:
 324:quantum/action.c ****                             clear_oneshot_mods();
 1325               		.loc 1 324 25 is_stmt 1 view .LVU341
 324:quantum/action.c ****                             clear_oneshot_mods();
 1326               		.loc 1 324 28 is_stmt 0 view .LVU342
 1327 0190 0111      		cpse r16,__zero_reg__
 1328 0192 00C0      		rjmp .L97
 1329               	.L180:
 339:quantum/action.c ****                             unregister_mods(mods);
 1330               		.loc 1 339 29 is_stmt 1 view .LVU343
 1331 0194 0E94 0000 		call clear_oneshot_mods
 1332               	.LVL127:
 340:quantum/action.c ****                         }
 1333               		.loc 1 340 29 view .LVU344
 1334               	.L103:
 389:quantum/action.c ****                             unregister_mods(mods);
 1335               		.loc 1 389 67 view .LVU345
 390:quantum/action.c ****                         }
 1336               		.loc 1 390 29 view .LVU346
 1337 0198 8F2D      		mov r24,r15
 1338 019a 0E94 0000 		call unregister_mods
 1339               	.LVL128:
 1340 019e 00C0      		rjmp .L69
 1341               	.L97:
 327:quantum/action.c ****                             // Retain Oneshot mods
 1342               		.loc 1 327 32 view .LVU347
 327:quantum/action.c ****                             // Retain Oneshot mods
 1343               		.loc 1 327 35 is_stmt 0 view .LVU348
 1344 01a0 0130      		cpi r16,lo8(1)
 1345 01a2 01F4      		brne .+2
 1346 01a4 00C0      		rjmp .L69
 1347 01a6 00C0      		rjmp .L180
 1348               	.L92:
 346:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1349               		.loc 1 346 21 is_stmt 1 view .LVU349
 346:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1350               		.loc 1 346 24 is_stmt 0 view .LVU350
 1351 01a8 1123      		tst r17
 1352 01aa 01F0      		breq .L99
 347:quantum/action.c ****                             register_mods(mods);
 1353               		.loc 1 347 25 is_stmt 1 view .LVU351
 347:quantum/action.c ****                             register_mods(mods);
 1354               		.loc 1 347 28 is_stmt 0 view .LVU352
 1355 01ac 0630      		cpi r16,lo8(6)
 1356 01ae 00F0      		brlo .+2
 1357 01b0 00C0      		rjmp .L69
 1358               	.L101:
 376:quantum/action.c ****                             register_mods(mods);
 1359               		.loc 1 376 67 is_stmt 1 view .LVU353
 377:quantum/action.c ****                         }
 1360               		.loc 1 377 29 view .LVU354
 1361 01b2 8F2D      		mov r24,r15
 1362 01b4 00C0      		rjmp .L176
 1363               	.L99:
 351:quantum/action.c ****                             unregister_mods(mods);
 1364               		.loc 1 351 25 view .LVU355
 351:quantum/action.c ****                             unregister_mods(mods);
 1365               		.loc 1 351 28 is_stmt 0 view .LVU356
 1366 01b6 0530      		cpi r16,lo8(5)
 1367 01b8 00F0      		brlo .+2
 1368 01ba 00C0      		rjmp .L69
 1369 01bc 00C0      		rjmp .L103
 1370               	.L100:
 380:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1371               		.loc 1 380 25 is_stmt 1 view .LVU357
 380:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1372               		.loc 1 380 28 is_stmt 0 view .LVU358
 1373 01be 0023      		tst r16
 1374 01c0 01F0      		breq .L103
 381:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1375               		.loc 1 381 71 is_stmt 1 view .LVU359
 382:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1376               		.loc 1 382 29 view .LVU360
 382:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1377               		.loc 1 382 32 is_stmt 0 view .LVU361
 1378 01c2 0D81      		ldd r16,Y+5
 1379               	.LVL129:
 382:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1380               		.loc 1 382 32 view .LVU362
 1381 01c4 0933      		cpi r16,lo8(57)
 1382 01c6 01F4      		brne .L141
 383:quantum/action.c ****                             } else {
 1383               		.loc 1 383 33 is_stmt 1 view .LVU363
 383:quantum/action.c ****                             } else {
 1384               		.loc 1 383 33 view .LVU364
 383:quantum/action.c ****                             } else {
 1385               		.loc 1 383 33 view .LVU365
 1386               	.LVL130:
 1387               	.LBB59:
 1388               	.LBI59:
 166:/usr/avr/include/util/delay.h **** {
 1389               		.loc 3 166 1 view .LVU366
 1390               	.LBB60:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1391               		.loc 3 168 2 view .LVU367
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1392               		.loc 3 172 2 view .LVU368
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1393               		.loc 3 173 2 view .LVU369
 174:/usr/avr/include/util/delay.h **** 
 1394               		.loc 3 174 2 view .LVU370
 184:/usr/avr/include/util/delay.h **** 	#endif
 1395               		.loc 3 184 3 view .LVU371
 1396               		.loc 3 187 2 view .LVU372
 1397 01c8 1FEF      		ldi r17,lo8(255999)
 1398 01ca 27EE      		ldi r18,hi8(255999)
 1399 01cc 33E0      		ldi r19,hlo8(255999)
 1400 01ce 1150      	1:	subi r17,1
 1401 01d0 2040      		sbci r18,0
 1402 01d2 3040      		sbci r19,0
 1403 01d4 01F4      		brne 1b
 1404               	.LVL131:
 1405               	.L181:
 1406               		.loc 3 187 2 is_stmt 0 view .LVU373
 1407               	.LBE60:
 1408               	.LBE59:
 1409               	.LBE63:
 1410               	.LBB64:
 1411               	.LBB65:
 1412 01d6 00C0      		rjmp .
 1413 01d8 0000      		nop
 1414               	.L141:
 1415               	.LBE65:
 1416               	.LBE64:
 576:quantum/action.c ****                             }
 1417               		.loc 1 576 33 is_stmt 1 discriminator 7 view .LVU374
 578:quantum/action.c ****                         } else {
 1418               		.loc 1 578 29 discriminator 7 view .LVU375
 1419 01da 8D81      		ldd r24,Y+5
 1420 01dc 0E94 0000 		call unregister_code
 1421               	.LVL132:
 1422 01e0 00C0      		rjmp .L69
 1423               	.LVL133:
 1424               	.L77:
 400:quantum/action.c ****                 case PAGE_SYSTEM:
 1425               		.loc 1 400 13 view .LVU376
 400:quantum/action.c ****                 case PAGE_SYSTEM:
 1426               		.loc 1 400 33 is_stmt 0 view .LVU377
 1427 01e2 8981      		ldd r24,Y+1
 1428 01e4 8695      		lsr r24
 1429 01e6 8695      		lsr r24
 1430 01e8 8370      		andi r24,lo8(3)
 1431 01ea 01F0      		breq .L106
 1432 01ec 8130      		cpi r24,lo8(1)
 1433 01ee 01F0      		breq .+2
 1434 01f0 00C0      		rjmp .L69
 409:quantum/action.c ****                         host_consumer_send(action.usage.code);
 1435               		.loc 1 409 21 is_stmt 1 view .LVU378
 410:quantum/action.c ****                     } else {
 1436               		.loc 1 410 25 is_stmt 0 view .LVU379
 1437 01f2 8D81      		ldd r24,Y+5
 1438 01f4 9981      		ldd r25,Y+1
 1439 01f6 9370      		andi r25,lo8(3)
 409:quantum/action.c ****                         host_consumer_send(action.usage.code);
 1440               		.loc 1 409 24 view .LVU380
 1441 01f8 1111      		cpse r17,__zero_reg__
 1442 01fa 00C0      		rjmp .L179
 412:quantum/action.c ****                     }
 1443               		.loc 1 412 25 is_stmt 1 view .LVU381
 1444 01fc 90E0      		ldi r25,0
 1445 01fe 80E0      		ldi r24,0
 1446               	.L179:
 1447 0200 0E94 0000 		call host_consumer_send
 1448               	.LVL134:
 1449 0204 00C0      		rjmp .L69
 1450               	.L106:
 402:quantum/action.c ****                         host_system_send(action.usage.code);
 1451               		.loc 1 402 21 view .LVU382
 403:quantum/action.c ****                     } else {
 1452               		.loc 1 403 25 is_stmt 0 view .LVU383
 1453 0206 8D81      		ldd r24,Y+5
 1454 0208 9981      		ldd r25,Y+1
 1455 020a 9370      		andi r25,lo8(3)
 402:quantum/action.c ****                         host_system_send(action.usage.code);
 1456               		.loc 1 402 24 view .LVU384
 1457 020c 1111      		cpse r17,__zero_reg__
 1458 020e 00C0      		rjmp .L174
 405:quantum/action.c ****                     }
 1459               		.loc 1 405 25 is_stmt 1 view .LVU385
 1460 0210 90E0      		ldi r25,0
 1461 0212 80E0      		ldi r24,0
 1462               	.L174:
 1463 0214 0E94 0000 		call host_system_send
 1464               	.LVL135:
 1465 0218 00C0      		rjmp .L69
 1466               	.L76:
 421:quantum/action.c ****                 mousekey_on(action.key.code);
 1467               		.loc 1 421 13 view .LVU386
 422:quantum/action.c ****             } else {
 1468               		.loc 1 422 17 is_stmt 0 view .LVU387
 1469 021a 8D81      		ldd r24,Y+5
 421:quantum/action.c ****                 mousekey_on(action.key.code);
 1470               		.loc 1 421 16 view .LVU388
 1471 021c 1123      		tst r17
 1472 021e 01F0      		breq .L110
 422:quantum/action.c ****             } else {
 1473               		.loc 1 422 17 is_stmt 1 view .LVU389
 1474 0220 0E94 0000 		call mousekey_on
 1475               	.LVL136:
 1476               	.L111:
 426:quantum/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 1477               		.loc 1 426 13 view .LVU390
 437:quantum/action.c ****                     break;
 1478               		.loc 1 437 21 view .LVU391
 1479 0224 0E94 0000 		call mousekey_send
 1480               	.LVL137:
 438:quantum/action.c ****             }
 1481               		.loc 1 438 21 view .LVU392
 1482 0228 00C0      		rjmp .L69
 1483               	.L110:
 424:quantum/action.c ****             }
 1484               		.loc 1 424 17 view .LVU393
 1485 022a 0E94 0000 		call mousekey_off
 1486               	.LVL138:
 1487 022e 00C0      		rjmp .L111
 1488               	.L75:
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1489               		.loc 1 444 13 view .LVU394
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1490               		.loc 1 444 39 is_stmt 0 view .LVU395
 1491 0230 8981      		ldd r24,Y+1
 1492 0232 8370      		andi r24,lo8(3)
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1493               		.loc 1 444 16 view .LVU396
 1494 0234 01F0      		breq .+2
 1495 0236 00C0      		rjmp .L112
 446:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1496               		.loc 1 446 17 is_stmt 1 view .LVU397
 446:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1497               		.loc 1 446 20 is_stmt 0 view .LVU398
 1498 0238 1111      		cpse r17,__zero_reg__
 1499 023a 00C0      		rjmp .L69
 1500               	.LBB67:
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1501               		.loc 1 447 21 is_stmt 1 view .LVU399
 1502               	.LVL139:
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1503               		.loc 1 448 21 view .LVU400
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1504               		.loc 1 447 61 is_stmt 0 view .LVU401
 1505 023c 2D81      		ldd r18,Y+5
 1506 023e 2295      		swap r18
 1507 0240 2695      		lsr r18
 1508 0242 2770      		andi r18,lo8(7)
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1509               		.loc 1 447 35 view .LVU402
 1510 0244 220F      		lsl r18
 1511 0246 220F      		lsl r18
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1512               		.loc 1 448 77 view .LVU403
 1513 0248 4D81      		ldd r20,Y+5
 1514 024a 4F70      		andi r20,lo8(15)
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1515               		.loc 1 448 44 view .LVU404
 1516 024c 50E0      		ldi r21,0
 1517 024e 70E0      		ldi r23,0
 1518 0250 60E0      		ldi r22,0
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1519               		.loc 1 448 35 view .LVU405
 1520 0252 022E      		mov r0,r18
 1521 0254 00C0      		rjmp 2f
 1522               		1:
 1523 0256 440F      		lsl r20
 1524 0258 551F      		rol r21
 1525 025a 661F      		rol r22
 1526 025c 771F      		rol r23
 1527               		2:
 1528 025e 0A94      		dec r0
 1529 0260 02F4      		brpl 1b
 1530               	.LVL140:
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1531               		.loc 1 449 21 is_stmt 1 view .LVU406
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1532               		.loc 1 449 104 is_stmt 0 view .LVU407
 1533 0262 0D81      		ldd r16,Y+5
 1534               	.LVL141:
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1535               		.loc 1 449 104 view .LVU408
 1536 0264 80E0      		ldi r24,0
 1537 0266 90E0      		ldi r25,0
 1538 0268 DC01      		movw r26,r24
 1539 026a 04FF      		sbrs r16,4
 1540 026c 00C0      		rjmp .L113
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1541               		.loc 1 449 94 discriminator 1 view .LVU409
 1542 026e 8FE0      		ldi r24,lo8(15)
 1543 0270 90E0      		ldi r25,0
 1544 0272 A0E0      		ldi r26,0
 1545 0274 B0E0      		ldi r27,0
 1546 0276 00C0      		rjmp 2f
 1547               		1:
 1548 0278 880F      		lsl r24
 1549 027a 991F      		rol r25
 1550 027c AA1F      		rol r26
 1551 027e BB1F      		rol r27
 1552               		2:
 1553 0280 2A95      		dec r18
 1554 0282 02F4      		brpl 1b
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1555               		.loc 1 449 104 discriminator 1 view .LVU410
 1556 0284 8095      		com r24
 1557 0286 9095      		com r25
 1558 0288 A095      		com r26
 1559 028a B095      		com r27
 1560               	.L113:
 1561               	.LVL142:
 450:quantum/action.c ****                         case OP_BIT_AND:
 1562               		.loc 1 450 21 is_stmt 1 discriminator 4 view .LVU411
 450:quantum/action.c ****                         case OP_BIT_AND:
 1563               		.loc 1 450 47 is_stmt 0 discriminator 4 view .LVU412
 1564 028c 1981      		ldd r17,Y+1
 1565               	.LVL143:
 450:quantum/action.c ****                         case OP_BIT_AND:
 1566               		.loc 1 450 47 discriminator 4 view .LVU413
 1567 028e 1695      		lsr r17
 1568 0290 1695      		lsr r17
 1569 0292 1370      		andi r17,lo8(3)
 1570 0294 1D83      		std Y+5,r17
 1571               	.LVL144:
 452:quantum/action.c ****                             break;
 1572               		.loc 1 452 29 discriminator 4 view .LVU414
 1573 0296 8C01      		movw r16,r24
 1574               	.LVL145:
 452:quantum/action.c ****                             break;
 1575               		.loc 1 452 29 discriminator 4 view .LVU415
 1576 0298 9D01      		movw r18,r26
 1577 029a 042B      		or r16,r20
 1578 029c 152B      		or r17,r21
 1579 029e 262B      		or r18,r22
 1580 02a0 372B      		or r19,r23
 1581 02a2 0983      		std Y+1,r16
 1582 02a4 1A83      		std Y+2,r17
 1583 02a6 2B83      		std Y+3,r18
 1584 02a8 3C83      		std Y+4,r19
 1585 02aa 1D81      		ldd r17,Y+5
 1586 02ac 6981      		ldd r22,Y+1
 1587 02ae 7A81      		ldd r23,Y+2
 1588 02b0 8B81      		ldd r24,Y+3
 1589 02b2 9C81      		ldd r25,Y+4
 1590 02b4 1230      		cpi r17,lo8(2)
 1591 02b6 01F0      		breq .L114
 1592 02b8 1330      		cpi r17,lo8(3)
 1593 02ba 01F0      		breq .L115
 1594 02bc 1130      		cpi r17,lo8(1)
 1595 02be 01F0      		breq .L116
 452:quantum/action.c ****                             break;
 1596               		.loc 1 452 29 is_stmt 1 view .LVU416
 1597 02c0 0E94 0000 		call default_layer_and
 1598               	.LVL146:
 453:quantum/action.c ****                         case OP_BIT_OR:
 1599               		.loc 1 453 29 view .LVU417
 1600 02c4 00C0      		rjmp .L69
 1601               	.LVL147:
 1602               	.L116:
 455:quantum/action.c ****                             break;
 1603               		.loc 1 455 29 view .LVU418
 1604 02c6 0E94 0000 		call default_layer_or
 1605               	.LVL148:
 456:quantum/action.c ****                         case OP_BIT_XOR:
 1606               		.loc 1 456 29 view .LVU419
 1607 02ca 00C0      		rjmp .L69
 1608               	.LVL149:
 1609               	.L114:
 458:quantum/action.c ****                             break;
 1610               		.loc 1 458 29 view .LVU420
 1611 02cc 0E94 0000 		call default_layer_xor
 1612               	.LVL150:
 459:quantum/action.c ****                         case OP_BIT_SET:
 1613               		.loc 1 459 29 view .LVU421
 1614 02d0 00C0      		rjmp .L69
 1615               	.LVL151:
 1616               	.L115:
 461:quantum/action.c ****                             break;
 1617               		.loc 1 461 29 view .LVU422
 1618 02d2 0E94 0000 		call default_layer_set
 1619               	.LVL152:
 462:quantum/action.c ****                     }
 1620               		.loc 1 462 29 view .LVU423
 1621 02d6 00C0      		rjmp .L69
 1622               	.LVL153:
 1623               	.L112:
 462:quantum/action.c ****                     }
 1624               		.loc 1 462 29 is_stmt 0 view .LVU424
 1625               	.LBE67:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1626               		.loc 1 467 17 is_stmt 1 view .LVU425
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1627               		.loc 1 467 21 is_stmt 0 view .LVU426
 1628 02d8 1123      		tst r17
 1629 02da 01F4      		brne .+2
 1630 02dc 00C0      		rjmp .L117
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1631               		.loc 1 467 20 discriminator 1 view .LVU427
 1632 02de 0981      		ldd r16,Y+1
 1633               	.LVL154:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1634               		.loc 1 467 20 discriminator 1 view .LVU428
 1635 02e0 00FF      		sbrs r16,0
 1636 02e2 00C0      		rjmp .L69
 1637               	.LVL155:
 1638               	.L118:
 1639               	.LBB68:
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1640               		.loc 1 468 21 is_stmt 1 view .LVU429
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1641               		.loc 1 469 21 view .LVU430
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1642               		.loc 1 468 61 is_stmt 0 view .LVU431
 1643 02e4 2D81      		ldd r18,Y+5
 1644 02e6 2295      		swap r18
 1645 02e8 2695      		lsr r18
 1646 02ea 2770      		andi r18,lo8(7)
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1647               		.loc 1 468 35 view .LVU432
 1648 02ec 220F      		lsl r18
 1649 02ee 220F      		lsl r18
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1650               		.loc 1 469 77 view .LVU433
 1651 02f0 4D81      		ldd r20,Y+5
 1652 02f2 4F70      		andi r20,lo8(15)
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1653               		.loc 1 469 44 view .LVU434
 1654 02f4 50E0      		ldi r21,0
 1655 02f6 70E0      		ldi r23,0
 1656 02f8 60E0      		ldi r22,0
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1657               		.loc 1 469 35 view .LVU435
 1658 02fa 022E      		mov r0,r18
 1659 02fc 00C0      		rjmp 2f
 1660               		1:
 1661 02fe 440F      		lsl r20
 1662 0300 551F      		rol r21
 1663 0302 661F      		rol r22
 1664 0304 771F      		rol r23
 1665               		2:
 1666 0306 0A94      		dec r0
 1667 0308 02F4      		brpl 1b
 1668               	.LVL156:
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1669               		.loc 1 470 21 is_stmt 1 view .LVU436
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1670               		.loc 1 470 104 is_stmt 0 view .LVU437
 1671 030a 0D81      		ldd r16,Y+5
 1672 030c 80E0      		ldi r24,0
 1673 030e 90E0      		ldi r25,0
 1674 0310 DC01      		movw r26,r24
 1675 0312 04FF      		sbrs r16,4
 1676 0314 00C0      		rjmp .L119
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1677               		.loc 1 470 94 discriminator 1 view .LVU438
 1678 0316 8FE0      		ldi r24,lo8(15)
 1679 0318 90E0      		ldi r25,0
 1680 031a A0E0      		ldi r26,0
 1681 031c B0E0      		ldi r27,0
 1682 031e 00C0      		rjmp 2f
 1683               		1:
 1684 0320 880F      		lsl r24
 1685 0322 991F      		rol r25
 1686 0324 AA1F      		rol r26
 1687 0326 BB1F      		rol r27
 1688               		2:
 1689 0328 2A95      		dec r18
 1690 032a 02F4      		brpl 1b
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1691               		.loc 1 470 104 discriminator 1 view .LVU439
 1692 032c 8095      		com r24
 1693 032e 9095      		com r25
 1694 0330 A095      		com r26
 1695 0332 B095      		com r27
 1696               	.L119:
 1697               	.LVL157:
 471:quantum/action.c ****                         case OP_BIT_AND:
 1698               		.loc 1 471 21 is_stmt 1 discriminator 4 view .LVU440
 471:quantum/action.c ****                         case OP_BIT_AND:
 1699               		.loc 1 471 47 is_stmt 0 discriminator 4 view .LVU441
 1700 0334 1981      		ldd r17,Y+1
 1701 0336 1695      		lsr r17
 1702 0338 1695      		lsr r17
 1703 033a 1370      		andi r17,lo8(3)
 1704 033c 1D83      		std Y+5,r17
 1705               	.LVL158:
 473:quantum/action.c ****                             break;
 1706               		.loc 1 473 29 discriminator 4 view .LVU442
 1707 033e 8C01      		movw r16,r24
 1708               	.LVL159:
 473:quantum/action.c ****                             break;
 1709               		.loc 1 473 29 discriminator 4 view .LVU443
 1710 0340 9D01      		movw r18,r26
 1711 0342 042B      		or r16,r20
 1712 0344 152B      		or r17,r21
 1713 0346 262B      		or r18,r22
 1714 0348 372B      		or r19,r23
 1715 034a 0983      		std Y+1,r16
 1716 034c 1A83      		std Y+2,r17
 1717 034e 2B83      		std Y+3,r18
 1718 0350 3C83      		std Y+4,r19
 1719 0352 1D81      		ldd r17,Y+5
 1720 0354 6981      		ldd r22,Y+1
 1721 0356 7A81      		ldd r23,Y+2
 1722 0358 8B81      		ldd r24,Y+3
 1723 035a 9C81      		ldd r25,Y+4
 1724 035c 1230      		cpi r17,lo8(2)
 1725 035e 01F0      		breq .L120
 1726 0360 1330      		cpi r17,lo8(3)
 1727 0362 01F0      		breq .L121
 1728 0364 1130      		cpi r17,lo8(1)
 1729 0366 01F0      		breq .L122
 473:quantum/action.c ****                             break;
 1730               		.loc 1 473 29 is_stmt 1 view .LVU444
 1731 0368 0E94 0000 		call layer_and
 1732               	.LVL160:
 474:quantum/action.c ****                         case OP_BIT_OR:
 1733               		.loc 1 474 29 view .LVU445
 1734 036c 00C0      		rjmp .L69
 1735               	.LVL161:
 1736               	.L117:
 474:quantum/action.c ****                         case OP_BIT_OR:
 1737               		.loc 1 474 29 is_stmt 0 view .LVU446
 1738               	.LBE68:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1739               		.loc 1 467 20 discriminator 2 view .LVU447
 1740 036e 1981      		ldd r17,Y+1
 1741               	.LVL162:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1742               		.loc 1 467 20 discriminator 2 view .LVU448
 1743 0370 11FF      		sbrs r17,1
 1744 0372 00C0      		rjmp .L69
 1745 0374 00C0      		rjmp .L118
 1746               	.LVL163:
 1747               	.L122:
 1748               	.LBB69:
 476:quantum/action.c ****                             break;
 1749               		.loc 1 476 29 is_stmt 1 view .LVU449
 1750 0376 0E94 0000 		call layer_or
 1751               	.LVL164:
 477:quantum/action.c ****                         case OP_BIT_XOR:
 1752               		.loc 1 477 29 view .LVU450
 1753 037a 00C0      		rjmp .L69
 1754               	.LVL165:
 1755               	.L120:
 479:quantum/action.c ****                             break;
 1756               		.loc 1 479 29 view .LVU451
 1757 037c 0E94 0000 		call layer_xor
 1758               	.LVL166:
 480:quantum/action.c ****                         case OP_BIT_SET:
 1759               		.loc 1 480 29 view .LVU452
 1760 0380 00C0      		rjmp .L69
 1761               	.LVL167:
 1762               	.L121:
 482:quantum/action.c ****                             break;
 1763               		.loc 1 482 29 view .LVU453
 1764 0382 0E94 0000 		call layer_state_set
 1765               	.LVL168:
 483:quantum/action.c ****                     }
 1766               		.loc 1 483 29 view .LVU454
 1767 0386 00C0      		rjmp .L69
 1768               	.LVL169:
 1769               	.L74:
 483:quantum/action.c ****                     }
 1770               		.loc 1 483 29 is_stmt 0 view .LVU455
 1771               	.LBE69:
 489:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1772               		.loc 1 489 13 is_stmt 1 view .LVU456
 1773               	.LBB70:
 272:quantum/action.c ****             if (event.pressed) {
 1774               		.loc 1 272 70 is_stmt 0 view .LVU457
 1775 0388 0981      		ldd r16,Y+1
 1776               	.LVL170:
 272:quantum/action.c ****             if (event.pressed) {
 1777               		.loc 1 272 70 view .LVU458
 1778 038a 0F70      		andi r16,lo8(15)
 1779 038c 0983      		std Y+1,r16
 1780               	.LBE70:
 489:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1781               		.loc 1 489 16 view .LVU459
 1782 038e 1123      		tst r17
 1783 0390 01F0      		breq .L123
 490:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 1784               		.loc 1 490 17 is_stmt 1 view .LVU460
 1785 0392 802F      		mov r24,r16
 1786 0394 0E94 0000 		call layer_on
 1787               	.LVL171:
 491:quantum/action.c ****             } else {
 1788               		.loc 1 491 17 view .LVU461
 1789 0398 8D81      		ldd r24,Y+5
 1790 039a 00C0      		rjmp .L176
 1791               	.L123:
 493:quantum/action.c ****                 layer_off(action.layer_mods.layer);
 1792               		.loc 1 493 17 view .LVU462
 1793 039c 8D81      		ldd r24,Y+5
 1794 039e 0E94 0000 		call unregister_mods
 1795               	.LVL172:
 494:quantum/action.c ****             }
 1796               		.loc 1 494 17 view .LVU463
 1797 03a2 8981      		ldd r24,Y+1
 1798               	.L178:
 581:quantum/action.c ****                         }
 1799               		.loc 1 581 29 is_stmt 0 view .LVU464
 1800 03a4 0E94 0000 		call layer_off
 1801               	.LVL173:
 1802 03a8 00C0      		rjmp .L69
 1803               	.LVL174:
 1804               	.L73:
 500:quantum/action.c ****                 case OP_TAP_TOGGLE:
 1805               		.loc 1 500 13 is_stmt 1 view .LVU465
 1806 03aa 2D81      		ldd r18,Y+5
 1807 03ac 223F      		cpi r18,lo8(-14)
 1808 03ae 01F0      		breq .L124
 1809 03b0 00F4      		brsh .L125
 1810 03b2 203F      		cpi r18,lo8(-16)
 1811 03b4 01F0      		breq .L126
 1812 03b6 213F      		cpi r18,lo8(-15)
 1813 03b8 01F0      		breq .L127
 1814               	.L128:
 562:quantum/action.c ****                         if (tap_count > 0) {
 1815               		.loc 1 562 21 view .LVU466
 562:quantum/action.c ****                         if (tap_count > 0) {
 1816               		.loc 1 562 24 is_stmt 0 view .LVU467
 1817 03ba 1123      		tst r17
 1818 03bc 01F4      		brne .+2
 1819 03be 00C0      		rjmp .L137
 563:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1820               		.loc 1 563 25 is_stmt 1 view .LVU468
 563:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1821               		.loc 1 563 28 is_stmt 0 view .LVU469
 1822 03c0 0111      		cpse r16,__zero_reg__
 1823 03c2 00C0      		rjmp .L177
 567:quantum/action.c ****                             layer_on(action.layer_tap.val);
 1824               		.loc 1 567 76 is_stmt 1 view .LVU470
 568:quantum/action.c ****                         }
 1825               		.loc 1 568 29 view .LVU471
 1826 03c4 8981      		ldd r24,Y+1
 1827 03c6 8F71      		andi r24,lo8(31)
 1828 03c8 00C0      		rjmp .L175
 1829               	.L125:
 1830 03ca 3D81      		ldd r19,Y+5
 1831 03cc 333F      		cpi r19,lo8(-13)
 1832 03ce 01F0      		breq .L129
 1833 03d0 343F      		cpi r19,lo8(-12)
 1834 03d2 01F4      		brne .L128
 548:quantum/action.c ****                         layer_on(action.layer_tap.val);
 1835               		.loc 1 548 21 view .LVU472
 548:quantum/action.c ****                         layer_on(action.layer_tap.val);
 1836               		.loc 1 548 24 is_stmt 0 view .LVU473
 1837 03d4 1123      		tst r17
 1838 03d6 01F0      		breq .L136
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1839               		.loc 1 549 25 is_stmt 1 view .LVU474
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1840               		.loc 1 549 50 is_stmt 0 view .LVU475
 1841 03d8 0981      		ldd r16,Y+1
 1842               	.LVL175:
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1843               		.loc 1 549 50 view .LVU476
 1844 03da 0F71      		andi r16,lo8(31)
 1845 03dc 0983      		std Y+1,r16
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1846               		.loc 1 549 25 view .LVU477
 1847 03de 802F      		mov r24,r16
 1848 03e0 0E94 0000 		call layer_on
 1849               	.LVL176:
 550:quantum/action.c ****                     } else {
 1850               		.loc 1 550 25 is_stmt 1 view .LVU478
 1851 03e4 63E0      		ldi r22,lo8(3)
 1852 03e6 8981      		ldd r24,Y+1
 1853 03e8 0E94 0000 		call set_oneshot_layer
 1854               	.LVL177:
 1855 03ec 00C0      		rjmp .L69
 1856               	.LVL178:
 1857               	.L126:
 503:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1858               		.loc 1 503 21 view .LVU479
 503:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1859               		.loc 1 503 24 is_stmt 0 view .LVU480
 1860 03ee 1123      		tst r17
 1861 03f0 01F0      		breq .L131
 504:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1862               		.loc 1 504 25 is_stmt 1 view .LVU481
 504:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1863               		.loc 1 504 28 is_stmt 0 view .LVU482
 1864 03f2 0530      		cpi r16,lo8(5)
 1865 03f4 00F0      		brlo .+2
 1866 03f6 00C0      		rjmp .L69
 1867               	.L132:
 505:quantum/action.c ****                         }
 1868               		.loc 1 505 29 is_stmt 1 view .LVU483
 1869 03f8 8981      		ldd r24,Y+1
 1870 03fa 8F71      		andi r24,lo8(31)
 1871 03fc 0E94 0000 		call layer_invert
 1872               	.LVL179:
 1873 0400 00C0      		rjmp .L69
 1874               	.L131:
 508:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1875               		.loc 1 508 25 view .LVU484
 508:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1876               		.loc 1 508 28 is_stmt 0 view .LVU485
 1877 0402 0630      		cpi r16,lo8(6)
 1878 0404 00F0      		brlo .+2
 1879 0406 00C0      		rjmp .L69
 1880 0408 00C0      		rjmp .L132
 1881               	.L127:
 514:quantum/action.c ****                     break;
 1882               		.loc 1 514 21 is_stmt 1 view .LVU486
 505:quantum/action.c ****                         }
 1883               		.loc 1 505 58 is_stmt 0 view .LVU487
 1884 040a 8981      		ldd r24,Y+1
 1885 040c 8F71      		andi r24,lo8(31)
 514:quantum/action.c ****                     break;
 1886               		.loc 1 514 68 view .LVU488
 1887 040e 1123      		tst r17
 1888 0410 01F0      		breq .L178
 1889               	.L175:
 568:quantum/action.c ****                         }
 1890               		.loc 1 568 29 view .LVU489
 1891 0412 0E94 0000 		call layer_on
 1892               	.LVL180:
 1893 0416 00C0      		rjmp .L69
 1894               	.L124:
 517:quantum/action.c ****                     break;
 1895               		.loc 1 517 21 is_stmt 1 view .LVU490
 505:quantum/action.c ****                         }
 1896               		.loc 1 505 58 is_stmt 0 view .LVU491
 1897 0418 8981      		ldd r24,Y+1
 1898 041a 8F71      		andi r24,lo8(31)
 517:quantum/action.c ****                     break;
 1899               		.loc 1 517 69 view .LVU492
 1900 041c 1123      		tst r17
 1901 041e 01F0      		breq .L175
 1902 0420 00C0      		rjmp .L178
 1903               	.L129:
 520:quantum/action.c ****                     break;
 1904               		.loc 1 520 21 is_stmt 1 view .LVU493
 520:quantum/action.c ****                     break;
 1905               		.loc 1 520 70 is_stmt 0 view .LVU494
 1906 0422 1123      		tst r17
 1907 0424 01F0      		breq .L135
 520:quantum/action.c ****                     break;
 1908               		.loc 1 520 37 discriminator 1 view .LVU495
 1909 0426 8981      		ldd r24,Y+1
 1910 0428 8F71      		andi r24,lo8(31)
 1911 042a 0E94 0000 		call layer_move
 1912               	.LVL181:
 1913 042e 00C0      		rjmp .L69
 1914               	.L135:
 520:quantum/action.c ****                     break;
 1915               		.loc 1 520 72 discriminator 2 view .LVU496
 1916 0430 0E94 0000 		call layer_clear
 1917               	.LVL182:
 1918 0434 00C0      		rjmp .L69
 1919               	.L136:
 552:quantum/action.c ****                         if (tap_count > 1) {
 1920               		.loc 1 552 25 is_stmt 1 view .LVU497
 1921 0436 81E0      		ldi r24,lo8(1)
 1922 0438 0E94 0000 		call clear_oneshot_layer_state
 1923               	.LVL183:
 553:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1924               		.loc 1 553 25 view .LVU498
 553:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1925               		.loc 1 553 28 is_stmt 0 view .LVU499
 1926 043c 0230      		cpi r16,lo8(2)
 1927 043e 00F4      		brsh .+2
 1928 0440 00C0      		rjmp .L69
 554:quantum/action.c ****                         }
 1929               		.loc 1 554 29 is_stmt 1 view .LVU500
 1930 0442 82E0      		ldi r24,lo8(2)
 1931 0444 0E94 0000 		call clear_oneshot_layer_state
 1932               	.LVL184:
 1933 0448 00C0      		rjmp .L69
 1934               	.L137:
 571:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1935               		.loc 1 571 25 view .LVU501
 571:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1936               		.loc 1 571 28 is_stmt 0 view .LVU502
 1937 044a 0023      		tst r16
 1938 044c 01F0      		breq .L139
 572:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1939               		.loc 1 572 77 is_stmt 1 view .LVU503
 573:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1940               		.loc 1 573 29 view .LVU504
 573:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1941               		.loc 1 573 32 is_stmt 0 view .LVU505
 1942 044e 1D81      		ldd r17,Y+5
 1943               	.LVL185:
 573:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1944               		.loc 1 573 32 view .LVU506
 1945 0450 1933      		cpi r17,lo8(57)
 1946 0452 01F0      		breq .+2
 1947 0454 00C0      		rjmp .L141
 574:quantum/action.c ****                             } else {
 1948               		.loc 1 574 33 is_stmt 1 view .LVU507
 574:quantum/action.c ****                             } else {
 1949               		.loc 1 574 33 view .LVU508
 574:quantum/action.c ****                             } else {
 1950               		.loc 1 574 33 view .LVU509
 1951               	.LVL186:
 1952               	.LBB71:
 1953               	.LBI64:
 166:/usr/avr/include/util/delay.h **** {
 1954               		.loc 3 166 1 view .LVU510
 1955               	.LBB66:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1956               		.loc 3 168 2 view .LVU511
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1957               		.loc 3 172 2 view .LVU512
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1958               		.loc 3 173 2 view .LVU513
 174:/usr/avr/include/util/delay.h **** 
 1959               		.loc 3 174 2 view .LVU514
 184:/usr/avr/include/util/delay.h **** 	#endif
 1960               		.loc 3 184 3 view .LVU515
 1961               		.loc 3 187 2 view .LVU516
 1962 0456 2FEF      		ldi r18,lo8(255999)
 1963 0458 37EE      		ldi r19,hi8(255999)
 1964 045a 83E0      		ldi r24,hlo8(255999)
 1965 045c 2150      	1:	subi r18,1
 1966 045e 3040      		sbci r19,0
 1967 0460 8040      		sbci r24,0
 1968 0462 01F4      		brne 1b
 1969 0464 00C0      		rjmp .L181
 1970               	.LVL187:
 1971               	.L139:
 1972               		.loc 3 187 2 is_stmt 0 view .LVU517
 1973               	.LBE66:
 1974               	.LBE71:
 580:quantum/action.c ****                             layer_off(action.layer_tap.val);
 1975               		.loc 1 580 79 is_stmt 1 view .LVU518
 581:quantum/action.c ****                         }
 1976               		.loc 1 581 29 view .LVU519
 1977 0466 8981      		ldd r24,Y+1
 1978 0468 8F71      		andi r24,lo8(31)
 1979 046a 00C0      		rjmp .L178
 1980               	.L72:
 592:quantum/action.c ****             break;
 1981               		.loc 1 592 13 view .LVU520
 592:quantum/action.c ****             break;
 1982               		.loc 1 592 83 is_stmt 0 view .LVU521
 1983 046c 4981      		ldd r20,Y+1
 1984 046e 4F70      		andi r20,lo8(15)
 592:quantum/action.c ****             break;
 1985               		.loc 1 592 13 view .LVU522
 1986 0470 6D81      		ldd r22,Y+5
 1987 0472 C601      		movw r24,r12
 1988 0474 0E94 0000 		call action_get_macro
 1989               	.LVL188:
 1990 0478 0E94 0000 		call action_macro_play
 1991               	.LVL189:
 593:quantum/action.c **** #endif
 1992               		.loc 1 593 13 is_stmt 1 view .LVU523
 1993 047c 00C0      		rjmp .L69
 1994               	.L70:
 670:quantum/action.c ****             break;
 1995               		.loc 1 670 13 view .LVU524
 670:quantum/action.c ****             break;
 1996               		.loc 1 670 64 is_stmt 0 view .LVU525
 1997 047e 4981      		ldd r20,Y+1
 1998 0480 4F70      		andi r20,lo8(15)
 670:quantum/action.c ****             break;
 1999               		.loc 1 670 13 view .LVU526
 2000 0482 6D81      		ldd r22,Y+5
 2001 0484 C601      		movw r24,r12
 2002 0486 0E94 0000 		call action_function
 2003               	.LVL190:
 671:quantum/action.c **** #endif
 2004               		.loc 1 671 13 is_stmt 1 view .LVU527
 2005 048a 00C0      		rjmp .L69
 2006               	.LVL191:
 2007               	.L66:
 2008               	/* epilogue start */
 739:quantum/action.c **** 
 2009               		.loc 1 739 1 is_stmt 0 view .LVU528
 2010 048c 0F90      		pop __tmp_reg__
 2011 048e 0F90      		pop __tmp_reg__
 2012 0490 0F90      		pop __tmp_reg__
 2013 0492 0F90      		pop __tmp_reg__
 2014 0494 0F90      		pop __tmp_reg__
 2015 0496 DF91      		pop r29
 2016 0498 CF91      		pop r28
 2017 049a 1F91      		pop r17
 2018 049c 0F91      		pop r16
 2019 049e FF90      		pop r15
 2020 04a0 EF90      		pop r14
 2021               	.LVL192:
 739:quantum/action.c **** 
 2022               		.loc 1 739 1 view .LVU529
 2023 04a2 DF90      		pop r13
 2024 04a4 CF90      		pop r12
 2025               	.LVL193:
 739:quantum/action.c **** 
 2026               		.loc 1 739 1 view .LVU530
 2027 04a6 BF90      		pop r11
 2028 04a8 AF90      		pop r10
 2029 04aa 0895      		ret
 2030               		.cfi_endproc
 2031               	.LFE116:
 2033               		.section	.text.process_record_handler,"ax",@progbits
 2034               	.global	process_record_handler
 2036               	process_record_handler:
 2037               	.LVL194:
 2038               	.LFB115:
 208:quantum/action.c **** #ifdef COMBO_ENABLE
 2039               		.loc 1 208 50 is_stmt 1 view -0
 2040               		.cfi_startproc
 208:quantum/action.c **** #ifdef COMBO_ENABLE
 2041               		.loc 1 208 50 is_stmt 0 view .LVU532
 2042 0000 0F93      		push r16
 2043               	.LCFI24:
 2044               		.cfi_def_cfa_offset 3
 2045               		.cfi_offset 16, -2
 2046 0002 1F93      		push r17
 2047               	.LCFI25:
 2048               		.cfi_def_cfa_offset 4
 2049               		.cfi_offset 17, -3
 2050 0004 CF93      		push r28
 2051               	.LCFI26:
 2052               		.cfi_def_cfa_offset 5
 2053               		.cfi_offset 28, -4
 2054 0006 DF93      		push r29
 2055               	.LCFI27:
 2056               		.cfi_def_cfa_offset 6
 2057               		.cfi_offset 29, -5
 2058               	/* prologue: function */
 2059               	/* frame size = 0 */
 2060               	/* stack size = 4 */
 2061               	.L__stack_usage = 4
 2062 0008 EC01      		movw r28,r24
 217:quantum/action.c **** #endif
 2063               		.loc 1 217 5 is_stmt 1 view .LVU533
 217:quantum/action.c **** #endif
 2064               		.loc 1 217 23 is_stmt 0 view .LVU534
 2065 000a 6881      		ld r22,Y
 2066 000c 7981      		ldd r23,Y+1
 2067 000e 8A81      		ldd r24,Y+2
 2068               	.LVL195:
 217:quantum/action.c **** #endif
 2069               		.loc 1 217 23 view .LVU535
 2070 0010 0E94 0000 		call store_or_get_action
 2071               	.LVL196:
 2072 0014 8C01      		movw r16,r24
 219:quantum/action.c ****     debug_action(action);
 2073               		.loc 1 219 23 is_stmt 1 view .LVU536
 220:quantum/action.c **** #ifndef NO_ACTION_LAYER
 2074               		.loc 1 220 5 view .LVU537
 222:quantum/action.c ****     layer_debug();
 2075               		.loc 1 222 29 view .LVU538
 223:quantum/action.c ****     dprint(" default_layer_state: ");
 2076               		.loc 1 223 5 view .LVU539
 2077 0016 0E94 0000 		call layer_debug
 2078               	.LVL197:
 224:quantum/action.c ****     default_layer_debug();
 2079               		.loc 1 224 37 view .LVU540
 225:quantum/action.c **** #endif
 2080               		.loc 1 225 5 view .LVU541
 2081 001a 0E94 0000 		call default_layer_debug
 2082               	.LVL198:
 227:quantum/action.c **** 
 2083               		.loc 1 227 15 view .LVU542
 229:quantum/action.c **** }
 2084               		.loc 1 229 5 view .LVU543
 2085 001e B801      		movw r22,r16
 2086 0020 CE01      		movw r24,r28
 2087               	/* epilogue start */
 230:quantum/action.c **** 
 2088               		.loc 1 230 1 is_stmt 0 view .LVU544
 2089 0022 DF91      		pop r29
 2090 0024 CF91      		pop r28
 2091               	.LVL199:
 230:quantum/action.c **** 
 2092               		.loc 1 230 1 view .LVU545
 2093 0026 1F91      		pop r17
 2094 0028 0F91      		pop r16
 229:quantum/action.c **** }
 2095               		.loc 1 229 5 view .LVU546
 2096 002a 0C94 0000 		jmp process_action
 2097               	.LVL200:
 229:quantum/action.c **** }
 2098               		.loc 1 229 5 view .LVU547
 2099               		.cfi_endproc
 2100               	.LFE115:
 2102               		.section	.text.process_record,"ax",@progbits
 2103               	.global	process_record
 2105               	process_record:
 2106               	.LVL201:
 2107               	.LFB114:
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 2108               		.loc 1 190 42 is_stmt 1 view -0
 2109               		.cfi_startproc
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 2110               		.loc 1 190 42 is_stmt 0 view .LVU549
 2111 0000 CF93      		push r28
 2112               	.LCFI28:
 2113               		.cfi_def_cfa_offset 3
 2114               		.cfi_offset 28, -2
 2115 0002 DF93      		push r29
 2116               	.LCFI29:
 2117               		.cfi_def_cfa_offset 4
 2118               		.cfi_offset 29, -3
 2119               	/* prologue: function */
 2120               	/* frame size = 0 */
 2121               	/* stack size = 2 */
 2122               	.L__stack_usage = 2
 2123 0004 EC01      		movw r28,r24
 191:quantum/action.c ****         return;
 2124               		.loc 1 191 5 is_stmt 1 view .LVU550
 2125 0006 9881      		ld r25,Y
 2126               	.LVL202:
 191:quantum/action.c ****         return;
 2127               		.loc 1 191 5 is_stmt 0 view .LVU551
 2128 0008 8981      		ldd r24,Y+1
 2129               	.LVL203:
 2130               	.LBB72:
 2131               	.LBI72:
 2132               		.loc 2 47 20 is_stmt 1 view .LVU552
 2133               	.LBB73:
 2134               		.loc 2 47 51 view .LVU553
 2135               		.loc 2 47 74 is_stmt 0 view .LVU554
 2136 000a 2B81      		ldd r18,Y+3
 2137 000c 3C81      		ldd r19,Y+4
 2138 000e 232B      		or r18,r19
 2139 0010 01F0      		breq .L183
 2140 0012 8923      		and r24,r25
 2141               	.LVL204:
 2142               		.loc 2 47 74 view .LVU555
 2143 0014 8F3F      		cpi r24,lo8(-1)
 2144 0016 01F4      		brne .L199
 2145               	.LVL205:
 2146               	.L183:
 2147               	/* epilogue start */
 2148               		.loc 2 47 74 view .LVU556
 2149               	.LBE73:
 2150               	.LBE72:
 206:quantum/action.c **** 
 2151               		.loc 1 206 1 view .LVU557
 2152 0018 DF91      		pop r29
 2153 001a CF91      		pop r28
 2154               	.LVL206:
 206:quantum/action.c **** 
 2155               		.loc 1 206 1 view .LVU558
 2156 001c 0895      		ret
 2157               	.LVL207:
 2158               	.L188:
 204:quantum/action.c ****     post_process_record_quantum(record);
 2159               		.loc 1 204 5 is_stmt 1 view .LVU559
 2160 001e CE01      		movw r24,r28
 2161 0020 0E94 0000 		call process_record_handler
 2162               	.LVL208:
 205:quantum/action.c **** }
 2163               		.loc 1 205 5 view .LVU560
 2164 0024 CE01      		movw r24,r28
 2165               	/* epilogue start */
 206:quantum/action.c **** 
 2166               		.loc 1 206 1 is_stmt 0 view .LVU561
 2167 0026 DF91      		pop r29
 2168 0028 CF91      		pop r28
 2169               	.LVL209:
 205:quantum/action.c **** }
 2170               		.loc 1 205 5 view .LVU562
 2171 002a 0C94 0000 		jmp post_process_record_quantum
 2172               	.LVL210:
 2173               	.L199:
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 2174               		.loc 1 195 5 is_stmt 1 view .LVU563
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 2175               		.loc 1 195 10 is_stmt 0 view .LVU564
 2176 002e CE01      		movw r24,r28
 2177 0030 0E94 0000 		call process_record_quantum
 2178               	.LVL211:
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 2179               		.loc 1 195 8 view .LVU565
 2180 0034 8111      		cpse r24,__zero_reg__
 2181 0036 00C0      		rjmp .L188
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2182               		.loc 1 197 9 is_stmt 1 view .LVU566
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2183               		.loc 1 197 13 is_stmt 0 view .LVU567
 2184 0038 0E94 0000 		call is_oneshot_layer_active
 2185               	.LVL212:
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2186               		.loc 1 197 12 view .LVU568
 2187 003c 8823      		tst r24
 2188 003e 01F0      		breq .L183
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2189               		.loc 1 197 39 discriminator 1 view .LVU569
 2190 0040 8A81      		ldd r24,Y+2
 2191 0042 8823      		tst r24
 2192 0044 01F0      		breq .L183
 198:quantum/action.c ****         }
 2193               		.loc 1 198 13 is_stmt 1 view .LVU570
 2194 0046 82E0      		ldi r24,lo8(2)
 2195               	/* epilogue start */
 206:quantum/action.c **** 
 2196               		.loc 1 206 1 is_stmt 0 view .LVU571
 2197 0048 DF91      		pop r29
 2198 004a CF91      		pop r28
 2199               	.LVL213:
 198:quantum/action.c ****         }
 2200               		.loc 1 198 13 view .LVU572
 2201 004c 0C94 0000 		jmp clear_oneshot_layer_state
 2202               	.LVL214:
 2203               		.cfi_endproc
 2204               	.LFE114:
 2206               		.section	.text.process_record_nocache,"ax",@progbits
 2207               	.global	process_record_nocache
 2209               	process_record_nocache:
 2210               	.LVL215:
 2211               	.LFB110:
 148:quantum/action.c ****     disable_action_cache = true;
 2212               		.loc 1 148 50 is_stmt 1 view -0
 2213               		.cfi_startproc
 2214               	/* prologue: function */
 2215               	/* frame size = 0 */
 2216               	/* stack size = 0 */
 2217               	.L__stack_usage = 0
 149:quantum/action.c ****     process_record(record);
 2218               		.loc 1 149 5 view .LVU574
 149:quantum/action.c ****     process_record(record);
 2219               		.loc 1 149 26 is_stmt 0 view .LVU575
 2220 0000 21E0      		ldi r18,lo8(1)
 2221 0002 2093 0000 		sts disable_action_cache,r18
 150:quantum/action.c ****     disable_action_cache = false;
 2222               		.loc 1 150 5 is_stmt 1 view .LVU576
 2223 0006 0E94 0000 		call process_record
 2224               	.LVL216:
 151:quantum/action.c **** }
 2225               		.loc 1 151 5 view .LVU577
 151:quantum/action.c **** }
 2226               		.loc 1 151 26 is_stmt 0 view .LVU578
 2227 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 2228               	/* epilogue start */
 152:quantum/action.c **** #else
 2229               		.loc 1 152 1 view .LVU579
 2230 000e 0895      		ret
 2231               		.cfi_endproc
 2232               	.LFE110:
 2234               		.section	.text.register_weak_mods,"ax",@progbits
 2235               	.global	register_weak_mods
 2237               	register_weak_mods:
 2238               	.LVL217:
 2239               	.LFB123:
 934:quantum/action.c **** 
 935:quantum/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 936:quantum/action.c ****  *
 937:quantum/action.c ****  * \param mods A bitfield of modifiers to register.
 938:quantum/action.c ****  */
 939:quantum/action.c **** void register_weak_mods(uint8_t mods) {
 2240               		.loc 1 939 39 is_stmt 1 view -0
 2241               		.cfi_startproc
 2242               	/* prologue: function */
 2243               	/* frame size = 0 */
 2244               	/* stack size = 0 */
 2245               	.L__stack_usage = 0
 940:quantum/action.c ****     if (mods) {
 2246               		.loc 1 940 5 view .LVU581
 2247               		.loc 1 940 8 is_stmt 0 view .LVU582
 2248 0000 8823      		tst r24
 2249 0002 01F0      		breq .L202
 941:quantum/action.c ****         add_weak_mods(mods);
 2250               		.loc 1 941 9 is_stmt 1 view .LVU583
 2251 0004 0E94 0000 		call add_weak_mods
 2252               	.LVL218:
 942:quantum/action.c ****         send_keyboard_report();
 2253               		.loc 1 942 9 view .LVU584
 2254 0008 0C94 0000 		jmp send_keyboard_report
 2255               	.LVL219:
 2256               	.L202:
 2257               	/* epilogue start */
 943:quantum/action.c ****     }
 944:quantum/action.c **** }
 2258               		.loc 1 944 1 is_stmt 0 view .LVU585
 2259 000c 0895      		ret
 2260               		.cfi_endproc
 2261               	.LFE123:
 2263               		.section	.text.unregister_weak_mods,"ax",@progbits
 2264               	.global	unregister_weak_mods
 2266               	unregister_weak_mods:
 2267               	.LVL220:
 2268               	.LFB124:
 945:quantum/action.c **** 
 946:quantum/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 947:quantum/action.c ****  *
 948:quantum/action.c ****  * \param mods A bitfield of modifiers to unregister.
 949:quantum/action.c ****  */
 950:quantum/action.c **** void unregister_weak_mods(uint8_t mods) {
 2269               		.loc 1 950 41 is_stmt 1 view -0
 2270               		.cfi_startproc
 2271               	/* prologue: function */
 2272               	/* frame size = 0 */
 2273               	/* stack size = 0 */
 2274               	.L__stack_usage = 0
 951:quantum/action.c ****     if (mods) {
 2275               		.loc 1 951 5 view .LVU587
 2276               		.loc 1 951 8 is_stmt 0 view .LVU588
 2277 0000 8823      		tst r24
 2278 0002 01F0      		breq .L204
 952:quantum/action.c ****         del_weak_mods(mods);
 2279               		.loc 1 952 9 is_stmt 1 view .LVU589
 2280 0004 0E94 0000 		call del_weak_mods
 2281               	.LVL221:
 953:quantum/action.c ****         send_keyboard_report();
 2282               		.loc 1 953 9 view .LVU590
 2283 0008 0C94 0000 		jmp send_keyboard_report
 2284               	.LVL222:
 2285               	.L204:
 2286               	/* epilogue start */
 954:quantum/action.c ****     }
 955:quantum/action.c **** }
 2287               		.loc 1 955 1 is_stmt 0 view .LVU591
 2288 000c 0895      		ret
 2289               		.cfi_endproc
 2290               	.LFE124:
 2292               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2293               	.global	clear_keyboard_but_mods_and_keys
 2295               	clear_keyboard_but_mods_and_keys:
 2296               	.LFB127:
 956:quantum/action.c **** 
 957:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:quantum/action.c ****  *
 959:quantum/action.c ****  * FIXME: Needs documentation.
 960:quantum/action.c ****  */
 961:quantum/action.c **** void clear_keyboard(void) {
 962:quantum/action.c ****     clear_mods();
 963:quantum/action.c ****     clear_keyboard_but_mods();
 964:quantum/action.c **** }
 965:quantum/action.c **** 
 966:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:quantum/action.c ****  *
 968:quantum/action.c ****  * FIXME: Needs documentation.
 969:quantum/action.c ****  */
 970:quantum/action.c **** void clear_keyboard_but_mods(void) {
 971:quantum/action.c ****     clear_keys();
 972:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 973:quantum/action.c **** }
 974:quantum/action.c **** 
 975:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 976:quantum/action.c ****  *
 977:quantum/action.c ****  * FIXME: Needs documentation.
 978:quantum/action.c ****  */
 979:quantum/action.c **** void clear_keyboard_but_mods_and_keys() {
 2297               		.loc 1 979 41 is_stmt 1 view -0
 2298               		.cfi_startproc
 2299               	/* prologue: function */
 2300               	/* frame size = 0 */
 2301               	/* stack size = 0 */
 2302               	.L__stack_usage = 0
 980:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 981:quantum/action.c ****     host_system_send(0);
 2303               		.loc 1 981 5 view .LVU593
 2304 0000 90E0      		ldi r25,0
 2305 0002 80E0      		ldi r24,0
 2306 0004 0E94 0000 		call host_system_send
 2307               	.LVL223:
 982:quantum/action.c ****     host_consumer_send(0);
 2308               		.loc 1 982 5 view .LVU594
 2309 0008 90E0      		ldi r25,0
 2310 000a 80E0      		ldi r24,0
 2311 000c 0E94 0000 		call host_consumer_send
 2312               	.LVL224:
 983:quantum/action.c **** #endif
 984:quantum/action.c ****     clear_weak_mods();
 2313               		.loc 1 984 5 view .LVU595
 2314 0010 0E94 0000 		call clear_weak_mods
 2315               	.LVL225:
 985:quantum/action.c ****     clear_macro_mods();
 2316               		.loc 1 985 5 view .LVU596
 2317 0014 0E94 0000 		call clear_macro_mods
 2318               	.LVL226:
 986:quantum/action.c ****     send_keyboard_report();
 2319               		.loc 1 986 5 view .LVU597
 2320 0018 0E94 0000 		call send_keyboard_report
 2321               	.LVL227:
 987:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 988:quantum/action.c ****     mousekey_clear();
 2322               		.loc 1 988 5 view .LVU598
 2323 001c 0E94 0000 		call mousekey_clear
 2324               	.LVL228:
 989:quantum/action.c ****     mousekey_send();
 2325               		.loc 1 989 5 view .LVU599
 2326 0020 0C94 0000 		jmp mousekey_send
 2327               	.LVL229:
 2328               		.cfi_endproc
 2329               	.LFE127:
 2331               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2332               	.global	clear_keyboard_but_mods
 2334               	clear_keyboard_but_mods:
 2335               	.LFB126:
 970:quantum/action.c ****     clear_keys();
 2336               		.loc 1 970 36 view -0
 2337               		.cfi_startproc
 2338               	/* prologue: function */
 2339               	/* frame size = 0 */
 2340               	/* stack size = 0 */
 2341               	.L__stack_usage = 0
 971:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 2342               		.loc 1 971 5 view .LVU601
 2343 0000 0E94 0000 		call clear_keys
 2344               	.LVL230:
 972:quantum/action.c **** }
 2345               		.loc 1 972 5 view .LVU602
 2346 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2347               	.LVL231:
 2348               		.cfi_endproc
 2349               	.LFE126:
 2351               		.section	.text.clear_keyboard,"ax",@progbits
 2352               	.global	clear_keyboard
 2354               	clear_keyboard:
 2355               	.LFB125:
 961:quantum/action.c ****     clear_mods();
 2356               		.loc 1 961 27 view -0
 2357               		.cfi_startproc
 2358               	/* prologue: function */
 2359               	/* frame size = 0 */
 2360               	/* stack size = 0 */
 2361               	.L__stack_usage = 0
 962:quantum/action.c ****     clear_keyboard_but_mods();
 2362               		.loc 1 962 5 view .LVU604
 2363 0000 0E94 0000 		call clear_mods
 2364               	.LVL232:
 963:quantum/action.c **** }
 2365               		.loc 1 963 5 view .LVU605
 2366 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2367               	.LVL233:
 2368               		.cfi_endproc
 2369               	.LFE125:
 2371               		.section	.text.is_tap_action,"ax",@progbits
 2372               	.global	is_tap_action
 2374               	is_tap_action:
 2375               	.LVL234:
 2376               	.LFB130:
 990:quantum/action.c **** #endif
 991:quantum/action.c **** }
 992:quantum/action.c **** 
 993:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:quantum/action.c ****  *
 995:quantum/action.c ****  * FIXME: Needs documentation.
 996:quantum/action.c ****  */
 997:quantum/action.c **** bool is_tap_key(keypos_t key) {
 998:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 999:quantum/action.c ****     return is_tap_action(action);
1000:quantum/action.c **** }
1001:quantum/action.c **** 
1002:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1003:quantum/action.c ****  *
1004:quantum/action.c ****  * FIXME: Needs documentation.
1005:quantum/action.c ****  */
1006:quantum/action.c **** bool is_tap_record(keyrecord_t *record) {
1007:quantum/action.c **** #ifdef COMBO_ENABLE
1008:quantum/action.c ****     action_t action;
1009:quantum/action.c ****     if (record->keycode) {
1010:quantum/action.c ****         action = action_for_keycode(record->keycode);
1011:quantum/action.c ****     } else {
1012:quantum/action.c ****         action = layer_switch_get_action(record->event.key);
1013:quantum/action.c ****     }
1014:quantum/action.c **** #else
1015:quantum/action.c ****     action_t action = layer_switch_get_action(record->event.key);
1016:quantum/action.c **** #endif
1017:quantum/action.c ****     return is_tap_action(action);
1018:quantum/action.c **** }
1019:quantum/action.c **** 
1020:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1021:quantum/action.c ****  *
1022:quantum/action.c ****  * FIXME: Needs documentation.
1023:quantum/action.c ****  */
1024:quantum/action.c **** bool is_tap_action(action_t action) {
 2377               		.loc 1 1024 37 view -0
 2378               		.cfi_startproc
 2379               	/* prologue: function */
 2380               	/* frame size = 0 */
 2381               	/* stack size = 0 */
 2382               	.L__stack_usage = 0
 2383               		.loc 1 1024 37 is_stmt 0 view .LVU607
 2384 0000 282F      		mov r18,r24
 2385               	.LVL235:
1025:quantum/action.c ****     switch (action.kind.id) {
 2386               		.loc 1 1025 5 is_stmt 1 view .LVU608
 2387               		.loc 1 1025 24 is_stmt 0 view .LVU609
 2388 0002 892F      		mov r24,r25
 2389 0004 8295      		swap r24
 2390 0006 8F70      		andi r24,lo8(15)
 2391               		.loc 1 1025 5 view .LVU610
 2392 0008 903C      		cpi r25,lo8(-64)
 2393 000a 00F4      		brsh .L210
 2394 000c 8A30      		cpi r24,lo8(10)
 2395 000e 00F4      		brsh .L211
 2396 0010 8430      		cpi r24,lo8(4)
 2397 0012 00F4      		brsh .L212
 2398 0014 8230      		cpi r24,lo8(2)
 2399 0016 00F4      		brsh .L211
 2400               	.L237:
 2401 0018 80E0      		ldi r24,0
 2402 001a 0895      		ret
 2403               	.L212:
 2404 001c 8630      		cpi r24,lo8(6)
 2405 001e 01F4      		brne .L237
1026:quantum/action.c ****         case ACT_LMODS_TAP:
1027:quantum/action.c ****         case ACT_RMODS_TAP:
1028:quantum/action.c ****         case ACT_LAYER_TAP:
1029:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
1030:quantum/action.c ****             switch (action.layer_tap.code) {
1031:quantum/action.c ****                 case KC_NO ... KC_RGUI:
1032:quantum/action.c ****                 case OP_TAP_TOGGLE:
1033:quantum/action.c ****                 case OP_ONESHOT:
1034:quantum/action.c ****                     return true;
1035:quantum/action.c ****             }
1036:quantum/action.c ****             return false;
1037:quantum/action.c ****         case ACT_SWAP_HANDS:
1038:quantum/action.c ****             switch (action.swap.code) {
 2406               		.loc 1 1038 13 is_stmt 1 view .LVU611
1034:quantum/action.c ****             }
 2407               		.loc 1 1034 28 is_stmt 0 view .LVU612
 2408 0020 81E0      		ldi r24,lo8(1)
 2409 0022 283E      		cpi r18,lo8(-24)
 2410 0024 00F0      		brlo .L209
 2411 0026 213F      		cpi r18,lo8(-15)
 2412 0028 01F4      		brne .L237
 2413 002a 00C0      		rjmp .L209
 2414               	.L210:
1025:quantum/action.c ****     switch (action.kind.id) {
 2415               		.loc 1 1025 5 view .LVU613
 2416 002c 8C30      		cpi r24,lo8(12)
 2417 002e 01F0      		breq .L215
 2418 0030 8F30      		cpi r24,lo8(15)
 2419 0032 01F4      		brne .L237
 2420               	.L215:
1039:quantum/action.c ****                 case KC_NO ... KC_RGUI:
1040:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
1041:quantum/action.c ****                     return true;
1042:quantum/action.c ****             }
1043:quantum/action.c ****             return false;
1044:quantum/action.c ****         case ACT_MACRO:
1045:quantum/action.c ****         case ACT_FUNCTION:
1046:quantum/action.c ****             if (action.func.opt & FUNC_TAP) {
 2421               		.loc 1 1046 13 is_stmt 1 view .LVU614
 2422               		.loc 1 1046 16 is_stmt 0 view .LVU615
 2423 0034 93FB      		bst r25,3
 2424 0036 8827      		clr r24
 2425 0038 80F9      		bld r24,0
 2426 003a 0895      		ret
 2427               	.L211:
1030:quantum/action.c ****                 case KC_NO ... KC_RGUI:
 2428               		.loc 1 1030 13 is_stmt 1 view .LVU616
 2429 003c 81E0      		ldi r24,lo8(1)
 2430 003e 203F      		cpi r18,lo8(-16)
 2431 0040 01F0      		breq .L220
 2432 0042 00F4      		brsh .L216
 2433 0044 283E      		cpi r18,lo8(-24)
 2434 0046 00F4      		brsh .L237
 2435               	.L209:
 2436               	/* epilogue start */
1047:quantum/action.c ****                 return true;
1048:quantum/action.c ****             }
1049:quantum/action.c ****             return false;
1050:quantum/action.c ****     }
1051:quantum/action.c ****     return false;
1052:quantum/action.c **** }
 2437               		.loc 1 1052 1 is_stmt 0 view .LVU617
 2438 0048 0895      		ret
 2439               	.L216:
 2440 004a 243F      		cpi r18,lo8(-12)
 2441 004c 01F4      		brne .L237
 2442 004e 00C0      		rjmp .L209
 2443               	.L220:
 2444 0050 0895      		ret
 2445               		.cfi_endproc
 2446               	.LFE130:
 2448               		.section	.text.is_tap_key,"ax",@progbits
 2449               	.global	is_tap_key
 2451               	is_tap_key:
 2452               	.LVL236:
 2453               	.LFB128:
 997:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 2454               		.loc 1 997 31 is_stmt 1 view -0
 2455               		.cfi_startproc
 2456               	/* prologue: function */
 2457               	/* frame size = 0 */
 2458               	/* stack size = 0 */
 2459               	.L__stack_usage = 0
 998:quantum/action.c ****     return is_tap_action(action);
 2460               		.loc 1 998 5 view .LVU619
 998:quantum/action.c ****     return is_tap_action(action);
 2461               		.loc 1 998 23 is_stmt 0 view .LVU620
 2462 0000 0E94 0000 		call layer_switch_get_action
 2463               	.LVL237:
 999:quantum/action.c **** }
 2464               		.loc 1 999 5 is_stmt 1 view .LVU621
 999:quantum/action.c **** }
 2465               		.loc 1 999 12 is_stmt 0 view .LVU622
 2466 0004 0C94 0000 		jmp is_tap_action
 2467               	.LVL238:
 2468               		.cfi_endproc
 2469               	.LFE128:
 2471               		.section	.text.is_tap_record,"ax",@progbits
 2472               	.global	is_tap_record
 2474               	is_tap_record:
 2475               	.LVL239:
 2476               	.LFB129:
1006:quantum/action.c **** #ifdef COMBO_ENABLE
 2477               		.loc 1 1006 41 is_stmt 1 view -0
 2478               		.cfi_startproc
 2479               	/* prologue: function */
 2480               	/* frame size = 0 */
 2481               	/* stack size = 0 */
 2482               	.L__stack_usage = 0
1015:quantum/action.c **** #endif
 2483               		.loc 1 1015 5 view .LVU624
1015:quantum/action.c **** #endif
 2484               		.loc 1 1015 23 is_stmt 0 view .LVU625
 2485 0000 FC01      		movw r30,r24
 2486 0002 8081      		ld r24,Z
 2487 0004 9181      		ldd r25,Z+1
 2488               	.LVL240:
1015:quantum/action.c **** #endif
 2489               		.loc 1 1015 23 view .LVU626
 2490 0006 0E94 0000 		call layer_switch_get_action
 2491               	.LVL241:
1017:quantum/action.c **** }
 2492               		.loc 1 1017 5 is_stmt 1 view .LVU627
1017:quantum/action.c **** }
 2493               		.loc 1 1017 12 is_stmt 0 view .LVU628
 2494 000a 0C94 0000 		jmp is_tap_action
 2495               	.LVL242:
 2496               		.cfi_endproc
 2497               	.LFE129:
 2499               		.section	.text.debug_event,"ax",@progbits
 2500               	.global	debug_event
 2502               	debug_event:
 2503               	.LFB131:
1053:quantum/action.c **** 
1054:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1055:quantum/action.c ****  *
1056:quantum/action.c ****  * FIXME: Needs documentation.
1057:quantum/action.c ****  */
1058:quantum/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2504               		.loc 1 1058 36 is_stmt 1 view -0
 2505               		.cfi_startproc
 2506 0000 CF93      		push r28
 2507               	.LCFI30:
 2508               		.cfi_def_cfa_offset 3
 2509               		.cfi_offset 28, -2
 2510 0002 DF93      		push r29
 2511               	.LCFI31:
 2512               		.cfi_def_cfa_offset 4
 2513               		.cfi_offset 29, -3
 2514 0004 00D0      		rcall .
 2515 0006 00D0      		rcall .
 2516 0008 0F92      		push __tmp_reg__
 2517               	.LCFI32:
 2518               		.cfi_def_cfa_offset 9
 2519 000a CDB7      		in r28,__SP_L__
 2520 000c DEB7      		in r29,__SP_H__
 2521               	.LCFI33:
 2522               		.cfi_def_cfa_register 28
 2523               	/* prologue: function */
 2524               	/* frame size = 5 */
 2525               	/* stack size = 7 */
 2526               	.L__stack_usage = 7
 2527               		.loc 1 1058 138 view .LVU630
 2528               	/* epilogue start */
 2529               		.loc 1 1058 140 is_stmt 0 view .LVU631
 2530 000e 0F90      		pop __tmp_reg__
 2531 0010 0F90      		pop __tmp_reg__
 2532 0012 0F90      		pop __tmp_reg__
 2533 0014 0F90      		pop __tmp_reg__
 2534 0016 0F90      		pop __tmp_reg__
 2535 0018 DF91      		pop r29
 2536 001a CF91      		pop r28
 2537 001c 0895      		ret
 2538               		.cfi_endproc
 2539               	.LFE131:
 2541               		.section	.text.debug_record,"ax",@progbits
 2542               	.global	debug_record
 2544               	debug_record:
 2545               	.LFB132:
1059:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1060:quantum/action.c ****  *
1061:quantum/action.c ****  * FIXME: Needs documentation.
1062:quantum/action.c ****  */
1063:quantum/action.c **** void debug_record(keyrecord_t record) {
 2546               		.loc 1 1063 39 is_stmt 1 view -0
 2547               		.cfi_startproc
 2548 0000 CF93      		push r28
 2549               	.LCFI34:
 2550               		.cfi_def_cfa_offset 3
 2551               		.cfi_offset 28, -2
 2552 0002 DF93      		push r29
 2553               	.LCFI35:
 2554               		.cfi_def_cfa_offset 4
 2555               		.cfi_offset 29, -3
 2556 0004 00D0      		rcall .
 2557 0006 00D0      		rcall .
 2558 0008 00D0      		rcall .
 2559               	.LCFI36:
 2560               		.cfi_def_cfa_offset 10
 2561 000a CDB7      		in r28,__SP_L__
 2562 000c DEB7      		in r29,__SP_H__
 2563               	.LCFI37:
 2564               		.cfi_def_cfa_register 28
 2565               	/* prologue: function */
 2566               	/* frame size = 6 */
 2567               	/* stack size = 8 */
 2568               	.L__stack_usage = 8
1064:quantum/action.c ****     debug_event(record.event);
 2569               		.loc 1 1064 5 view .LVU633
1065:quantum/action.c **** #ifndef NO_ACTION_TAPPING
1066:quantum/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2570               		.loc 1 1066 77 view .LVU634
 2571               	/* epilogue start */
1067:quantum/action.c **** #endif
1068:quantum/action.c **** }
 2572               		.loc 1 1068 1 is_stmt 0 view .LVU635
 2573 000e 2696      		adiw r28,6
 2574 0010 0FB6      		in __tmp_reg__,__SREG__
 2575 0012 F894      		cli
 2576 0014 DEBF      		out __SP_H__,r29
 2577 0016 0FBE      		out __SREG__,__tmp_reg__
 2578 0018 CDBF      		out __SP_L__,r28
 2579 001a DF91      		pop r29
 2580 001c CF91      		pop r28
 2581 001e 0895      		ret
 2582               		.cfi_endproc
 2583               	.LFE132:
 2585               		.section	.text.debug_action,"ax",@progbits
 2586               	.global	debug_action
 2588               	debug_action:
 2589               	.LVL243:
 2590               	.LFB133:
1069:quantum/action.c **** 
1070:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1071:quantum/action.c ****  *
1072:quantum/action.c ****  * FIXME: Needs documentation.
1073:quantum/action.c ****  */
1074:quantum/action.c **** void debug_action(action_t action) {
 2591               		.loc 1 1074 36 is_stmt 1 view -0
 2592               		.cfi_startproc
 2593               	/* prologue: function */
 2594               	/* frame size = 0 */
 2595               	/* stack size = 0 */
 2596               	.L__stack_usage = 0
1075:quantum/action.c ****     switch (action.kind.id) {
 2597               		.loc 1 1075 5 view .LVU637
1076:quantum/action.c ****         case ACT_LMODS:
1077:quantum/action.c ****             dprint("ACT_LMODS");
1078:quantum/action.c ****             break;
1079:quantum/action.c ****         case ACT_RMODS:
1080:quantum/action.c ****             dprint("ACT_RMODS");
1081:quantum/action.c ****             break;
1082:quantum/action.c ****         case ACT_LMODS_TAP:
1083:quantum/action.c ****             dprint("ACT_LMODS_TAP");
1084:quantum/action.c ****             break;
1085:quantum/action.c ****         case ACT_RMODS_TAP:
1086:quantum/action.c ****             dprint("ACT_RMODS_TAP");
1087:quantum/action.c ****             break;
1088:quantum/action.c ****         case ACT_USAGE:
1089:quantum/action.c ****             dprint("ACT_USAGE");
1090:quantum/action.c ****             break;
1091:quantum/action.c ****         case ACT_MOUSEKEY:
1092:quantum/action.c ****             dprint("ACT_MOUSEKEY");
1093:quantum/action.c ****             break;
1094:quantum/action.c ****         case ACT_LAYER:
1095:quantum/action.c ****             dprint("ACT_LAYER");
1096:quantum/action.c ****             break;
1097:quantum/action.c ****         case ACT_LAYER_MODS:
1098:quantum/action.c ****             dprint("ACT_LAYER_MODS");
1099:quantum/action.c ****             break;
1100:quantum/action.c ****         case ACT_LAYER_TAP:
1101:quantum/action.c ****             dprint("ACT_LAYER_TAP");
1102:quantum/action.c ****             break;
1103:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
1104:quantum/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1105:quantum/action.c ****             break;
1106:quantum/action.c ****         case ACT_MACRO:
1107:quantum/action.c ****             dprint("ACT_MACRO");
1108:quantum/action.c ****             break;
1109:quantum/action.c ****         case ACT_FUNCTION:
1110:quantum/action.c ****             dprint("ACT_FUNCTION");
1111:quantum/action.c ****             break;
1112:quantum/action.c ****         case ACT_SWAP_HANDS:
1113:quantum/action.c ****             dprint("ACT_SWAP_HANDS");
1114:quantum/action.c ****             break;
1115:quantum/action.c ****         default:
1116:quantum/action.c ****             dprint("UNKNOWN");
1117:quantum/action.c ****             break;
1118:quantum/action.c ****     }
1119:quantum/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2598               		.loc 1 1119 75 view .LVU638
 2599               	/* epilogue start */
1120:quantum/action.c **** }
 2600               		.loc 1 1120 1 is_stmt 0 view .LVU639
 2601 0000 0895      		ret
 2602               		.cfi_endproc
 2603               	.LFE133:
 2605               		.section	.rodata.CSWTCH.14,"a"
 2608               	CSWTCH.14:
 2609 0000 E200      		.word	226
 2610 0002 E900      		.word	233
 2611 0004 EA00      		.word	234
 2612 0006 B500      		.word	181
 2613 0008 B600      		.word	182
 2614 000a B700      		.word	183
 2615 000c CD00      		.word	205
 2616 000e 8301      		.word	387
 2617 0010 CC00      		.word	204
 2618 0012 8A01      		.word	394
 2619 0014 9201      		.word	402
 2620 0016 9401      		.word	404
 2621 0018 2102      		.word	545
 2622 001a 2302      		.word	547
 2623 001c 2402      		.word	548
 2624 001e 2502      		.word	549
 2625 0020 2602      		.word	550
 2626 0022 2702      		.word	551
 2627 0024 2A02      		.word	554
 2628 0026 B300      		.word	179
 2629 0028 B400      		.word	180
 2630 002a 6F00      		.word	111
 2631 002c 7000      		.word	112
 2632               	.global	disable_action_cache
 2633               		.section	.bss.disable_action_cache,"aw",@nobits
 2636               	disable_action_cache:
 2637 0000 00        		.zero	1
 2638               		.comm	tp_buttons,2,1
 2639               		.text
 2640               	.Letext0:
 2641               		.file 5 "/usr/avr/include/stdint.h"
 2642               		.file 6 "quantum/keycode.h"
 2643               		.file 7 "quantum/action_code.h"
 2644               		.file 8 "quantum/action_macro.h"
 2645               		.file 9 "quantum/action.h"
 2646               		.file 10 "quantum/action_layer.h"
 2647               		.file 11 "quantum/action_util.h"
 2648               		.file 12 "quantum/mousekey.h"
 2649               		.file 13 "/usr/avr/include/math.h"
 2650               		.file 14 "quantum/led.h"
 2651               		.file 15 "tmk_core/common/host.h"
 2652               		.file 16 "quantum/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/ccqDDycv.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccqDDycv.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccqDDycv.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccqDDycv.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccqDDycv.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccqDDycv.s:13     .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccqDDycv.s:13     .text.process_record_quantum:0000000000000000 process_record_quantum.localalias
     /tmp/ccqDDycv.s:37     .text.pre_process_record_quantum:0000000000000000 pre_process_record_quantum
     /tmp/ccqDDycv.s:51     .text.action_exec:0000000000000000 action_exec
     /tmp/ccqDDycv.s:205    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
     /tmp/ccqDDycv.s:223    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/ccqDDycv.s:248    .text.register_code:0000000000000000 register_code
     /tmp/ccqDDycv.s:2608   .rodata.CSWTCH.14:0000000000000000 CSWTCH.14
     /tmp/ccqDDycv.s:566    .text.unregister_code:0000000000000000 unregister_code
     /tmp/ccqDDycv.s:734    .text.tap_code_delay:0000000000000000 tap_code_delay
     /tmp/ccqDDycv.s:821    .text.tap_code:0000000000000000 tap_code
     /tmp/ccqDDycv.s:848    .text.register_mods:0000000000000000 register_mods
     /tmp/ccqDDycv.s:877    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/ccqDDycv.s:906    .text.process_action:0000000000000000 process_action
     /tmp/ccqDDycv.s:2105   .text.process_record:0000000000000000 process_record
     /tmp/ccqDDycv.s:2036   .text.process_record_handler:0000000000000000 process_record_handler
     /tmp/ccqDDycv.s:2209   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/ccqDDycv.s:2636   .bss.disable_action_cache:0000000000000000 disable_action_cache
     /tmp/ccqDDycv.s:2237   .text.register_weak_mods:0000000000000000 register_weak_mods
     /tmp/ccqDDycv.s:2266   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
     /tmp/ccqDDycv.s:2295   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
     /tmp/ccqDDycv.s:2334   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/ccqDDycv.s:2354   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/ccqDDycv.s:2374   .text.is_tap_action:0000000000000000 is_tap_action
     /tmp/ccqDDycv.s:2451   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/ccqDDycv.s:2474   .text.is_tap_record:0000000000000000 is_tap_record
     /tmp/ccqDDycv.s:2502   .text.debug_event:0000000000000000 debug_event
     /tmp/ccqDDycv.s:2544   .text.debug_record:0000000000000000 debug_record
     /tmp/ccqDDycv.s:2588   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
clear_weak_mods
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
keyboard_report
is_key_pressed
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
