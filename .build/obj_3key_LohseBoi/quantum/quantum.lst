   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.extract_mod_bits,"ax",@progbits
  11               	.global	extract_mod_bits
  13               	extract_mod_bits:
  14               	.LVL0:
  15               	.LFB119:
  16               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #include "magic.h"
  19:quantum/quantum.c **** 
  20:quantum/quantum.c **** #ifdef BLUETOOTH_ENABLE
  21:quantum/quantum.c **** #    include "outputselect.h"
  22:quantum/quantum.c **** #endif
  23:quantum/quantum.c **** 
  24:quantum/quantum.c **** #ifdef BACKLIGHT_ENABLE
  25:quantum/quantum.c **** #    include "backlight.h"
  26:quantum/quantum.c **** #endif
  27:quantum/quantum.c **** 
  28:quantum/quantum.c **** #ifdef API_ENABLE
  29:quantum/quantum.c **** #    include "api.h"
  30:quantum/quantum.c **** #endif
  31:quantum/quantum.c **** 
  32:quantum/quantum.c **** #ifdef MIDI_ENABLE
  33:quantum/quantum.c **** #    include "process_midi.h"
  34:quantum/quantum.c **** #endif
  35:quantum/quantum.c **** 
  36:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
  37:quantum/quantum.c **** #    include "velocikey.h"
  38:quantum/quantum.c **** #endif
  39:quantum/quantum.c **** 
  40:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
  41:quantum/quantum.c **** #    include "haptic.h"
  42:quantum/quantum.c **** #endif
  43:quantum/quantum.c **** 
  44:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  45:quantum/quantum.c **** #    ifndef GOODBYE_SONG
  46:quantum/quantum.c **** #        define GOODBYE_SONG SONG(GOODBYE_SOUND)
  47:quantum/quantum.c **** #    endif
  48:quantum/quantum.c **** float goodbye_song[][2] = GOODBYE_SONG;
  49:quantum/quantum.c **** #    ifdef DEFAULT_LAYER_SONGS
  50:quantum/quantum.c **** float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  51:quantum/quantum.c **** #    endif
  52:quantum/quantum.c **** #endif
  53:quantum/quantum.c **** 
  54:quantum/quantum.c **** #ifdef AUTO_SHIFT_ENABLE
  55:quantum/quantum.c **** #    include "process_auto_shift.h"
  56:quantum/quantum.c **** #endif
  57:quantum/quantum.c **** 
  58:quantum/quantum.c **** uint8_t extract_mod_bits(uint16_t code) {
  17               		.loc 1 58 41 view -0
  18               		.cfi_startproc
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  23               		.loc 1 58 41 is_stmt 0 view .LVU1
  24 0000 9C01      		movw r18,r24
  59:quantum/quantum.c ****     switch (code) {
  25               		.loc 1 59 5 is_stmt 1 view .LVU2
  26 0002 9A95      		dec r25
  27               	.LVL1:
  28               		.loc 1 59 5 is_stmt 0 view .LVU3
  29 0004 8115      		cp r24,__zero_reg__
  30 0006 9F41      		sbci r25,31
  31 0008 00F4      		brsh .L8
  60:quantum/quantum.c ****         case QK_MODS ... QK_MODS_MAX:
  61:quantum/quantum.c ****             break;
  32               		.loc 1 61 13 is_stmt 1 view .LVU4
  62:quantum/quantum.c ****         default:
  63:quantum/quantum.c ****             return 0;
  64:quantum/quantum.c ****     }
  65:quantum/quantum.c **** 
  66:quantum/quantum.c ****     uint8_t mods_to_send = 0;
  33               		.loc 1 66 5 view .LVU5
  34               	.LVL2:
  67:quantum/quantum.c **** 
  68:quantum/quantum.c ****     if (code & QK_RMODS_MIN) {  // Right mod flag is set
  35               		.loc 1 68 5 view .LVU6
  69:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_RCTL);
  70:quantum/quantum.c ****         if (code & QK_LSFT) mods_to_send |= MOD_BIT(KC_RSFT);
  36               		.loc 1 70 18 is_stmt 0 view .LVU7
  37 000a F901      		movw r30,r18
  38 000c EE27      		clr r30
  39 000e F270      		andi r31,2
  69:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_RCTL);
  40               		.loc 1 69 12 view .LVU8
  41 0010 832F      		mov r24,r19
  42 0012 8170      		andi r24,lo8(1)
  43 0014 B901      		movw r22,r18
  44 0016 6627      		clr r22
  45 0018 7470      		andi r23,4
  46 001a A901      		movw r20,r18
  47 001c 4427      		clr r20
  48 001e 5870      		andi r21,8
  68:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_RCTL);
  49               		.loc 1 68 8 view .LVU9
  50 0020 34FF      		sbrs r19,4
  51 0022 00C0      		rjmp .L3
  69:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_RCTL);
  52               		.loc 1 69 9 is_stmt 1 view .LVU10
  69:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_RCTL);
  53               		.loc 1 69 12 is_stmt 0 view .LVU11
  54 0024 8295      		swap r24
  55 0026 807F      		andi r24,lo8(-16)
  56               	.LVL3:
  57               		.loc 1 70 9 is_stmt 1 view .LVU12
  58               		.loc 1 70 12 is_stmt 0 view .LVU13
  59 0028 EF2B      		or r30,r31
  60 002a 01F0      		breq .L4
  61               		.loc 1 70 29 is_stmt 1 discriminator 1 view .LVU14
  62               		.loc 1 70 42 is_stmt 0 discriminator 1 view .LVU15
  63 002c 8062      		ori r24,lo8(32)
  64               	.LVL4:
  65               	.L4:
  71:quantum/quantum.c ****         if (code & QK_LALT) mods_to_send |= MOD_BIT(KC_RALT);
  66               		.loc 1 71 9 is_stmt 1 view .LVU16
  67               		.loc 1 71 12 is_stmt 0 view .LVU17
  68 002e 672B      		or r22,r23
  69 0030 01F0      		breq .L5
  70               		.loc 1 71 29 is_stmt 1 discriminator 1 view .LVU18
  71               		.loc 1 71 42 is_stmt 0 discriminator 1 view .LVU19
  72 0032 8064      		ori r24,lo8(64)
  73               	.LVL5:
  74               	.L5:
  72:quantum/quantum.c ****         if (code & QK_LGUI) mods_to_send |= MOD_BIT(KC_RGUI);
  75               		.loc 1 72 9 is_stmt 1 view .LVU20
  76               		.loc 1 72 12 is_stmt 0 view .LVU21
  77 0034 452B      		or r20,r21
  78 0036 01F0      		breq .L1
  79               		.loc 1 72 29 is_stmt 1 discriminator 1 view .LVU22
  80               		.loc 1 72 42 is_stmt 0 discriminator 1 view .LVU23
  81 0038 8068      		ori r24,lo8(-128)
  82               	.LVL6:
  83               		.loc 1 72 42 discriminator 1 view .LVU24
  84 003a 0895      		ret
  85               	.LVL7:
  86               	.L3:
  73:quantum/quantum.c ****     } else {
  74:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_LCTL);
  87               		.loc 1 74 9 is_stmt 1 view .LVU25
  75:quantum/quantum.c ****         if (code & QK_LSFT) mods_to_send |= MOD_BIT(KC_LSFT);
  88               		.loc 1 75 9 view .LVU26
  89               		.loc 1 75 12 is_stmt 0 view .LVU27
  90 003c EF2B      		or r30,r31
  91 003e 01F0      		breq .L6
  92               		.loc 1 75 29 is_stmt 1 discriminator 1 view .LVU28
  93               		.loc 1 75 42 is_stmt 0 discriminator 1 view .LVU29
  94 0040 8260      		ori r24,lo8(2)
  95               	.LVL8:
  96               	.L6:
  76:quantum/quantum.c ****         if (code & QK_LALT) mods_to_send |= MOD_BIT(KC_LALT);
  97               		.loc 1 76 9 is_stmt 1 view .LVU30
  98               		.loc 1 76 12 is_stmt 0 view .LVU31
  99 0042 672B      		or r22,r23
 100 0044 01F0      		breq .L7
 101               		.loc 1 76 29 is_stmt 1 discriminator 1 view .LVU32
 102               		.loc 1 76 42 is_stmt 0 discriminator 1 view .LVU33
 103 0046 8460      		ori r24,lo8(4)
 104               	.LVL9:
 105               	.L7:
  77:quantum/quantum.c ****         if (code & QK_LGUI) mods_to_send |= MOD_BIT(KC_LGUI);
 106               		.loc 1 77 9 is_stmt 1 view .LVU34
 107               		.loc 1 77 12 is_stmt 0 view .LVU35
 108 0048 452B      		or r20,r21
 109 004a 01F0      		breq .L1
 110               		.loc 1 77 29 is_stmt 1 discriminator 1 view .LVU36
 111               		.loc 1 77 42 is_stmt 0 discriminator 1 view .LVU37
 112 004c 8860      		ori r24,lo8(8)
 113               	.LVL10:
 114               		.loc 1 77 42 discriminator 1 view .LVU38
 115 004e 0895      		ret
 116               	.LVL11:
 117               	.L8:
  63:quantum/quantum.c ****     }
 118               		.loc 1 63 20 view .LVU39
 119 0050 80E0      		ldi r24,0
 120               	.L1:
 121               	/* epilogue start */
  78:quantum/quantum.c ****     }
  79:quantum/quantum.c **** 
  80:quantum/quantum.c ****     return mods_to_send;
  81:quantum/quantum.c **** }
 122               		.loc 1 81 1 view .LVU40
 123 0052 0895      		ret
 124               		.cfi_endproc
 125               	.LFE119:
 127               		.section	.text.do_code16,"ax",@progbits
 129               	do_code16:
 130               	.LVL12:
 131               	.LFB120:
  82:quantum/quantum.c **** 
  83:quantum/quantum.c **** static void do_code16(uint16_t code, void (*f)(uint8_t)) { f(extract_mod_bits(code)); }
 132               		.loc 1 83 58 is_stmt 1 view -0
 133               		.cfi_startproc
 134               		.loc 1 83 58 is_stmt 0 view .LVU42
 135 0000 CF93      		push r28
 136               	.LCFI0:
 137               		.cfi_def_cfa_offset 3
 138               		.cfi_offset 28, -2
 139 0002 DF93      		push r29
 140               	.LCFI1:
 141               		.cfi_def_cfa_offset 4
 142               		.cfi_offset 29, -3
 143               	/* prologue: function */
 144               	/* frame size = 0 */
 145               	/* stack size = 2 */
 146               	.L__stack_usage = 2
 147 0004 EB01      		movw r28,r22
 148               		.loc 1 83 60 is_stmt 1 view .LVU43
 149 0006 0E94 0000 		call extract_mod_bits
 150               	.LVL13:
 151               		.loc 1 83 60 is_stmt 0 view .LVU44
 152 000a FE01      		movw r30,r28
 153               	/* epilogue start */
 154               		.loc 1 83 87 view .LVU45
 155 000c DF91      		pop r29
 156 000e CF91      		pop r28
 157               	.LVL14:
 158               		.loc 1 83 60 view .LVU46
 159 0010 0994      		ijmp
 160               	.LVL15:
 161               		.loc 1 83 60 view .LVU47
 162               		.cfi_endproc
 163               	.LFE120:
 165               		.section	.text.register_code16,"ax",@progbits
 166               	.global	register_code16
 168               	register_code16:
 169               	.LVL16:
 170               	.LFB121:
  84:quantum/quantum.c **** 
  85:quantum/quantum.c **** void register_code16(uint16_t code) {
 171               		.loc 1 85 37 is_stmt 1 view -0
 172               		.cfi_startproc
 173               		.loc 1 85 37 is_stmt 0 view .LVU49
 174 0000 CF93      		push r28
 175               	.LCFI2:
 176               		.cfi_def_cfa_offset 3
 177               		.cfi_offset 28, -2
 178 0002 DF93      		push r29
 179               	.LCFI3:
 180               		.cfi_def_cfa_offset 4
 181               		.cfi_offset 29, -3
 182               	/* prologue: function */
 183               	/* frame size = 0 */
 184               	/* stack size = 2 */
 185               	.L__stack_usage = 2
 186 0004 EC01      		movw r28,r24
  86:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 187               		.loc 1 86 5 is_stmt 1 view .LVU50
 188               		.loc 1 86 9 is_stmt 0 view .LVU51
 189 0006 805E      		subi r24,-32
 190 0008 9109      		sbc r25,__zero_reg__
 191               	.LVL17:
 192               		.loc 1 86 8 view .LVU52
 193 000a 0897      		sbiw r24,8
 194 000c 00F0      		brlo .L29
  87:quantum/quantum.c ****         do_code16(code, register_mods);
  88:quantum/quantum.c ****     } else {
  89:quantum/quantum.c ****         do_code16(code, register_weak_mods);
 195               		.loc 1 89 9 discriminator 1 view .LVU53
 196 000e 60E0      		ldi r22,lo8(gs(register_weak_mods))
 197 0010 70E0      		ldi r23,hi8(gs(register_weak_mods))
  86:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 198               		.loc 1 86 22 discriminator 1 view .LVU54
 199 0012 2097      		sbiw r28,0
 200 0014 01F4      		brne .L32
 201               	.L29:
  87:quantum/quantum.c ****         do_code16(code, register_mods);
 202               		.loc 1 87 9 is_stmt 1 view .LVU55
 203 0016 60E0      		ldi r22,lo8(gs(register_mods))
 204 0018 70E0      		ldi r23,hi8(gs(register_mods))
 205               	.L32:
 206               		.loc 1 89 9 is_stmt 0 view .LVU56
 207 001a CE01      		movw r24,r28
 208 001c 0E94 0000 		call do_code16
 209               	.LVL18:
  90:quantum/quantum.c ****     }
  91:quantum/quantum.c ****     register_code(code);
 210               		.loc 1 91 5 is_stmt 1 view .LVU57
 211 0020 8C2F      		mov r24,r28
 212               	/* epilogue start */
  92:quantum/quantum.c **** }
 213               		.loc 1 92 1 is_stmt 0 view .LVU58
 214 0022 DF91      		pop r29
 215 0024 CF91      		pop r28
 216               	.LVL19:
  91:quantum/quantum.c **** }
 217               		.loc 1 91 5 view .LVU59
 218 0026 0C94 0000 		jmp register_code
 219               	.LVL20:
 220               		.cfi_endproc
 221               	.LFE121:
 223               		.section	.text.unregister_code16,"ax",@progbits
 224               	.global	unregister_code16
 226               	unregister_code16:
 227               	.LVL21:
 228               	.LFB122:
  93:quantum/quantum.c **** 
  94:quantum/quantum.c **** void unregister_code16(uint16_t code) {
 229               		.loc 1 94 39 is_stmt 1 view -0
 230               		.cfi_startproc
 231               		.loc 1 94 39 is_stmt 0 view .LVU61
 232 0000 CF93      		push r28
 233               	.LCFI4:
 234               		.cfi_def_cfa_offset 3
 235               		.cfi_offset 28, -2
 236 0002 DF93      		push r29
 237               	.LCFI5:
 238               		.cfi_def_cfa_offset 4
 239               		.cfi_offset 29, -3
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 242               	/* stack size = 2 */
 243               	.L__stack_usage = 2
 244 0004 EC01      		movw r28,r24
  95:quantum/quantum.c ****     unregister_code(code);
 245               		.loc 1 95 5 is_stmt 1 view .LVU62
 246 0006 0E94 0000 		call unregister_code
 247               	.LVL22:
  96:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 248               		.loc 1 96 5 view .LVU63
 249               		.loc 1 96 9 is_stmt 0 view .LVU64
 250 000a CE01      		movw r24,r28
 251 000c 805E      		subi r24,-32
 252 000e 9109      		sbc r25,__zero_reg__
 253               		.loc 1 96 8 view .LVU65
 254 0010 0897      		sbiw r24,8
 255 0012 00F0      		brlo .L34
  97:quantum/quantum.c ****         do_code16(code, unregister_mods);
  98:quantum/quantum.c ****     } else {
  99:quantum/quantum.c ****         do_code16(code, unregister_weak_mods);
 256               		.loc 1 99 9 discriminator 1 view .LVU66
 257 0014 60E0      		ldi r22,lo8(gs(unregister_weak_mods))
 258 0016 70E0      		ldi r23,hi8(gs(unregister_weak_mods))
  96:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 259               		.loc 1 96 22 discriminator 1 view .LVU67
 260 0018 2097      		sbiw r28,0
 261 001a 01F4      		brne .L36
 262               	.L34:
  97:quantum/quantum.c ****         do_code16(code, unregister_mods);
 263               		.loc 1 97 9 is_stmt 1 view .LVU68
 264 001c 60E0      		ldi r22,lo8(gs(unregister_mods))
 265 001e 70E0      		ldi r23,hi8(gs(unregister_mods))
 266               	.L36:
 267               		.loc 1 99 9 is_stmt 0 view .LVU69
 268 0020 CE01      		movw r24,r28
 269               	/* epilogue start */
 100:quantum/quantum.c ****     }
 101:quantum/quantum.c **** }
 270               		.loc 1 101 1 view .LVU70
 271 0022 DF91      		pop r29
 272 0024 CF91      		pop r28
 273               	.LVL23:
  99:quantum/quantum.c ****     }
 274               		.loc 1 99 9 view .LVU71
 275 0026 0C94 0000 		jmp do_code16
 276               	.LVL24:
  99:quantum/quantum.c ****     }
 277               		.loc 1 99 9 view .LVU72
 278               		.cfi_endproc
 279               	.LFE122:
 281               		.section	.text.tap_code16,"ax",@progbits
 282               	.global	tap_code16
 284               	tap_code16:
 285               	.LVL25:
 286               	.LFB123:
 102:quantum/quantum.c **** 
 103:quantum/quantum.c **** void tap_code16(uint16_t code) {
 287               		.loc 1 103 32 is_stmt 1 view -0
 288               		.cfi_startproc
 289               		.loc 1 103 32 is_stmt 0 view .LVU74
 290 0000 CF93      		push r28
 291               	.LCFI6:
 292               		.cfi_def_cfa_offset 3
 293               		.cfi_offset 28, -2
 294 0002 DF93      		push r29
 295               	.LCFI7:
 296               		.cfi_def_cfa_offset 4
 297               		.cfi_offset 29, -3
 298               	/* prologue: function */
 299               	/* frame size = 0 */
 300               	/* stack size = 2 */
 301               	.L__stack_usage = 2
 302 0004 D82F      		mov r29,r24
 303 0006 C92F      		mov r28,r25
 104:quantum/quantum.c ****     register_code16(code);
 304               		.loc 1 104 5 is_stmt 1 view .LVU75
 305 0008 0E94 0000 		call register_code16
 306               	.LVL26:
 105:quantum/quantum.c **** #if TAP_CODE_DELAY > 0
 106:quantum/quantum.c ****     wait_ms(TAP_CODE_DELAY);
 107:quantum/quantum.c **** #endif
 108:quantum/quantum.c ****     unregister_code16(code);
 307               		.loc 1 108 5 view .LVU76
 308 000c 8D2F      		mov r24,r29
 309 000e 9C2F      		mov r25,r28
 310               	/* epilogue start */
 109:quantum/quantum.c **** }
 311               		.loc 1 109 1 is_stmt 0 view .LVU77
 312 0010 DF91      		pop r29
 313 0012 CF91      		pop r28
 108:quantum/quantum.c **** }
 314               		.loc 1 108 5 view .LVU78
 315 0014 0C94 0000 		jmp unregister_code16
 316               	.LVL27:
 317               		.cfi_endproc
 318               	.LFE123:
 320               		.section	.text.process_action_kb,"ax",@progbits
 321               		.weak	process_action_kb
 323               	process_action_kb:
 324               	.LVL28:
 325               	.LFB124:
 110:quantum/quantum.c **** 
 111:quantum/quantum.c **** __attribute__((weak)) bool process_action_kb(keyrecord_t *record) { return true; }
 326               		.loc 1 111 67 is_stmt 1 view -0
 327               		.cfi_startproc
 328               	/* prologue: function */
 329               	/* frame size = 0 */
 330               	/* stack size = 0 */
 331               	.L__stack_usage = 0
 332               		.loc 1 111 69 view .LVU80
 333               		.loc 1 111 82 is_stmt 0 view .LVU81
 334 0000 81E0      		ldi r24,lo8(1)
 335               	.LVL29:
 336               	/* epilogue start */
 337               		.loc 1 111 82 view .LVU82
 338 0002 0895      		ret
 339               		.cfi_endproc
 340               	.LFE124:
 342               		.section	.text.process_record_user,"ax",@progbits
 343               		.weak	process_record_user
 345               	process_record_user:
 346               	.LVL30:
 347               	.LFB126:
 112:quantum/quantum.c **** 
 113:quantum/quantum.c **** __attribute__((weak)) bool process_record_kb(uint16_t keycode, keyrecord_t *record) { return proces
 114:quantum/quantum.c **** 
 115:quantum/quantum.c **** __attribute__((weak)) bool process_record_user(uint16_t keycode, keyrecord_t *record) { return true
 348               		.loc 1 115 87 is_stmt 1 view -0
 349               		.cfi_startproc
 350               	/* prologue: function */
 351               	/* frame size = 0 */
 352               	/* stack size = 0 */
 353               	.L__stack_usage = 0
 354               		.loc 1 115 89 view .LVU84
 355               		.loc 1 115 102 is_stmt 0 view .LVU85
 356 0000 81E0      		ldi r24,lo8(1)
 357               	.LVL31:
 358               	/* epilogue start */
 359               		.loc 1 115 102 view .LVU86
 360 0002 0895      		ret
 361               		.cfi_endproc
 362               	.LFE126:
 364               		.section	.text.process_record_kb,"ax",@progbits
 365               		.weak	process_record_kb
 367               	process_record_kb:
 368               	.LVL32:
 369               	.LFB125:
 113:quantum/quantum.c **** 
 370               		.loc 1 113 85 is_stmt 1 view -0
 371               		.cfi_startproc
 372               	/* prologue: function */
 373               	/* frame size = 0 */
 374               	/* stack size = 0 */
 375               	.L__stack_usage = 0
 113:quantum/quantum.c **** 
 376               		.loc 1 113 87 view .LVU88
 113:quantum/quantum.c **** 
 377               		.loc 1 113 94 is_stmt 0 view .LVU89
 378 0000 0C94 0000 		jmp process_record_user
 379               	.LVL33:
 113:quantum/quantum.c **** 
 380               		.loc 1 113 94 view .LVU90
 381               		.cfi_endproc
 382               	.LFE125:
 384               		.section	.text.post_process_record_user,"ax",@progbits
 385               		.weak	post_process_record_user
 387               	post_process_record_user:
 388               	.LVL34:
 389               	.LFB128:
 116:quantum/quantum.c **** 
 117:quantum/quantum.c **** __attribute__((weak)) void post_process_record_kb(uint16_t keycode, keyrecord_t *record) { post_pro
 118:quantum/quantum.c **** 
 119:quantum/quantum.c **** __attribute__((weak)) void post_process_record_user(uint16_t keycode, keyrecord_t *record) {}
 390               		.loc 1 119 92 is_stmt 1 view -0
 391               		.cfi_startproc
 392               	/* prologue: function */
 393               	/* frame size = 0 */
 394               	/* stack size = 0 */
 395               	.L__stack_usage = 0
 396               		.loc 1 119 93 view .LVU92
 397               	/* epilogue start */
 398 0000 0895      		ret
 399               		.cfi_endproc
 400               	.LFE128:
 402               		.section	.text.post_process_record_kb,"ax",@progbits
 403               		.weak	post_process_record_kb
 405               	post_process_record_kb:
 406               	.LVL35:
 407               	.LFB127:
 117:quantum/quantum.c **** 
 408               		.loc 1 117 90 view -0
 409               		.cfi_startproc
 410               	/* prologue: function */
 411               	/* frame size = 0 */
 412               	/* stack size = 0 */
 413               	.L__stack_usage = 0
 117:quantum/quantum.c **** 
 414               		.loc 1 117 92 view .LVU94
 415 0000 0C94 0000 		jmp post_process_record_user
 416               	.LVL36:
 117:quantum/quantum.c **** 
 417               		.loc 1 117 92 is_stmt 0 view .LVU95
 418               		.cfi_endproc
 419               	.LFE127:
 421               		.section	.text.get_event_keycode,"ax",@progbits
 422               	.global	get_event_keycode
 424               	get_event_keycode:
 425               	.LVL37:
 426               	.LFB131:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void reset_keyboard(void) {
 122:quantum/quantum.c ****     clear_keyboard();
 123:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 124:quantum/quantum.c ****     process_midi_all_notes_off();
 125:quantum/quantum.c **** #endif
 126:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 127:quantum/quantum.c **** #    ifndef NO_MUSIC_MODE
 128:quantum/quantum.c ****     music_all_notes_off();
 129:quantum/quantum.c **** #    endif
 130:quantum/quantum.c ****     uint16_t timer_start = timer_read();
 131:quantum/quantum.c ****     PLAY_SONG(goodbye_song);
 132:quantum/quantum.c ****     shutdown_user();
 133:quantum/quantum.c ****     while (timer_elapsed(timer_start) < 250) wait_ms(1);
 134:quantum/quantum.c ****     stop_all_notes();
 135:quantum/quantum.c **** #else
 136:quantum/quantum.c ****     shutdown_user();
 137:quantum/quantum.c ****     wait_ms(250);
 138:quantum/quantum.c **** #endif
 139:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 140:quantum/quantum.c ****     haptic_shutdown();
 141:quantum/quantum.c **** #endif
 142:quantum/quantum.c ****     bootloader_jump();
 143:quantum/quantum.c **** }
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** /* Convert record into usable keycode via the contained event. */
 146:quantum/quantum.c **** uint16_t get_record_keycode(keyrecord_t *record, bool update_layer_cache) {
 147:quantum/quantum.c **** #ifdef COMBO_ENABLE
 148:quantum/quantum.c ****     if (record->keycode) { return record->keycode; }
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c ****     return get_event_keycode(record->event, update_layer_cache);
 151:quantum/quantum.c **** }
 152:quantum/quantum.c **** 
 153:quantum/quantum.c **** 
 154:quantum/quantum.c **** /* Convert event into usable keycode. Checks the layer cache to ensure that it
 155:quantum/quantum.c ****  * retains the correct keycode after a layer change, if the key is still pressed.
 156:quantum/quantum.c ****  * "update_layer_cache" is to ensure that it only updates the layer cache when
 157:quantum/quantum.c ****  * appropriate, otherwise, it will update it and cause layer tap (and other keys)
 158:quantum/quantum.c ****  * from triggering properly.
 159:quantum/quantum.c ****  */
 160:quantum/quantum.c **** uint16_t get_event_keycode(keyevent_t event, bool update_layer_cache) {
 427               		.loc 1 160 71 is_stmt 1 view -0
 428               		.cfi_startproc
 429               		.loc 1 160 71 is_stmt 0 view .LVU97
 430 0000 1F93      		push r17
 431               	.LCFI8:
 432               		.cfi_def_cfa_offset 3
 433               		.cfi_offset 17, -2
 434 0002 CF93      		push r28
 435               	.LCFI9:
 436               		.cfi_def_cfa_offset 4
 437               		.cfi_offset 28, -3
 438 0004 DF93      		push r29
 439               	.LCFI10:
 440               		.cfi_def_cfa_offset 5
 441               		.cfi_offset 29, -4
 442 0006 00D0      		rcall .
 443 0008 00D0      		rcall .
 444 000a 0F92      		push __tmp_reg__
 445               	.LCFI11:
 446               		.cfi_def_cfa_offset 10
 447 000c CDB7      		in r28,__SP_L__
 448 000e DEB7      		in r29,__SP_H__
 449               	.LCFI12:
 450               		.cfi_def_cfa_register 28
 451               	/* prologue: function */
 452               	/* frame size = 5 */
 453               	/* stack size = 8 */
 454               	.L__stack_usage = 8
 455 0010 4983      		std Y+1,r20
 456 0012 5A83      		std Y+2,r21
 457 0014 6B83      		std Y+3,r22
 161:quantum/quantum.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 162:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 163:quantum/quantum.c ****     if (!disable_action_cache) {
 458               		.loc 1 163 5 is_stmt 1 view .LVU98
 459               		.loc 1 163 8 is_stmt 0 view .LVU99
 460 0016 3091 0000 		lds r19,disable_action_cache
 461 001a 8981      		ldd r24,Y+1
 462 001c 9A81      		ldd r25,Y+2
 463 001e 3111      		cpse r19,__zero_reg__
 464 0020 00C0      		rjmp .L44
 465               	.LBB4:
 164:quantum/quantum.c ****         uint8_t layer;
 466               		.loc 1 164 9 is_stmt 1 view .LVU100
 165:quantum/quantum.c **** 
 166:quantum/quantum.c ****         if (event.pressed && update_layer_cache) {
 467               		.loc 1 166 9 view .LVU101
 468               		.loc 1 166 12 is_stmt 0 view .LVU102
 469 0022 6623      		tst r22
 470 0024 01F0      		breq .L45
 471               		.loc 1 166 27 discriminator 1 view .LVU103
 472 0026 2223      		tst r18
 473 0028 01F0      		breq .L45
 167:quantum/quantum.c ****             layer = layer_switch_get_layer(event.key);
 474               		.loc 1 167 13 is_stmt 1 view .LVU104
 475               		.loc 1 167 21 is_stmt 0 view .LVU105
 476 002a 0E94 0000 		call layer_switch_get_layer
 477               	.LVL38:
 478               		.loc 1 167 21 view .LVU106
 479 002e 182F      		mov r17,r24
 480               	.LVL39:
 168:quantum/quantum.c ****             update_source_layers_cache(event.key, layer);
 481               		.loc 1 168 13 is_stmt 1 view .LVU107
 482 0030 682F      		mov r22,r24
 483 0032 8981      		ldd r24,Y+1
 484 0034 9A81      		ldd r25,Y+2
 485 0036 0E94 0000 		call update_source_layers_cache
 486               	.LVL40:
 487               	.L46:
 169:quantum/quantum.c ****         } else {
 170:quantum/quantum.c ****             layer = read_source_layers_cache(event.key);
 171:quantum/quantum.c ****         }
 172:quantum/quantum.c ****         return keymap_key_to_keycode(layer, event.key);
 488               		.loc 1 172 9 view .LVU108
 489               		.loc 1 172 16 is_stmt 0 view .LVU109
 490 003a 6981      		ldd r22,Y+1
 491 003c 7A81      		ldd r23,Y+2
 492 003e 812F      		mov r24,r17
 493               	.LVL41:
 494               	.L53:
 495               	/* epilogue start */
 496               		.loc 1 172 16 view .LVU110
 497               	.LBE4:
 173:quantum/quantum.c ****     } else
 174:quantum/quantum.c **** #endif
 175:quantum/quantum.c ****         return keymap_key_to_keycode(layer_switch_get_layer(event.key), event.key);
 176:quantum/quantum.c **** }
 498               		.loc 1 176 1 view .LVU111
 499 0040 0F90      		pop __tmp_reg__
 500 0042 0F90      		pop __tmp_reg__
 501 0044 0F90      		pop __tmp_reg__
 502 0046 0F90      		pop __tmp_reg__
 503 0048 0F90      		pop __tmp_reg__
 504 004a DF91      		pop r29
 505 004c CF91      		pop r28
 506 004e 1F91      		pop r17
 175:quantum/quantum.c **** }
 507               		.loc 1 175 16 view .LVU112
 508 0050 0C94 0000 		jmp keymap_key_to_keycode
 509               	.LVL42:
 510               	.L45:
 511               	.LBB5:
 170:quantum/quantum.c ****         }
 512               		.loc 1 170 13 is_stmt 1 view .LVU113
 170:quantum/quantum.c ****         }
 513               		.loc 1 170 21 is_stmt 0 view .LVU114
 514 0054 0E94 0000 		call read_source_layers_cache
 515               	.LVL43:
 170:quantum/quantum.c ****         }
 516               		.loc 1 170 21 view .LVU115
 517 0058 182F      		mov r17,r24
 518               	.LVL44:
 170:quantum/quantum.c ****         }
 519               		.loc 1 170 21 view .LVU116
 520 005a 00C0      		rjmp .L46
 521               	.LVL45:
 522               	.L44:
 170:quantum/quantum.c ****         }
 523               		.loc 1 170 21 view .LVU117
 524               	.LBE5:
 175:quantum/quantum.c **** }
 525               		.loc 1 175 9 is_stmt 1 view .LVU118
 175:quantum/quantum.c **** }
 526               		.loc 1 175 16 is_stmt 0 view .LVU119
 527 005c 0E94 0000 		call layer_switch_get_layer
 528               	.LVL46:
 175:quantum/quantum.c **** }
 529               		.loc 1 175 16 view .LVU120
 530 0060 6981      		ldd r22,Y+1
 531 0062 7A81      		ldd r23,Y+2
 532 0064 00C0      		rjmp .L53
 533               		.cfi_endproc
 534               	.LFE131:
 536               		.section	.text.get_record_keycode,"ax",@progbits
 537               	.global	get_record_keycode
 539               	get_record_keycode:
 540               	.LVL47:
 541               	.LFB130:
 146:quantum/quantum.c **** #ifdef COMBO_ENABLE
 542               		.loc 1 146 75 is_stmt 1 view -0
 543               		.cfi_startproc
 544               	/* prologue: function */
 545               	/* frame size = 0 */
 546               	/* stack size = 0 */
 547               	.L__stack_usage = 0
 146:quantum/quantum.c **** #ifdef COMBO_ENABLE
 548               		.loc 1 146 75 is_stmt 0 view .LVU122
 549 0000 FC01      		movw r30,r24
 550 0002 262F      		mov r18,r22
 150:quantum/quantum.c **** }
 551               		.loc 1 150 5 is_stmt 1 view .LVU123
 150:quantum/quantum.c **** }
 552               		.loc 1 150 12 is_stmt 0 view .LVU124
 553 0004 4081      		ld r20,Z
 554 0006 5181      		ldd r21,Z+1
 555 0008 6281      		ldd r22,Z+2
 556               	.LVL48:
 150:quantum/quantum.c **** }
 557               		.loc 1 150 12 view .LVU125
 558 000a 7381      		ldd r23,Z+3
 559 000c 8481      		ldd r24,Z+4
 560               	.LVL49:
 150:quantum/quantum.c **** }
 561               		.loc 1 150 12 view .LVU126
 562 000e 0C94 0000 		jmp get_event_keycode
 563               	.LVL50:
 150:quantum/quantum.c **** }
 564               		.loc 1 150 12 view .LVU127
 565               		.cfi_endproc
 566               	.LFE130:
 568               		.section	.text.pre_process_record_quantum,"ax",@progbits
 569               	.global	pre_process_record_quantum
 571               	pre_process_record_quantum:
 572               	.LVL51:
 573               	.LFB132:
 177:quantum/quantum.c **** 
 178:quantum/quantum.c **** /* Get keycode, and then process pre tapping functionality */
 179:quantum/quantum.c **** bool pre_process_record_quantum(keyrecord_t *record) {
 574               		.loc 1 179 54 is_stmt 1 view -0
 575               		.cfi_startproc
 576               	/* prologue: function */
 577               	/* frame size = 0 */
 578               	/* stack size = 0 */
 579               	.L__stack_usage = 0
 180:quantum/quantum.c ****     if (!(
 580               		.loc 1 180 5 view .LVU129
 181:quantum/quantum.c **** #ifdef COMBO_ENABLE
 182:quantum/quantum.c ****         process_combo(get_record_keycode(record, true), record) &&
 183:quantum/quantum.c **** #endif
 184:quantum/quantum.c ****         true)) {
 185:quantum/quantum.c ****         return false;
 186:quantum/quantum.c ****     }
 187:quantum/quantum.c ****     return true; // continue processing
 581               		.loc 1 187 5 view .LVU130
 188:quantum/quantum.c **** }
 582               		.loc 1 188 1 is_stmt 0 view .LVU131
 583 0000 81E0      		ldi r24,lo8(1)
 584               	.LVL52:
 585               	/* epilogue start */
 586               		.loc 1 188 1 view .LVU132
 587 0002 0895      		ret
 588               		.cfi_endproc
 589               	.LFE132:
 591               		.section	.text.post_process_record_quantum,"ax",@progbits
 592               	.global	post_process_record_quantum
 594               	post_process_record_quantum:
 595               	.LVL53:
 596               	.LFB133:
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** /* Get keycode, and then call keyboard function */
 191:quantum/quantum.c **** void post_process_record_quantum(keyrecord_t *record) {
 597               		.loc 1 191 55 is_stmt 1 view -0
 598               		.cfi_startproc
 599               		.loc 1 191 55 is_stmt 0 view .LVU134
 600 0000 CF93      		push r28
 601               	.LCFI13:
 602               		.cfi_def_cfa_offset 3
 603               		.cfi_offset 28, -2
 604 0002 DF93      		push r29
 605               	.LCFI14:
 606               		.cfi_def_cfa_offset 4
 607               		.cfi_offset 29, -3
 608               	/* prologue: function */
 609               	/* frame size = 0 */
 610               	/* stack size = 2 */
 611               	.L__stack_usage = 2
 612 0004 D82F      		mov r29,r24
 613 0006 C92F      		mov r28,r25
 192:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record, false);
 614               		.loc 1 192 5 is_stmt 1 view .LVU135
 615               		.loc 1 192 24 is_stmt 0 view .LVU136
 616 0008 60E0      		ldi r22,0
 617 000a 0E94 0000 		call get_record_keycode
 618               	.LVL54:
 193:quantum/quantum.c ****     post_process_record_kb(keycode, record);
 619               		.loc 1 193 5 is_stmt 1 view .LVU137
 620 000e 6D2F      		mov r22,r29
 621 0010 7C2F      		mov r23,r28
 622               	/* epilogue start */
 194:quantum/quantum.c **** }
 623               		.loc 1 194 1 is_stmt 0 view .LVU138
 624 0012 DF91      		pop r29
 625 0014 CF91      		pop r28
 193:quantum/quantum.c ****     post_process_record_kb(keycode, record);
 626               		.loc 1 193 5 view .LVU139
 627 0016 0C94 0000 		jmp post_process_record_kb
 628               	.LVL55:
 193:quantum/quantum.c ****     post_process_record_kb(keycode, record);
 629               		.loc 1 193 5 view .LVU140
 630               		.cfi_endproc
 631               	.LFE133:
 633               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 634               	.global	set_single_persistent_default_layer
 636               	set_single_persistent_default_layer:
 637               	.LVL56:
 638               	.LFB135:
 195:quantum/quantum.c **** 
 196:quantum/quantum.c **** /* Core keycode function, hands off handling to other functions,
 197:quantum/quantum.c ****     then processes internal quantum keycodes, and then processes
 198:quantum/quantum.c ****     ACTIONs.                                                      */
 199:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 200:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record, true);
 201:quantum/quantum.c **** 
 202:quantum/quantum.c ****     // This is how you use actions here
 203:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 204:quantum/quantum.c ****     //   action_t action;
 205:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 206:quantum/quantum.c ****     //   process_action(record, action);
 207:quantum/quantum.c ****     //   return false;
 208:quantum/quantum.c ****     // }
 209:quantum/quantum.c **** 
 210:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 211:quantum/quantum.c ****     if (velocikey_enabled() && record->event.pressed) {
 212:quantum/quantum.c ****         velocikey_accelerate();
 213:quantum/quantum.c ****     }
 214:quantum/quantum.c **** #endif
 215:quantum/quantum.c **** 
 216:quantum/quantum.c **** #ifdef WPM_ENABLE
 217:quantum/quantum.c ****     if (record->event.pressed) {
 218:quantum/quantum.c ****         update_wpm(keycode);
 219:quantum/quantum.c ****     }
 220:quantum/quantum.c **** #endif
 221:quantum/quantum.c **** 
 222:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 223:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 224:quantum/quantum.c **** #endif
 225:quantum/quantum.c **** 
 226:quantum/quantum.c ****     if (!(
 227:quantum/quantum.c **** #if defined(KEY_LOCK_ENABLE)
 228:quantum/quantum.c ****             // Must run first to be able to mask key_up events.
 229:quantum/quantum.c ****             process_key_lock(&keycode, record) &&
 230:quantum/quantum.c **** #endif
 231:quantum/quantum.c **** #if defined(DYNAMIC_MACRO_ENABLE) && !defined(DYNAMIC_MACRO_USER_CALL)
 232:quantum/quantum.c ****             // Must run asap to ensure all keypresses are recorded.
 233:quantum/quantum.c ****             process_dynamic_macro(keycode, record) &&
 234:quantum/quantum.c **** #endif
 235:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 236:quantum/quantum.c ****             process_clicky(keycode, record) &&
 237:quantum/quantum.c **** #endif
 238:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 239:quantum/quantum.c ****             process_haptic(keycode, record) &&
 240:quantum/quantum.c **** #endif
 241:quantum/quantum.c **** #if defined(VIA_ENABLE)
 242:quantum/quantum.c ****             process_record_via(keycode, record) &&
 243:quantum/quantum.c **** #endif
 244:quantum/quantum.c ****             process_record_kb(keycode, record) &&
 245:quantum/quantum.c **** #if defined(SEQUENCER_ENABLE)
 246:quantum/quantum.c ****             process_sequencer(keycode, record) &&
 247:quantum/quantum.c **** #endif
 248:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 249:quantum/quantum.c ****             process_midi(keycode, record) &&
 250:quantum/quantum.c **** #endif
 251:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 252:quantum/quantum.c ****             process_audio(keycode, record) &&
 253:quantum/quantum.c **** #endif
 254:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) || defined(LED_MATRIX_ENABLE)
 255:quantum/quantum.c ****             process_backlight(keycode, record) &&
 256:quantum/quantum.c **** #endif
 257:quantum/quantum.c **** #ifdef STENO_ENABLE
 258:quantum/quantum.c ****             process_steno(keycode, record) &&
 259:quantum/quantum.c **** #endif
 260:quantum/quantum.c **** #if (defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSIC_M
 261:quantum/quantum.c ****             process_music(keycode, record) &&
 262:quantum/quantum.c **** #endif
 263:quantum/quantum.c **** #ifdef KEY_OVERRIDE_ENABLE
 264:quantum/quantum.c ****             process_key_override(keycode, record) &&
 265:quantum/quantum.c **** #endif
 266:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 267:quantum/quantum.c ****             process_tap_dance(keycode, record) &&
 268:quantum/quantum.c **** #endif
 269:quantum/quantum.c **** #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 270:quantum/quantum.c ****             process_unicode_common(keycode, record) &&
 271:quantum/quantum.c **** #endif
 272:quantum/quantum.c **** #ifdef LEADER_ENABLE
 273:quantum/quantum.c ****             process_leader(keycode, record) &&
 274:quantum/quantum.c **** #endif
 275:quantum/quantum.c **** #ifdef PRINTING_ENABLE
 276:quantum/quantum.c ****             process_printer(keycode, record) &&
 277:quantum/quantum.c **** #endif
 278:quantum/quantum.c **** #ifdef AUTO_SHIFT_ENABLE
 279:quantum/quantum.c ****             process_auto_shift(keycode, record) &&
 280:quantum/quantum.c **** #endif
 281:quantum/quantum.c **** #ifdef TERMINAL_ENABLE
 282:quantum/quantum.c ****             process_terminal(keycode, record) &&
 283:quantum/quantum.c **** #endif
 284:quantum/quantum.c **** #ifdef SPACE_CADET_ENABLE
 285:quantum/quantum.c ****             process_space_cadet(keycode, record) &&
 286:quantum/quantum.c **** #endif
 287:quantum/quantum.c **** #ifdef MAGIC_KEYCODE_ENABLE
 288:quantum/quantum.c ****             process_magic(keycode, record) &&
 289:quantum/quantum.c **** #endif
 290:quantum/quantum.c **** #ifdef GRAVE_ESC_ENABLE
 291:quantum/quantum.c ****             process_grave_esc(keycode, record) &&
 292:quantum/quantum.c **** #endif
 293:quantum/quantum.c **** #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 294:quantum/quantum.c ****             process_rgb(keycode, record) &&
 295:quantum/quantum.c **** #endif
 296:quantum/quantum.c **** #ifdef JOYSTICK_ENABLE
 297:quantum/quantum.c ****             process_joystick(keycode, record) &&
 298:quantum/quantum.c **** #endif
 299:quantum/quantum.c ****             true)) {
 300:quantum/quantum.c ****         return false;
 301:quantum/quantum.c ****     }
 302:quantum/quantum.c **** 
 303:quantum/quantum.c ****     if (record->event.pressed) {
 304:quantum/quantum.c ****         switch (keycode) {
 305:quantum/quantum.c **** #ifndef NO_RESET
 306:quantum/quantum.c ****             case RESET:
 307:quantum/quantum.c ****                 reset_keyboard();
 308:quantum/quantum.c ****                 return false;
 309:quantum/quantum.c **** #endif
 310:quantum/quantum.c **** #ifndef NO_DEBUG
 311:quantum/quantum.c ****             case DEBUG:
 312:quantum/quantum.c ****                 debug_enable ^= 1;
 313:quantum/quantum.c ****                 if (debug_enable) {
 314:quantum/quantum.c ****                     print("DEBUG: enabled.\n");
 315:quantum/quantum.c ****                 } else {
 316:quantum/quantum.c ****                     print("DEBUG: disabled.\n");
 317:quantum/quantum.c ****                 }
 318:quantum/quantum.c **** #endif
 319:quantum/quantum.c ****                 return false;
 320:quantum/quantum.c ****             case EEPROM_RESET:
 321:quantum/quantum.c ****                 eeconfig_init();
 322:quantum/quantum.c ****                 return false;
 323:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 324:quantum/quantum.c ****             case VLK_TOG:
 325:quantum/quantum.c ****                 velocikey_toggle();
 326:quantum/quantum.c ****                 return false;
 327:quantum/quantum.c **** #endif
 328:quantum/quantum.c **** #ifdef BLUETOOTH_ENABLE
 329:quantum/quantum.c ****             case OUT_AUTO:
 330:quantum/quantum.c ****                 set_output(OUTPUT_AUTO);
 331:quantum/quantum.c ****                 return false;
 332:quantum/quantum.c ****             case OUT_USB:
 333:quantum/quantum.c ****                 set_output(OUTPUT_USB);
 334:quantum/quantum.c ****                 return false;
 335:quantum/quantum.c ****             case OUT_BT:
 336:quantum/quantum.c ****                 set_output(OUTPUT_BLUETOOTH);
 337:quantum/quantum.c ****                 return false;
 338:quantum/quantum.c **** #endif
 339:quantum/quantum.c **** #ifndef NO_ACTION_ONESHOT
 340:quantum/quantum.c ****             case ONESHOT_TOGGLE:
 341:quantum/quantum.c ****                 oneshot_toggle();
 342:quantum/quantum.c ****                 break;
 343:quantum/quantum.c ****             case ONESHOT_ENABLE:
 344:quantum/quantum.c ****                 oneshot_enable();
 345:quantum/quantum.c ****                 break;
 346:quantum/quantum.c ****             case ONESHOT_DISABLE:
 347:quantum/quantum.c ****                 oneshot_disable();
 348:quantum/quantum.c ****                 break;
 349:quantum/quantum.c **** #endif
 350:quantum/quantum.c ****         }
 351:quantum/quantum.c ****     }
 352:quantum/quantum.c **** 
 353:quantum/quantum.c ****     return process_action_kb(record);
 354:quantum/quantum.c **** }
 355:quantum/quantum.c **** 
 356:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 639               		.loc 1 356 65 is_stmt 1 view -0
 640               		.cfi_startproc
 641               		.loc 1 356 65 is_stmt 0 view .LVU142
 642 0000 0F93      		push r16
 643               	.LCFI15:
 644               		.cfi_def_cfa_offset 3
 645               		.cfi_offset 16, -2
 646 0002 1F93      		push r17
 647               	.LCFI16:
 648               		.cfi_def_cfa_offset 4
 649               		.cfi_offset 17, -3
 650 0004 CF93      		push r28
 651               	.LCFI17:
 652               		.cfi_def_cfa_offset 5
 653               		.cfi_offset 28, -4
 654 0006 DF93      		push r29
 655               	.LCFI18:
 656               		.cfi_def_cfa_offset 6
 657               		.cfi_offset 29, -5
 658 0008 00D0      		rcall .
 659 000a 00D0      		rcall .
 660               	.LCFI19:
 661               		.cfi_def_cfa_offset 10
 662 000c CDB7      		in r28,__SP_L__
 663 000e DEB7      		in r29,__SP_H__
 664               	.LCFI20:
 665               		.cfi_def_cfa_register 28
 666               	/* prologue: function */
 667               	/* frame size = 4 */
 668               	/* stack size = 8 */
 669               	.L__stack_usage = 8
 357:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 358:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 359:quantum/quantum.c **** #endif
 360:quantum/quantum.c ****     eeconfig_update_default_layer((layer_state_t)1 << default_layer);
 670               		.loc 1 360 5 is_stmt 1 view .LVU143
 671               		.loc 1 360 52 is_stmt 0 view .LVU144
 672 0010 41E0      		ldi r20,lo8(1)
 673 0012 50E0      		ldi r21,0
 674 0014 60E0      		ldi r22,0
 675 0016 70E0      		ldi r23,0
 676 0018 8A01      		movw r16,r20
 677 001a 9B01      		movw r18,r22
 678 001c 00C0      		rjmp 2f
 679               		1:
 680 001e 000F      		lsl r16
 681 0020 111F      		rol r17
 682 0022 221F      		rol r18
 683 0024 331F      		rol r19
 684               		2:
 685 0026 8A95      		dec r24
 686 0028 02F4      		brpl 1b
 687 002a 0983      		std Y+1,r16
 688 002c 1A83      		std Y+2,r17
 689 002e 2B83      		std Y+3,r18
 690 0030 3C83      		std Y+4,r19
 691               		.loc 1 360 5 view .LVU145
 692 0032 8981      		ldd r24,Y+1
 693               	.LVL57:
 694               		.loc 1 360 5 view .LVU146
 695 0034 0E94 0000 		call eeconfig_update_default_layer
 696               	.LVL58:
 361:quantum/quantum.c ****     default_layer_set((layer_state_t)1 << default_layer);
 697               		.loc 1 361 5 is_stmt 1 view .LVU147
 698 0038 6981      		ldd r22,Y+1
 699 003a 7A81      		ldd r23,Y+2
 700 003c 8B81      		ldd r24,Y+3
 701 003e 9C81      		ldd r25,Y+4
 702               	/* epilogue start */
 362:quantum/quantum.c **** }
 703               		.loc 1 362 1 is_stmt 0 view .LVU148
 704 0040 0F90      		pop __tmp_reg__
 705 0042 0F90      		pop __tmp_reg__
 706 0044 0F90      		pop __tmp_reg__
 707 0046 0F90      		pop __tmp_reg__
 708 0048 DF91      		pop r29
 709 004a CF91      		pop r28
 710 004c 1F91      		pop r17
 711 004e 0F91      		pop r16
 361:quantum/quantum.c ****     default_layer_set((layer_state_t)1 << default_layer);
 712               		.loc 1 361 5 view .LVU149
 713 0050 0C94 0000 		jmp default_layer_set
 714               	.LVL59:
 715               		.cfi_endproc
 716               	.LFE135:
 718               		.section	.text.update_tri_layer_state,"ax",@progbits
 719               	.global	update_tri_layer_state
 721               	update_tri_layer_state:
 722               	.LVL60:
 723               	.LFB136:
 363:quantum/quantum.c **** 
 364:quantum/quantum.c **** layer_state_t update_tri_layer_state(layer_state_t state, uint8_t layer1, uint8_t layer2, uint8_t l
 724               		.loc 1 364 107 is_stmt 1 view -0
 725               		.cfi_startproc
 726               		.loc 1 364 107 is_stmt 0 view .LVU151
 727 0000 8F92      		push r8
 728               	.LCFI21:
 729               		.cfi_def_cfa_offset 3
 730               		.cfi_offset 8, -2
 731 0002 9F92      		push r9
 732               	.LCFI22:
 733               		.cfi_def_cfa_offset 4
 734               		.cfi_offset 9, -3
 735 0004 AF92      		push r10
 736               	.LCFI23:
 737               		.cfi_def_cfa_offset 5
 738               		.cfi_offset 10, -4
 739 0006 BF92      		push r11
 740               	.LCFI24:
 741               		.cfi_def_cfa_offset 6
 742               		.cfi_offset 11, -5
 743 0008 CF92      		push r12
 744               	.LCFI25:
 745               		.cfi_def_cfa_offset 7
 746               		.cfi_offset 12, -6
 747 000a DF92      		push r13
 748               	.LCFI26:
 749               		.cfi_def_cfa_offset 8
 750               		.cfi_offset 13, -7
 751 000c EF92      		push r14
 752               	.LCFI27:
 753               		.cfi_def_cfa_offset 9
 754               		.cfi_offset 14, -8
 755 000e FF92      		push r15
 756               	.LCFI28:
 757               		.cfi_def_cfa_offset 10
 758               		.cfi_offset 15, -9
 759 0010 0F93      		push r16
 760               	.LCFI29:
 761               		.cfi_def_cfa_offset 11
 762               		.cfi_offset 16, -10
 763 0012 1F93      		push r17
 764               	.LCFI30:
 765               		.cfi_def_cfa_offset 12
 766               		.cfi_offset 17, -11
 767 0014 CF93      		push r28
 768               	.LCFI31:
 769               		.cfi_def_cfa_offset 13
 770               		.cfi_offset 28, -12
 771 0016 DF93      		push r29
 772               	.LCFI32:
 773               		.cfi_def_cfa_offset 14
 774               		.cfi_offset 29, -13
 775 0018 00D0      		rcall .
 776 001a 00D0      		rcall .
 777               	.LCFI33:
 778               		.cfi_def_cfa_offset 18
 779 001c CDB7      		in r28,__SP_L__
 780 001e DEB7      		in r29,__SP_H__
 781               	.LCFI34:
 782               		.cfi_def_cfa_register 28
 783               	/* prologue: function */
 784               	/* frame size = 4 */
 785               	/* stack size = 16 */
 786               	.L__stack_usage = 16
 787 0020 6B01      		movw r12,r22
 788 0022 7C01      		movw r14,r24
 365:quantum/quantum.c ****     layer_state_t mask12 = ((layer_state_t)1 << layer1) | ((layer_state_t)1 << layer2);
 789               		.loc 1 365 5 is_stmt 1 view .LVU152
 790               		.loc 1 365 46 is_stmt 0 view .LVU153
 791 0024 81E0      		ldi r24,lo8(1)
 792 0026 90E0      		ldi r25,0
 793 0028 A0E0      		ldi r26,0
 794 002a B0E0      		ldi r27,0
 795 002c 4C01      		movw r8,r24
 796 002e 5D01      		movw r10,r26
 797 0030 00C0      		rjmp 2f
 798               		1:
 799 0032 880C      		lsl r8
 800 0034 991C      		rol r9
 801 0036 AA1C      		rol r10
 802 0038 BB1C      		rol r11
 803               		2:
 804 003a 4A95      		dec r20
 805 003c 02F4      		brpl 1b
 806 003e B501      		movw r22,r10
 807               	.LVL61:
 808               		.loc 1 365 46 view .LVU154
 809 0040 A401      		movw r20,r8
 810               	.LVL62:
 811               		.loc 1 365 77 view .LVU155
 812 0042 4C01      		movw r8,r24
 813 0044 5D01      		movw r10,r26
 814 0046 00C0      		rjmp 2f
 815               		1:
 816 0048 880C      		lsl r8
 817 004a 991C      		rol r9
 818 004c AA1C      		rol r10
 819 004e BB1C      		rol r11
 820               		2:
 821 0050 2A95      		dec r18
 822 0052 02F4      		brpl 1b
 823               		.loc 1 365 19 view .LVU156
 824 0054 4829      		or r20,r8
 825 0056 5929      		or r21,r9
 826 0058 6A29      		or r22,r10
 827 005a 7B29      		or r23,r11
 828               	.LVL63:
 366:quantum/quantum.c ****     layer_state_t mask3  = (layer_state_t)1 << layer3;
 829               		.loc 1 366 5 is_stmt 1 view .LVU157
 830               		.loc 1 366 19 is_stmt 0 view .LVU158
 831 005c 00C0      		rjmp 2f
 832               		1:
 833 005e 880F      		lsl r24
 834 0060 991F      		rol r25
 835 0062 AA1F      		rol r26
 836 0064 BB1F      		rol r27
 837               		2:
 838 0066 0A95      		dec r16
 839 0068 02F4      		brpl 1b
 840               	.LVL64:
 367:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 841               		.loc 1 367 5 is_stmt 1 view .LVU159
 842               		.loc 1 367 19 is_stmt 0 view .LVU160
 843 006a 8A01      		movw r16,r20
 844               	.LVL65:
 845               		.loc 1 367 19 view .LVU161
 846 006c 9B01      		movw r18,r22
 847               	.LVL66:
 848               		.loc 1 367 19 view .LVU162
 849 006e 0C21      		and r16,r12
 850 0070 1D21      		and r17,r13
 851 0072 2E21      		and r18,r14
 852 0074 3F21      		and r19,r15
 853               		.loc 1 367 57 view .LVU163
 854 0076 0417      		cp r16,r20
 855 0078 1507      		cpc r17,r21
 856 007a 2607      		cpc r18,r22
 857 007c 3707      		cpc r19,r23
 858 007e 01F4      		brne .L59
 859               		.loc 1 367 57 discriminator 1 view .LVU164
 860 0080 9C01      		movw r18,r24
 861 0082 AD01      		movw r20,r26
 862               	.LVL67:
 863               		.loc 1 367 57 discriminator 1 view .LVU165
 864 0084 2C29      		or r18,r12
 865 0086 3D29      		or r19,r13
 866 0088 4E29      		or r20,r14
 867 008a 5F29      		or r21,r15
 868 008c 2983      		std Y+1,r18
 869 008e 3A83      		std Y+2,r19
 870 0090 4B83      		std Y+3,r20
 871 0092 5C83      		std Y+4,r21
 872               	.LVL68:
 873               	.L58:
 368:quantum/quantum.c **** }
 874               		.loc 1 368 1 view .LVU166
 875 0094 6981      		ldd r22,Y+1
 876 0096 7A81      		ldd r23,Y+2
 877 0098 8B81      		ldd r24,Y+3
 878 009a 9C81      		ldd r25,Y+4
 879               	/* epilogue start */
 880 009c 0F90      		pop __tmp_reg__
 881 009e 0F90      		pop __tmp_reg__
 882 00a0 0F90      		pop __tmp_reg__
 883 00a2 0F90      		pop __tmp_reg__
 884 00a4 DF91      		pop r29
 885 00a6 CF91      		pop r28
 886 00a8 1F91      		pop r17
 887 00aa 0F91      		pop r16
 888 00ac FF90      		pop r15
 889 00ae EF90      		pop r14
 890 00b0 DF90      		pop r13
 891 00b2 CF90      		pop r12
 892 00b4 BF90      		pop r11
 893 00b6 AF90      		pop r10
 894 00b8 9F90      		pop r9
 895 00ba 8F90      		pop r8
 896 00bc 0895      		ret
 897               	.LVL69:
 898               	.L59:
 367:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 899               		.loc 1 367 68 discriminator 2 view .LVU167
 900 00be 8095      		com r24
 901 00c0 9095      		com r25
 902 00c2 A095      		com r26
 903 00c4 B095      		com r27
 904               	.LVL70:
 367:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 905               		.loc 1 367 57 discriminator 2 view .LVU168
 906 00c6 4C01      		movw r8,r24
 907 00c8 5D01      		movw r10,r26
 908 00ca 8C20      		and r8,r12
 909 00cc 9D20      		and r9,r13
 910 00ce AE20      		and r10,r14
 911 00d0 BF20      		and r11,r15
 912 00d2 8982      		std Y+1,r8
 913 00d4 9A82      		std Y+2,r9
 914 00d6 AB82      		std Y+3,r10
 915 00d8 BC82      		std Y+4,r11
 916 00da 00C0      		rjmp .L58
 917               		.cfi_endproc
 918               	.LFE136:
 920               		.section	.text.update_tri_layer,"ax",@progbits
 921               	.global	update_tri_layer
 923               	update_tri_layer:
 924               	.LVL71:
 925               	.LFB137:
 369:quantum/quantum.c **** 
 370:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) { layer_state_set(update_tri_
 926               		.loc 1 370 71 is_stmt 1 view -0
 927               		.cfi_startproc
 928               		.loc 1 370 71 is_stmt 0 view .LVU170
 929 0000 0F93      		push r16
 930               	.LCFI35:
 931               		.cfi_def_cfa_offset 3
 932               		.cfi_offset 16, -2
 933 0002 CF93      		push r28
 934               	.LCFI36:
 935               		.cfi_def_cfa_offset 4
 936               		.cfi_offset 28, -3
 937 0004 DF93      		push r29
 938               	.LCFI37:
 939               		.cfi_def_cfa_offset 5
 940               		.cfi_offset 29, -4
 941 0006 00D0      		rcall .
 942 0008 00D0      		rcall .
 943               	.LCFI38:
 944               		.cfi_def_cfa_offset 9
 945 000a CDB7      		in r28,__SP_L__
 946 000c DEB7      		in r29,__SP_H__
 947               	.LCFI39:
 948               		.cfi_def_cfa_register 28
 949               	/* prologue: function */
 950               	/* frame size = 4 */
 951               	/* stack size = 7 */
 952               	.L__stack_usage = 7
 953 000e 262F      		mov r18,r22
 954 0010 042F      		mov r16,r20
 955               		.loc 1 370 73 is_stmt 1 view .LVU171
 956 0012 4091 0000 		lds r20,layer_state
 957 0016 5091 0000 		lds r21,layer_state+1
 958 001a 6091 0000 		lds r22,layer_state+2
 959 001e 7091 0000 		lds r23,layer_state+3
 960               	.LVL72:
 961               		.loc 1 370 73 is_stmt 0 view .LVU172
 962 0022 4983      		std Y+1,r20
 963 0024 5A83      		std Y+2,r21
 964 0026 6B83      		std Y+3,r22
 965 0028 7C83      		std Y+4,r23
 966 002a 482F      		mov r20,r24
 967 002c 6981      		ldd r22,Y+1
 968 002e 7A81      		ldd r23,Y+2
 969 0030 8B81      		ldd r24,Y+3
 970 0032 9C81      		ldd r25,Y+4
 971               	.LVL73:
 972               		.loc 1 370 73 view .LVU173
 973 0034 0E94 0000 		call update_tri_layer_state
 974               	.LVL74:
 975               	/* epilogue start */
 976               		.loc 1 370 151 view .LVU174
 977 0038 0F90      		pop __tmp_reg__
 978 003a 0F90      		pop __tmp_reg__
 979 003c 0F90      		pop __tmp_reg__
 980 003e 0F90      		pop __tmp_reg__
 981 0040 DF91      		pop r29
 982 0042 CF91      		pop r28
 983 0044 0F91      		pop r16
 984               	.LVL75:
 985               		.loc 1 370 73 view .LVU175
 986 0046 0C94 0000 		jmp layer_state_set
 987               	.LVL76:
 988               		.cfi_endproc
 989               	.LFE137:
 991               		.section	.text.matrix_init_quantum,"ax",@progbits
 992               	.global	matrix_init_quantum
 994               	matrix_init_quantum:
 995               	.LFB138:
 371:quantum/quantum.c **** 
 372:quantum/quantum.c **** void matrix_init_quantum() {
 996               		.loc 1 372 28 is_stmt 1 view -0
 997               		.cfi_startproc
 998               	/* prologue: function */
 999               	/* frame size = 0 */
 1000               	/* stack size = 0 */
 1001               	.L__stack_usage = 0
 373:quantum/quantum.c ****     magic();
 1002               		.loc 1 373 5 view .LVU177
 1003 0000 0E94 0000 		call magic
 1004               	.LVL77:
 374:quantum/quantum.c ****     led_init_ports();
 1005               		.loc 1 374 5 view .LVU178
 1006 0004 0E94 0000 		call led_init_ports
 1007               	.LVL78:
 375:quantum/quantum.c **** #ifdef BACKLIGHT_ENABLE
 376:quantum/quantum.c ****     backlight_init_ports();
 1008               		.loc 1 376 5 view .LVU179
 1009 0008 0E94 0000 		call backlight_init_ports
 1010               	.LVL79:
 377:quantum/quantum.c **** #endif
 378:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 379:quantum/quantum.c ****     audio_init();
 380:quantum/quantum.c **** #endif
 381:quantum/quantum.c **** #ifdef LED_MATRIX_ENABLE
 382:quantum/quantum.c ****     led_matrix_init();
 383:quantum/quantum.c **** #endif
 384:quantum/quantum.c **** #ifdef RGB_MATRIX_ENABLE
 385:quantum/quantum.c ****     rgb_matrix_init();
 386:quantum/quantum.c **** #endif
 387:quantum/quantum.c **** #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 388:quantum/quantum.c ****     unicode_input_mode_init();
 389:quantum/quantum.c **** #endif
 390:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 391:quantum/quantum.c ****     haptic_init();
 392:quantum/quantum.c **** #endif
 393:quantum/quantum.c **** #if defined(BLUETOOTH_ENABLE) && defined(OUTPUT_AUTO_ENABLE)
 394:quantum/quantum.c ****     set_output(OUTPUT_AUTO);
 395:quantum/quantum.c **** #endif
 396:quantum/quantum.c **** 
 397:quantum/quantum.c ****     matrix_init_kb();
 1011               		.loc 1 397 5 view .LVU180
 1012 000c 0C94 0000 		jmp matrix_init_kb
 1013               	.LVL80:
 1014               		.cfi_endproc
 1015               	.LFE138:
 1017               		.section	.text.matrix_scan_quantum,"ax",@progbits
 1018               	.global	matrix_scan_quantum
 1020               	matrix_scan_quantum:
 1021               	.LFB139:
 398:quantum/quantum.c **** }
 399:quantum/quantum.c **** 
 400:quantum/quantum.c **** void matrix_scan_quantum() {
 1022               		.loc 1 400 28 view -0
 1023               		.cfi_startproc
 1024               	/* prologue: function */
 1025               	/* frame size = 0 */
 1026               	/* stack size = 0 */
 1027               	.L__stack_usage = 0
 401:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && defined(AUDIO_INIT_DELAY)
 402:quantum/quantum.c ****     // There are some tasks that need to be run a little bit
 403:quantum/quantum.c ****     // after keyboard startup, or else they will not work correctly
 404:quantum/quantum.c ****     // because of interaction with the USB device state, which
 405:quantum/quantum.c ****     // may still be in flux...
 406:quantum/quantum.c ****     //
 407:quantum/quantum.c ****     // At the moment the only feature that needs this is the
 408:quantum/quantum.c ****     // startup song.
 409:quantum/quantum.c ****     static bool     delayed_tasks_run  = false;
 410:quantum/quantum.c ****     static uint16_t delayed_task_timer = 0;
 411:quantum/quantum.c ****     if (!delayed_tasks_run) {
 412:quantum/quantum.c ****         if (!delayed_task_timer) {
 413:quantum/quantum.c ****             delayed_task_timer = timer_read();
 414:quantum/quantum.c ****         } else if (timer_elapsed(delayed_task_timer) > 300) {
 415:quantum/quantum.c ****             audio_startup();
 416:quantum/quantum.c ****             delayed_tasks_run = true;
 417:quantum/quantum.c ****         }
 418:quantum/quantum.c ****     }
 419:quantum/quantum.c **** #endif
 420:quantum/quantum.c **** 
 421:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 422:quantum/quantum.c ****     music_task();
 423:quantum/quantum.c **** #endif
 424:quantum/quantum.c **** 
 425:quantum/quantum.c **** #ifdef KEY_OVERRIDE_ENABLE
 426:quantum/quantum.c ****     key_override_task();
 427:quantum/quantum.c **** #endif
 428:quantum/quantum.c **** 
 429:quantum/quantum.c **** #ifdef SEQUENCER_ENABLE
 430:quantum/quantum.c ****     sequencer_task();
 431:quantum/quantum.c **** #endif
 432:quantum/quantum.c **** 
 433:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 434:quantum/quantum.c ****     tap_dance_task();
 435:quantum/quantum.c **** #endif
 436:quantum/quantum.c **** 
 437:quantum/quantum.c **** #ifdef COMBO_ENABLE
 438:quantum/quantum.c ****     combo_task();
 439:quantum/quantum.c **** #endif
 440:quantum/quantum.c **** 
 441:quantum/quantum.c **** #ifdef LED_MATRIX_ENABLE
 442:quantum/quantum.c ****     led_matrix_task();
 443:quantum/quantum.c **** #endif
 444:quantum/quantum.c **** 
 445:quantum/quantum.c **** #ifdef WPM_ENABLE
 446:quantum/quantum.c ****     decay_wpm();
 447:quantum/quantum.c **** #endif
 448:quantum/quantum.c **** 
 449:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 450:quantum/quantum.c ****     haptic_task();
 451:quantum/quantum.c **** #endif
 452:quantum/quantum.c **** 
 453:quantum/quantum.c **** #ifdef DIP_SWITCH_ENABLE
 454:quantum/quantum.c ****     dip_switch_read(false);
 455:quantum/quantum.c **** #endif
 456:quantum/quantum.c **** 
 457:quantum/quantum.c **** #ifdef AUTO_SHIFT_ENABLE
 458:quantum/quantum.c ****     autoshift_matrix_scan();
 459:quantum/quantum.c **** #endif
 460:quantum/quantum.c **** 
 461:quantum/quantum.c ****     matrix_scan_kb();
 1028               		.loc 1 461 5 view .LVU182
 1029 0000 0C94 0000 		jmp matrix_scan_kb
 1030               	.LVL81:
 1031               		.cfi_endproc
 1032               	.LFE139:
 1034               		.section	.text.api_send_unicode,"ax",@progbits
 1035               	.global	api_send_unicode
 1037               	api_send_unicode:
 1038               	.LVL82:
 1039               	.LFB140:
 462:quantum/quantum.c **** }
 463:quantum/quantum.c **** 
 464:quantum/quantum.c **** #ifdef HD44780_ENABLED
 465:quantum/quantum.c **** #    include "hd44780.h"
 466:quantum/quantum.c **** #endif
 467:quantum/quantum.c **** 
 468:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 1040               		.loc 1 468 41 view -0
 1041               		.cfi_startproc
 1042               	/* prologue: function */
 1043               	/* frame size = 0 */
 1044               	/* stack size = 0 */
 1045               	.L__stack_usage = 0
 469:quantum/quantum.c **** #ifdef API_ENABLE
 470:quantum/quantum.c ****     uint8_t chunk[4];
 471:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
 472:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
 473:quantum/quantum.c **** #endif
 474:quantum/quantum.c **** }
 1046               		.loc 1 474 1 view .LVU184
 1047               	/* epilogue start */
 1048 0000 0895      		ret
 1049               		.cfi_endproc
 1050               	.LFE140:
 1052               		.section	.text.startup_user,"ax",@progbits
 1053               		.weak	startup_user
 1055               	startup_user:
 1056               	.LFB141:
 475:quantum/quantum.c **** 
 476:quantum/quantum.c **** //------------------------------------------------------------------------------
 477:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
 478:quantum/quantum.c **** // different events such as startup and bootloader jump
 479:quantum/quantum.c **** 
 480:quantum/quantum.c **** __attribute__((weak)) void startup_user() {}
 1057               		.loc 1 480 43 view -0
 1058               		.cfi_startproc
 1059               	/* prologue: function */
 1060               	/* frame size = 0 */
 1061               	/* stack size = 0 */
 1062               	.L__stack_usage = 0
 1063               		.loc 1 480 44 view .LVU186
 1064               	/* epilogue start */
 1065 0000 0895      		ret
 1066               		.cfi_endproc
 1067               	.LFE141:
 1069               		.section	.text.shutdown_user,"ax",@progbits
 1070               		.weak	shutdown_user
 1072               	shutdown_user:
 1073               	.LFB144:
 1074               		.cfi_startproc
 1075               	/* prologue: function */
 1076               	/* frame size = 0 */
 1077               	/* stack size = 0 */
 1078               	.L__stack_usage = 0
 1079               	/* epilogue start */
 1080 0000 0895      		ret
 1081               		.cfi_endproc
 1082               	.LFE144:
 1084               		.section	.text.reset_keyboard,"ax",@progbits
 1085               	.global	reset_keyboard
 1087               	reset_keyboard:
 1088               	.LFB129:
 121:quantum/quantum.c ****     clear_keyboard();
 1089               		.loc 1 121 27 view -0
 1090               		.cfi_startproc
 1091               	/* prologue: function */
 1092               	/* frame size = 0 */
 1093               	/* stack size = 0 */
 1094               	.L__stack_usage = 0
 122:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 1095               		.loc 1 122 5 view .LVU188
 1096 0000 0E94 0000 		call clear_keyboard
 1097               	.LVL83:
 136:quantum/quantum.c ****     wait_ms(250);
 1098               		.loc 1 136 5 view .LVU189
 1099 0004 0E94 0000 		call shutdown_user
 1100               	.LVL84:
 137:quantum/quantum.c **** #endif
 1101               		.loc 1 137 5 view .LVU190
 137:quantum/quantum.c **** #endif
 1102               		.loc 1 137 5 view .LVU191
 137:quantum/quantum.c **** #endif
 1103               		.loc 1 137 5 view .LVU192
 1104               	.LBB6:
 1105               	.LBI6:
 1106               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 1107               		.loc 2 166 1 view .LVU193
 1108               	.LBB7:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 1109               		.loc 2 168 2 view .LVU194
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 1110               		.loc 2 172 2 view .LVU195
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1111               		.loc 2 173 2 view .LVU196
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1112               		.loc 2 174 2 view .LVU197
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 1113               		.loc 2 184 3 view .LVU198
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1114               		.loc 2 187 2 view .LVU199
 1115 0008 2FEF      		ldi r18,lo8(799999)
 1116 000a 84E3      		ldi r24,hi8(799999)
 1117 000c 9CE0      		ldi r25,hlo8(799999)
 1118 000e 2150      	1:	subi r18,1
 1119 0010 8040      		sbci r24,0
 1120 0012 9040      		sbci r25,0
 1121 0014 01F4      		brne 1b
 1122 0016 00C0      		rjmp .
 1123 0018 0000      		nop
 1124               	.LVL85:
 1125               		.loc 2 187 2 is_stmt 0 view .LVU200
 1126               	.LBE7:
 1127               	.LBE6:
 137:quantum/quantum.c **** #endif
 1128               		.loc 1 137 5 is_stmt 1 view .LVU201
 142:quantum/quantum.c **** }
 1129               		.loc 1 142 5 view .LVU202
 1130 001a 0C94 0000 		jmp bootloader_jump
 1131               	.LVL86:
 1132               		.cfi_endproc
 1133               	.LFE129:
 1135               		.section	.text.process_record_quantum,"ax",@progbits
 1136               	.global	process_record_quantum
 1138               	process_record_quantum:
 1139               	.LVL87:
 1140               	.LFB134:
 199:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record, true);
 1141               		.loc 1 199 50 view -0
 1142               		.cfi_startproc
 199:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record, true);
 1143               		.loc 1 199 50 is_stmt 0 view .LVU204
 1144 0000 0F93      		push r16
 1145               	.LCFI40:
 1146               		.cfi_def_cfa_offset 3
 1147               		.cfi_offset 16, -2
 1148 0002 1F93      		push r17
 1149               	.LCFI41:
 1150               		.cfi_def_cfa_offset 4
 1151               		.cfi_offset 17, -3
 1152 0004 CF93      		push r28
 1153               	.LCFI42:
 1154               		.cfi_def_cfa_offset 5
 1155               		.cfi_offset 28, -4
 1156 0006 DF93      		push r29
 1157               	.LCFI43:
 1158               		.cfi_def_cfa_offset 6
 1159               		.cfi_offset 29, -5
 1160               	/* prologue: function */
 1161               	/* frame size = 0 */
 1162               	/* stack size = 4 */
 1163               	.L__stack_usage = 4
 1164 0008 8C01      		movw r16,r24
 200:quantum/quantum.c **** 
 1165               		.loc 1 200 5 is_stmt 1 view .LVU205
 200:quantum/quantum.c **** 
 1166               		.loc 1 200 24 is_stmt 0 view .LVU206
 1167 000a 61E0      		ldi r22,lo8(1)
 1168 000c 0E94 0000 		call get_record_keycode
 1169               	.LVL88:
 200:quantum/quantum.c **** 
 1170               		.loc 1 200 24 view .LVU207
 1171 0010 EC01      		movw r28,r24
 1172               	.LVL89:
 226:quantum/quantum.c **** #if defined(KEY_LOCK_ENABLE)
 1173               		.loc 1 226 5 is_stmt 1 view .LVU208
 244:quantum/quantum.c **** #if defined(SEQUENCER_ENABLE)
 1174               		.loc 1 244 13 is_stmt 0 view .LVU209
 1175 0012 B801      		movw r22,r16
 1176 0014 0E94 0000 		call process_record_kb
 1177               	.LVL90:
 291:quantum/quantum.c **** #endif
 1178               		.loc 1 291 48 view .LVU210
 1179 0018 8823      		tst r24
 1180 001a 01F4      		brne .+2
 1181 001c 00C0      		rjmp .L68
 255:quantum/quantum.c **** #endif
 1182               		.loc 1 255 13 view .LVU211
 1183 001e B801      		movw r22,r16
 1184 0020 CE01      		movw r24,r28
 1185 0022 0E94 0000 		call process_backlight
 1186               	.LVL91:
 244:quantum/quantum.c **** #if defined(SEQUENCER_ENABLE)
 1187               		.loc 1 244 48 view .LVU212
 1188 0026 8823      		tst r24
 1189 0028 01F0      		breq .L68
 285:quantum/quantum.c **** #endif
 1190               		.loc 1 285 13 view .LVU213
 1191 002a B801      		movw r22,r16
 1192 002c CE01      		movw r24,r28
 1193 002e 0E94 0000 		call process_space_cadet
 1194               	.LVL92:
 255:quantum/quantum.c **** #endif
 1195               		.loc 1 255 48 view .LVU214
 1196 0032 8823      		tst r24
 1197 0034 01F0      		breq .L68
 288:quantum/quantum.c **** #endif
 1198               		.loc 1 288 13 view .LVU215
 1199 0036 B801      		movw r22,r16
 1200 0038 CE01      		movw r24,r28
 1201 003a 0E94 0000 		call process_magic
 1202               	.LVL93:
 285:quantum/quantum.c **** #endif
 1203               		.loc 1 285 50 view .LVU216
 1204 003e 8823      		tst r24
 1205 0040 01F0      		breq .L68
 291:quantum/quantum.c **** #endif
 1206               		.loc 1 291 13 view .LVU217
 1207 0042 B801      		movw r22,r16
 1208 0044 CE01      		movw r24,r28
 1209 0046 0E94 0000 		call process_grave_esc
 1210               	.LVL94:
 288:quantum/quantum.c **** #endif
 1211               		.loc 1 288 44 view .LVU218
 1212 004a 8823      		tst r24
 1213 004c 01F0      		breq .L68
 294:quantum/quantum.c **** #endif
 1214               		.loc 1 294 13 discriminator 2 view .LVU219
 1215 004e B801      		movw r22,r16
 1216 0050 CE01      		movw r24,r28
 1217 0052 0E94 0000 		call process_rgb
 1218               	.LVL95:
 291:quantum/quantum.c **** #endif
 1219               		.loc 1 291 48 discriminator 2 view .LVU220
 1220 0056 8823      		tst r24
 1221 0058 01F0      		breq .L68
 303:quantum/quantum.c ****         switch (keycode) {
 1222               		.loc 1 303 5 is_stmt 1 view .LVU221
 303:quantum/quantum.c ****         switch (keycode) {
 1223               		.loc 1 303 8 is_stmt 0 view .LVU222
 1224 005a F801      		movw r30,r16
 1225 005c 8281      		ldd r24,Z+2
 1226 005e 8823      		tst r24
 1227 0060 01F0      		breq .L72
 304:quantum/quantum.c **** #ifndef NO_RESET
 1228               		.loc 1 304 9 is_stmt 1 view .LVU223
 1229 0062 CB35      		cpi r28,91
 1230 0064 FDE5      		ldi r31,93
 1231 0066 DF07      		cpc r29,r31
 1232 0068 01F0      		breq .L73
 1233 006a 00F4      		brsh .L74
 1234 006c C115      		cp r28,__zero_reg__
 1235 006e ECE5      		ldi r30,92
 1236 0070 DE07      		cpc r29,r30
 1237 0072 01F0      		breq .L75
 1238 0074 CF3D      		cpi r28,-33
 1239 0076 DC45      		sbci r29,92
 1240 0078 01F0      		breq .L76
 1241               	.L72:
 353:quantum/quantum.c **** }
 1242               		.loc 1 353 5 view .LVU224
 353:quantum/quantum.c **** }
 1243               		.loc 1 353 12 is_stmt 0 view .LVU225
 1244 007a C801      		movw r24,r16
 1245               	/* epilogue start */
 354:quantum/quantum.c **** 
 1246               		.loc 1 354 1 view .LVU226
 1247 007c DF91      		pop r29
 1248 007e CF91      		pop r28
 1249               	.LVL96:
 354:quantum/quantum.c **** 
 1250               		.loc 1 354 1 view .LVU227
 1251 0080 1F91      		pop r17
 1252 0082 0F91      		pop r16
 1253               	.LVL97:
 353:quantum/quantum.c **** }
 1254               		.loc 1 353 12 view .LVU228
 1255 0084 0C94 0000 		jmp process_action_kb
 1256               	.LVL98:
 1257               	.L74:
 304:quantum/quantum.c **** #ifndef NO_RESET
 1258               		.loc 1 304 9 view .LVU229
 1259 0088 CC35      		cpi r28,92
 1260 008a 8DE5      		ldi r24,93
 1261 008c D807      		cpc r29,r24
 1262 008e 01F0      		breq .L77
 1263 0090 CD35      		cpi r28,93
 1264 0092 DD45      		sbci r29,93
 1265 0094 01F4      		brne .L72
 341:quantum/quantum.c ****                 break;
 1266               		.loc 1 341 17 is_stmt 1 view .LVU230
 1267 0096 0E94 0000 		call oneshot_toggle
 1268               	.LVL99:
 342:quantum/quantum.c ****             case ONESHOT_ENABLE:
 1269               		.loc 1 342 17 view .LVU231
 1270 009a 00C0      		rjmp .L72
 1271               	.L75:
 307:quantum/quantum.c ****                 return false;
 1272               		.loc 1 307 17 view .LVU232
 1273 009c 0E94 0000 		call reset_keyboard
 1274               	.LVL100:
 308:quantum/quantum.c **** #endif
 1275               		.loc 1 308 17 view .LVU233
 1276               	.L68:
 354:quantum/quantum.c **** 
 1277               		.loc 1 354 1 is_stmt 0 view .LVU234
 1278 00a0 80E0      		ldi r24,0
 1279               	/* epilogue start */
 1280 00a2 DF91      		pop r29
 1281 00a4 CF91      		pop r28
 1282               	.LVL101:
 354:quantum/quantum.c **** 
 1283               		.loc 1 354 1 view .LVU235
 1284 00a6 1F91      		pop r17
 1285 00a8 0F91      		pop r16
 1286               	.LVL102:
 354:quantum/quantum.c **** 
 1287               		.loc 1 354 1 view .LVU236
 1288 00aa 0895      		ret
 1289               	.LVL103:
 1290               	.L76:
 321:quantum/quantum.c ****                 return false;
 1291               		.loc 1 321 17 is_stmt 1 view .LVU237
 1292 00ac 0E94 0000 		call eeconfig_init
 1293               	.LVL104:
 322:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 1294               		.loc 1 322 17 view .LVU238
 322:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 1295               		.loc 1 322 24 is_stmt 0 view .LVU239
 1296 00b0 00C0      		rjmp .L68
 1297               	.L73:
 344:quantum/quantum.c ****                 break;
 1298               		.loc 1 344 17 is_stmt 1 view .LVU240
 1299 00b2 0E94 0000 		call oneshot_enable
 1300               	.LVL105:
 345:quantum/quantum.c ****             case ONESHOT_DISABLE:
 1301               		.loc 1 345 17 view .LVU241
 1302 00b6 00C0      		rjmp .L72
 1303               	.L77:
 347:quantum/quantum.c ****                 break;
 1304               		.loc 1 347 17 view .LVU242
 1305 00b8 0E94 0000 		call oneshot_disable
 1306               	.LVL106:
 348:quantum/quantum.c **** #endif
 1307               		.loc 1 348 17 view .LVU243
 1308 00bc 00C0      		rjmp .L72
 1309               		.cfi_endproc
 1310               	.LFE134:
 1312               		.text
 1313               	.Letext0:
 1314               		.file 3 "/usr/avr/include/stdint.h"
 1315               		.file 4 "quantum/keyboard.h"
 1316               		.file 5 "quantum/action.h"
 1317               		.file 6 "quantum/keycode.h"
 1318               		.file 7 "quantum/quantum_keycodes.h"
 1319               		.file 8 "quantum/action_layer.h"
 1320               		.file 9 "quantum/matrix.h"
 1321               		.file 10 "quantum/backlight/backlight.h"
 1322               		.file 11 "quantum/led.h"
 1323               		.file 12 "quantum/bootmagic/magic.h"
 1324               		.file 13 "quantum/eeconfig.h"
 1325               		.file 14 "quantum/action_util.h"
 1326               		.file 15 "quantum/process_keycode/process_rgb.h"
 1327               		.file 16 "quantum/process_keycode/process_grave_esc.h"
 1328               		.file 17 "quantum/process_keycode/process_magic.h"
 1329               		.file 18 "quantum/process_keycode/process_space_cadet.h"
 1330               		.file 19 "quantum/process_keycode/process_backlight.h"
 1331               		.file 20 "quantum/keymap.h"
 1332               		.file 21 "/usr/avr/include/math.h"
 1333               		.file 22 "tmk_core/common/bootloader.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/ccqf7DGY.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccqf7DGY.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccqf7DGY.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccqf7DGY.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccqf7DGY.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccqf7DGY.s:13     .text.extract_mod_bits:0000000000000000 extract_mod_bits
     /tmp/ccqf7DGY.s:129    .text.do_code16:0000000000000000 do_code16
     /tmp/ccqf7DGY.s:168    .text.register_code16:0000000000000000 register_code16
     /tmp/ccqf7DGY.s:226    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/ccqf7DGY.s:284    .text.tap_code16:0000000000000000 tap_code16
     /tmp/ccqf7DGY.s:323    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/ccqf7DGY.s:345    .text.process_record_user:0000000000000000 process_record_user
     /tmp/ccqf7DGY.s:367    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/ccqf7DGY.s:387    .text.post_process_record_user:0000000000000000 post_process_record_user
     /tmp/ccqf7DGY.s:405    .text.post_process_record_kb:0000000000000000 post_process_record_kb
     /tmp/ccqf7DGY.s:424    .text.get_event_keycode:0000000000000000 get_event_keycode
     /tmp/ccqf7DGY.s:539    .text.get_record_keycode:0000000000000000 get_record_keycode
     /tmp/ccqf7DGY.s:571    .text.pre_process_record_quantum:0000000000000000 pre_process_record_quantum
     /tmp/ccqf7DGY.s:594    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
     /tmp/ccqf7DGY.s:636    .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/ccqf7DGY.s:721    .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
     /tmp/ccqf7DGY.s:923    .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/ccqf7DGY.s:994    .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccqf7DGY.s:1020   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccqf7DGY.s:1037   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/ccqf7DGY.s:1055   .text.startup_user:0000000000000000 startup_user
     /tmp/ccqf7DGY.s:1072   .text.shutdown_user:0000000000000000 shutdown_user
     /tmp/ccqf7DGY.s:1087   .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/ccqf7DGY.s:1138   .text.process_record_quantum:0000000000000000 process_record_quantum

UNDEFINED SYMBOLS
register_weak_mods
register_mods
register_code
unregister_code
unregister_weak_mods
unregister_mods
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
keymap_key_to_keycode
read_source_layers_cache
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
magic
led_init_ports
backlight_init_ports
matrix_init_kb
matrix_scan_kb
clear_keyboard
bootloader_jump
process_backlight
process_space_cadet
process_magic
process_grave_esc
process_rgb
oneshot_toggle
eeconfig_init
oneshot_enable
oneshot_disable
