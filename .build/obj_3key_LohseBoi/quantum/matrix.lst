   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.setPinInputHigh_atomic,"ax",@progbits
  12               	setPinInputHigh_atomic:
  13               	.LVL0:
  14               	.LFB120:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012-2018 Jun Wako, Jack Humbert, Yiancar
   3:quantum/matrix.c **** 
   4:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   6:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/matrix.c **** (at your option) any later version.
   8:quantum/matrix.c **** 
   9:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  10:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/matrix.c **** GNU General Public License for more details.
  13:quantum/matrix.c **** 
  14:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  15:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/matrix.c **** */
  17:quantum/matrix.c **** #include <stdint.h>
  18:quantum/matrix.c **** #include <stdbool.h>
  19:quantum/matrix.c **** #include <string.h>
  20:quantum/matrix.c **** #include "util.h"
  21:quantum/matrix.c **** #include "matrix.h"
  22:quantum/matrix.c **** #include "debounce.h"
  23:quantum/matrix.c **** #include "quantum.h"
  24:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
  25:quantum/matrix.c **** #    include "split_common/split_util.h"
  26:quantum/matrix.c **** #    include "split_common/transactions.h"
  27:quantum/matrix.c **** 
  28:quantum/matrix.c **** #    define ROWS_PER_HAND (MATRIX_ROWS / 2)
  29:quantum/matrix.c **** #else
  30:quantum/matrix.c **** #    define ROWS_PER_HAND (MATRIX_ROWS)
  31:quantum/matrix.c **** #endif
  32:quantum/matrix.c **** 
  33:quantum/matrix.c **** #ifdef DIRECT_PINS_RIGHT
  34:quantum/matrix.c **** #    define SPLIT_MUTABLE
  35:quantum/matrix.c **** #else
  36:quantum/matrix.c **** #    define SPLIT_MUTABLE const
  37:quantum/matrix.c **** #endif
  38:quantum/matrix.c **** #ifdef MATRIX_ROW_PINS_RIGHT
  39:quantum/matrix.c **** #    define SPLIT_MUTABLE_ROW
  40:quantum/matrix.c **** #else
  41:quantum/matrix.c **** #    define SPLIT_MUTABLE_ROW const
  42:quantum/matrix.c **** #endif
  43:quantum/matrix.c **** #ifdef MATRIX_COL_PINS_RIGHT
  44:quantum/matrix.c **** #    define SPLIT_MUTABLE_COL
  45:quantum/matrix.c **** #else
  46:quantum/matrix.c **** #    define SPLIT_MUTABLE_COL const
  47:quantum/matrix.c **** #endif
  48:quantum/matrix.c **** 
  49:quantum/matrix.c **** #ifdef DIRECT_PINS
  50:quantum/matrix.c **** static SPLIT_MUTABLE pin_t direct_pins[MATRIX_ROWS][MATRIX_COLS] = DIRECT_PINS;
  51:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL) || (DIODE_DIRECTION == COL2ROW)
  52:quantum/matrix.c **** #    ifdef MATRIX_ROW_PINS
  53:quantum/matrix.c **** static SPLIT_MUTABLE_ROW pin_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  54:quantum/matrix.c **** #    endif  // MATRIX_ROW_PINS
  55:quantum/matrix.c **** #    ifdef MATRIX_COL_PINS
  56:quantum/matrix.c **** static SPLIT_MUTABLE_COL pin_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  57:quantum/matrix.c **** #    endif  // MATRIX_COL_PINS
  58:quantum/matrix.c **** #endif
  59:quantum/matrix.c **** 
  60:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  61:quantum/matrix.c **** extern matrix_row_t raw_matrix[MATRIX_ROWS];  // raw values
  62:quantum/matrix.c **** extern matrix_row_t matrix[MATRIX_ROWS];      // debounced values
  63:quantum/matrix.c **** 
  64:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
  65:quantum/matrix.c **** // row offsets for each hand
  66:quantum/matrix.c **** uint8_t thisHand, thatHand;
  67:quantum/matrix.c **** #endif
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** // user-defined overridable functions
  70:quantum/matrix.c **** __attribute__((weak)) void matrix_init_pins(void);
  71:quantum/matrix.c **** __attribute__((weak)) void matrix_read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_r
  72:quantum/matrix.c **** __attribute__((weak)) void matrix_read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_c
  73:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
  74:quantum/matrix.c **** __attribute__((weak)) void matrix_slave_scan_kb(void) { matrix_slave_scan_user(); }
  75:quantum/matrix.c **** __attribute__((weak)) void matrix_slave_scan_user(void) {}
  76:quantum/matrix.c **** #endif
  77:quantum/matrix.c **** 
  78:quantum/matrix.c **** static inline void setPinOutput_writeLow(pin_t pin) {
  79:quantum/matrix.c ****     ATOMIC_BLOCK_FORCEON {
  80:quantum/matrix.c ****         setPinOutput(pin);
  81:quantum/matrix.c ****         writePinLow(pin);
  82:quantum/matrix.c ****     }
  83:quantum/matrix.c **** }
  84:quantum/matrix.c **** 
  85:quantum/matrix.c **** static inline void setPinInputHigh_atomic(pin_t pin) {
  16               		.loc 1 85 54 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  86:quantum/matrix.c ****     ATOMIC_BLOCK_FORCEON { setPinInputHigh(pin); }
  22               		.loc 1 86 5 view .LVU1
  23               	.LBB12:
  24               		.loc 1 86 5 view .LVU2
  25               	.LBB13:
  26               	.LBI13:
  27               		.file 2 "/usr/avr/include/util/atomic.h"
   1:/usr/avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/avr/include/util/atomic.h **** 
   4:/usr/avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/avr/include/util/atomic.h **** 
   7:/usr/avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/avr/include/util/atomic.h **** 
  10:/usr/avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/avr/include/util/atomic.h ****      distribution.
  14:/usr/avr/include/util/atomic.h **** 
  15:/usr/avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/avr/include/util/atomic.h **** 
  19:/usr/avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/avr/include/util/atomic.h **** */
  31:/usr/avr/include/util/atomic.h **** 
  32:/usr/avr/include/util/atomic.h **** /* $Id: atomic.h 2158 2010-06-10 15:48:28Z joerg_wunsch $ */
  33:/usr/avr/include/util/atomic.h **** 
  34:/usr/avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/avr/include/util/atomic.h **** 
  37:/usr/avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/avr/include/util/atomic.h **** 
  40:/usr/avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/avr/include/util/atomic.h **** {
  44:/usr/avr/include/util/atomic.h ****     sei();
  45:/usr/avr/include/util/atomic.h ****     return 1;
  46:/usr/avr/include/util/atomic.h **** }
  47:/usr/avr/include/util/atomic.h **** 
  48:/usr/avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  28               		.loc 2 48 27 view .LVU3
  29               	.LBB14:
  49:/usr/avr/include/util/atomic.h **** {
  50:/usr/avr/include/util/atomic.h ****     cli();
  30               		.loc 2 50 5 view .LVU4
  31               	/* #APP */
  32               	 ;  50 "/usr/avr/include/util/atomic.h" 1
  33 0000 F894      		cli
  34               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h ****     return 1;
  35               		.loc 2 51 5 view .LVU5
  36               	.LVL1:
  37               		.loc 2 51 5 is_stmt 0 view .LVU6
  38               	/* #NOAPP */
  39               	.LBE14:
  40               	.LBE13:
  41               		.loc 1 86 5 is_stmt 1 view .LVU7
  42               		.loc 1 86 28 view .LVU8
  43 0002 E82F      		mov r30,r24
  44 0004 E295      		swap r30
  45 0006 EF70      		andi r30,lo8(15)
  46 0008 F0E0      		ldi r31,0
  47 000a 41A1      		ldd r20,Z+33
  48 000c 8F70      		andi r24,lo8(15)
  49               	.LVL2:
  50               		.loc 1 86 28 is_stmt 0 view .LVU9
  51 000e 21E0      		ldi r18,lo8(1)
  52 0010 30E0      		ldi r19,0
  53 0012 B901      		movw r22,r18
  54 0014 00C0      		rjmp 2f
  55               		1:
  56 0016 660F      		lsl r22
  57 0018 771F      		rol r23
  58               		2:
  59 001a 8A95      		dec r24
  60 001c 02F4      		brpl 1b
  61 001e CB01      		movw r24,r22
  62 0020 962F      		mov r25,r22
  63 0022 9095      		com r25
  64 0024 9423      		and r25,r20
  65 0026 91A3      		std Z+33,r25
  66 0028 92A1      		ldd r25,Z+34
  67 002a 892B      		or r24,r25
  68 002c 82A3      		std Z+34,r24
  69               		.loc 1 86 5 is_stmt 1 view .LVU10
  70               	.LVL3:
  71               		.loc 1 86 5 view .LVU11
  72               	.LBB15:
  73               	.LBI15:
  52:/usr/avr/include/util/atomic.h **** }
  53:/usr/avr/include/util/atomic.h **** 
  54:/usr/avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  74               		.loc 2 54 24 view .LVU12
  75               	.LBB16:
  55:/usr/avr/include/util/atomic.h **** {
  56:/usr/avr/include/util/atomic.h ****     sei();
  76               		.loc 2 56 5 view .LVU13
  77               	/* #APP */
  78               	 ;  56 "/usr/avr/include/util/atomic.h" 1
  79 002e 7894      		sei
  80               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  81               		.loc 2 57 5 view .LVU14
  58:/usr/avr/include/util/atomic.h ****     (void)__s;
  82               		.loc 2 58 5 view .LVU15
  83               	.LVL4:
  84               	/* #NOAPP */
  85               	/* epilogue start */
  86               		.loc 2 58 5 is_stmt 0 view .LVU16
  87               	.LBE16:
  88               	.LBE15:
  89               	.LBE12:
  87:quantum/matrix.c **** }
  90               		.loc 1 87 1 view .LVU17
  91 0030 0895      		ret
  92               		.cfi_endproc
  93               	.LFE120:
  95               		.section	.text.matrix_init_pins,"ax",@progbits
  96               		.weak	matrix_init_pins
  98               	matrix_init_pins:
  99               	.LFB125:
  88:quantum/matrix.c **** 
  89:quantum/matrix.c **** static inline uint8_t readMatrixPin(pin_t pin) {
  90:quantum/matrix.c ****     if (pin != NO_PIN) {
  91:quantum/matrix.c ****         return readPin(pin);
  92:quantum/matrix.c ****     } else {
  93:quantum/matrix.c ****         return 1;
  94:quantum/matrix.c ****     }
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** // matrix code
  98:quantum/matrix.c **** 
  99:quantum/matrix.c **** #ifdef DIRECT_PINS
 100:quantum/matrix.c **** 
 101:quantum/matrix.c **** __attribute__((weak)) void matrix_init_pins(void) {
 102:quantum/matrix.c ****     for (int row = 0; row < MATRIX_ROWS; row++) {
 103:quantum/matrix.c ****         for (int col = 0; col < MATRIX_COLS; col++) {
 104:quantum/matrix.c ****             pin_t pin = direct_pins[row][col];
 105:quantum/matrix.c ****             if (pin != NO_PIN) {
 106:quantum/matrix.c ****                 setPinInputHigh(pin);
 107:quantum/matrix.c ****             }
 108:quantum/matrix.c ****         }
 109:quantum/matrix.c ****     }
 110:quantum/matrix.c **** }
 111:quantum/matrix.c **** 
 112:quantum/matrix.c **** __attribute__((weak)) void matrix_read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_r
 113:quantum/matrix.c ****     // Start with a clear matrix row
 114:quantum/matrix.c ****     matrix_row_t current_row_value = 0;
 115:quantum/matrix.c **** 
 116:quantum/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 117:quantum/matrix.c ****         pin_t pin = direct_pins[current_row][col_index];
 118:quantum/matrix.c ****         if (pin != NO_PIN) {
 119:quantum/matrix.c ****             current_row_value |= readPin(pin) ? 0 : (MATRIX_ROW_SHIFTER << col_index);
 120:quantum/matrix.c ****         }
 121:quantum/matrix.c ****     }
 122:quantum/matrix.c **** 
 123:quantum/matrix.c ****     // Update the matrix
 124:quantum/matrix.c ****     current_matrix[current_row] = current_row_value;
 125:quantum/matrix.c **** }
 126:quantum/matrix.c **** 
 127:quantum/matrix.c **** #elif defined(DIODE_DIRECTION)
 128:quantum/matrix.c **** #    if defined(MATRIX_ROW_PINS) && defined(MATRIX_COL_PINS)
 129:quantum/matrix.c **** #        if (DIODE_DIRECTION == COL2ROW)
 130:quantum/matrix.c **** 
 131:quantum/matrix.c **** static bool select_row(uint8_t row) {
 132:quantum/matrix.c ****     pin_t pin = row_pins[row];
 133:quantum/matrix.c ****     if (pin != NO_PIN) {
 134:quantum/matrix.c ****         setPinOutput_writeLow(pin);
 135:quantum/matrix.c ****         return true;
 136:quantum/matrix.c ****     }
 137:quantum/matrix.c ****     return false;
 138:quantum/matrix.c **** }
 139:quantum/matrix.c **** 
 140:quantum/matrix.c **** static void unselect_row(uint8_t row) {
 141:quantum/matrix.c ****     pin_t pin = row_pins[row];
 142:quantum/matrix.c ****     if (pin != NO_PIN) {
 143:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 144:quantum/matrix.c ****     }
 145:quantum/matrix.c **** }
 146:quantum/matrix.c **** 
 147:quantum/matrix.c **** static void unselect_rows(void) {
 148:quantum/matrix.c ****     for (uint8_t x = 0; x < ROWS_PER_HAND; x++) {
 149:quantum/matrix.c ****         unselect_row(x);
 150:quantum/matrix.c ****     }
 151:quantum/matrix.c **** }
 152:quantum/matrix.c **** 
 153:quantum/matrix.c **** __attribute__((weak)) void matrix_init_pins(void) {
 154:quantum/matrix.c ****     unselect_rows();
 155:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 156:quantum/matrix.c ****         if (col_pins[x] != NO_PIN) {
 157:quantum/matrix.c ****             setPinInputHigh_atomic(col_pins[x]);
 158:quantum/matrix.c ****         }
 159:quantum/matrix.c ****     }
 160:quantum/matrix.c **** }
 161:quantum/matrix.c **** 
 162:quantum/matrix.c **** __attribute__((weak)) void matrix_read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_r
 163:quantum/matrix.c ****     // Start with a clear matrix row
 164:quantum/matrix.c ****     matrix_row_t current_row_value = 0;
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     if (!select_row(current_row)) {  // Select row
 167:quantum/matrix.c ****         return;                      // skip NO_PIN row
 168:quantum/matrix.c ****     }
 169:quantum/matrix.c ****     matrix_output_select_delay();
 170:quantum/matrix.c **** 
 171:quantum/matrix.c ****     // For each col...
 172:quantum/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 173:quantum/matrix.c ****         uint8_t pin_state = readMatrixPin(col_pins[col_index]);
 174:quantum/matrix.c **** 
 175:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 176:quantum/matrix.c ****         current_row_value |= pin_state ? 0 : (MATRIX_ROW_SHIFTER << col_index);
 177:quantum/matrix.c ****     }
 178:quantum/matrix.c **** 
 179:quantum/matrix.c ****     // Unselect row
 180:quantum/matrix.c ****     unselect_row(current_row);
 181:quantum/matrix.c ****     matrix_output_unselect_delay(current_row, current_row_value != 0);  // wait for all Col signals
 182:quantum/matrix.c **** 
 183:quantum/matrix.c ****     // Update the matrix
 184:quantum/matrix.c ****     current_matrix[current_row] = current_row_value;
 185:quantum/matrix.c **** }
 186:quantum/matrix.c **** 
 187:quantum/matrix.c **** #        elif (DIODE_DIRECTION == ROW2COL)
 188:quantum/matrix.c **** 
 189:quantum/matrix.c **** static bool select_col(uint8_t col) {
 190:quantum/matrix.c ****     pin_t pin = col_pins[col];
 191:quantum/matrix.c ****     if (pin != NO_PIN) {
 192:quantum/matrix.c ****         setPinOutput_writeLow(pin);
 193:quantum/matrix.c ****         return true;
 194:quantum/matrix.c ****     }
 195:quantum/matrix.c ****     return false;
 196:quantum/matrix.c **** }
 197:quantum/matrix.c **** 
 198:quantum/matrix.c **** static void unselect_col(uint8_t col) {
 199:quantum/matrix.c ****     pin_t pin = col_pins[col];
 200:quantum/matrix.c ****     if (pin != NO_PIN) {
 201:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 202:quantum/matrix.c ****     }
 203:quantum/matrix.c **** }
 204:quantum/matrix.c **** 
 205:quantum/matrix.c **** static void unselect_cols(void) {
 206:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 207:quantum/matrix.c ****         unselect_col(x);
 208:quantum/matrix.c ****     }
 209:quantum/matrix.c **** }
 210:quantum/matrix.c **** 
 211:quantum/matrix.c **** __attribute__((weak)) void matrix_init_pins(void) {
 100               		.loc 1 211 51 is_stmt 1 view -0
 101               		.cfi_startproc
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 104               	/* stack size = 0 */
 105               	.L__stack_usage = 0
 212:quantum/matrix.c ****     unselect_cols();
 106               		.loc 1 212 5 view .LVU19
 107               	.LBB23:
 108               	.LBI23:
 205:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 109               		.loc 1 205 13 view .LVU20
 206:quantum/matrix.c ****         unselect_col(x);
 110               		.loc 1 206 5 view .LVU21
 111               	.LBB24:
 206:quantum/matrix.c ****         unselect_col(x);
 112               		.loc 1 206 10 view .LVU22
 113               	.LVL5:
 206:quantum/matrix.c ****         unselect_col(x);
 114               		.loc 1 206 27 view .LVU23
 207:quantum/matrix.c ****     }
 115               		.loc 1 207 9 view .LVU24
 116               	.LBB25:
 117               	.LBI25:
 198:quantum/matrix.c ****     pin_t pin = col_pins[col];
 118               		.loc 1 198 13 view .LVU25
 119               	.LBB26:
 199:quantum/matrix.c ****     if (pin != NO_PIN) {
 120               		.loc 1 199 5 view .LVU26
 200:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 121               		.loc 1 200 5 view .LVU27
 201:quantum/matrix.c ****     }
 122               		.loc 1 201 9 view .LVU28
 123 0000 82E9      		ldi r24,lo8(-110)
 124 0002 0E94 0000 		call setPinInputHigh_atomic
 125               	.LVL6:
 201:quantum/matrix.c ****     }
 126               		.loc 1 201 9 is_stmt 0 view .LVU29
 127               	.LBE26:
 128               	.LBE25:
 206:quantum/matrix.c ****         unselect_col(x);
 129               		.loc 1 206 43 is_stmt 1 view .LVU30
 206:quantum/matrix.c ****         unselect_col(x);
 130               		.loc 1 206 27 view .LVU31
 207:quantum/matrix.c ****     }
 131               		.loc 1 207 9 view .LVU32
 132               	.LBB29:
 198:quantum/matrix.c ****     pin_t pin = col_pins[col];
 133               		.loc 1 198 13 view .LVU33
 134               	.LBB27:
 199:quantum/matrix.c ****     if (pin != NO_PIN) {
 135               		.loc 1 199 5 view .LVU34
 200:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 136               		.loc 1 200 5 view .LVU35
 201:quantum/matrix.c ****     }
 137               		.loc 1 201 9 view .LVU36
 138 0006 81E9      		ldi r24,lo8(-111)
 139 0008 0E94 0000 		call setPinInputHigh_atomic
 140               	.LVL7:
 201:quantum/matrix.c ****     }
 141               		.loc 1 201 9 is_stmt 0 view .LVU37
 142               	.LBE27:
 143               	.LBE29:
 206:quantum/matrix.c ****         unselect_col(x);
 144               		.loc 1 206 43 is_stmt 1 view .LVU38
 206:quantum/matrix.c ****         unselect_col(x);
 145               		.loc 1 206 27 view .LVU39
 207:quantum/matrix.c ****     }
 146               		.loc 1 207 9 view .LVU40
 147               	.LBB30:
 198:quantum/matrix.c ****     pin_t pin = col_pins[col];
 148               		.loc 1 198 13 view .LVU41
 149               	.LBB28:
 199:quantum/matrix.c ****     if (pin != NO_PIN) {
 150               		.loc 1 199 5 view .LVU42
 200:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 151               		.loc 1 200 5 view .LVU43
 201:quantum/matrix.c ****     }
 152               		.loc 1 201 9 view .LVU44
 153 000c 80E9      		ldi r24,lo8(-112)
 154 000e 0E94 0000 		call setPinInputHigh_atomic
 155               	.LVL8:
 201:quantum/matrix.c ****     }
 156               		.loc 1 201 9 is_stmt 0 view .LVU45
 157               	.LBE28:
 158               	.LBE30:
 206:quantum/matrix.c ****         unselect_col(x);
 159               		.loc 1 206 43 is_stmt 1 view .LVU46
 206:quantum/matrix.c ****         unselect_col(x);
 160               		.loc 1 206 27 view .LVU47
 206:quantum/matrix.c ****         unselect_col(x);
 161               		.loc 1 206 27 is_stmt 0 view .LVU48
 162               	.LBE24:
 163               	.LBE23:
 164               	.LBB31:
 213:quantum/matrix.c ****     for (uint8_t x = 0; x < ROWS_PER_HAND; x++) {
 165               		.loc 1 213 27 is_stmt 1 view .LVU49
 214:quantum/matrix.c ****         if (row_pins[x] != NO_PIN) {
 166               		.loc 1 214 9 view .LVU50
 215:quantum/matrix.c ****             setPinInputHigh_atomic(row_pins[x]);
 167               		.loc 1 215 13 view .LVU51
 168 0012 84E9      		ldi r24,lo8(-108)
 169 0014 0C94 0000 		jmp setPinInputHigh_atomic
 170               	.LVL9:
 171               	.LBE31:
 172               		.cfi_endproc
 173               	.LFE125:
 175               		.section	.text.matrix_read_rows_on_col,"ax",@progbits
 176               		.weak	matrix_read_rows_on_col
 178               	matrix_read_rows_on_col:
 179               	.LVL10:
 180               	.LFB126:
 216:quantum/matrix.c ****         }
 217:quantum/matrix.c ****     }
 218:quantum/matrix.c **** }
 219:quantum/matrix.c **** 
 220:quantum/matrix.c **** __attribute__((weak)) void matrix_read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_c
 181               		.loc 1 220 104 view -0
 182               		.cfi_startproc
 183               		.loc 1 220 104 is_stmt 0 view .LVU53
 184 0000 DF92      		push r13
 185               	.LCFI0:
 186               		.cfi_def_cfa_offset 3
 187               		.cfi_offset 13, -2
 188 0002 EF92      		push r14
 189               	.LCFI1:
 190               		.cfi_def_cfa_offset 4
 191               		.cfi_offset 14, -3
 192 0004 FF92      		push r15
 193               	.LCFI2:
 194               		.cfi_def_cfa_offset 5
 195               		.cfi_offset 15, -4
 196 0006 0F93      		push r16
 197               	.LCFI3:
 198               		.cfi_def_cfa_offset 6
 199               		.cfi_offset 16, -5
 200 0008 1F93      		push r17
 201               	.LCFI4:
 202               		.cfi_def_cfa_offset 7
 203               		.cfi_offset 17, -6
 204 000a CF93      		push r28
 205               	.LCFI5:
 206               		.cfi_def_cfa_offset 8
 207               		.cfi_offset 28, -7
 208 000c DF93      		push r29
 209               	.LCFI6:
 210               		.cfi_def_cfa_offset 9
 211               		.cfi_offset 29, -8
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 7 */
 215               	.L__stack_usage = 7
 216 000e 7C01      		movw r14,r24
 217 0010 D62E      		mov r13,r22
 221:quantum/matrix.c ****     bool key_pressed = false;
 218               		.loc 1 221 5 is_stmt 1 view .LVU54
 219               	.LVL11:
 222:quantum/matrix.c **** 
 223:quantum/matrix.c ****     // Select col
 224:quantum/matrix.c ****     if (!select_col(current_col)) {  // select col
 220               		.loc 1 224 5 view .LVU55
 221               	.LBB46:
 222               	.LBI46:
 189:quantum/matrix.c ****     pin_t pin = col_pins[col];
 223               		.loc 1 189 13 view .LVU56
 224               	.LBB47:
 190:quantum/matrix.c ****     if (pin != NO_PIN) {
 225               		.loc 1 190 5 view .LVU57
 190:quantum/matrix.c ****     if (pin != NO_PIN) {
 226               		.loc 1 190 25 is_stmt 0 view .LVU58
 227 0012 062F      		mov r16,r22
 228 0014 10E0      		ldi r17,0
 190:quantum/matrix.c ****     if (pin != NO_PIN) {
 229               		.loc 1 190 11 view .LVU59
 230 0016 0050      		subi r16,lo8(-(col_pins))
 231 0018 1040      		sbci r17,hi8(-(col_pins))
 232 001a F801      		movw r30,r16
 233 001c 8081      		ld r24,Z
 234               	.LVL12:
 191:quantum/matrix.c ****         setPinOutput_writeLow(pin);
 235               		.loc 1 191 5 is_stmt 1 view .LVU60
 191:quantum/matrix.c ****         setPinOutput_writeLow(pin);
 236               		.loc 1 191 8 is_stmt 0 view .LVU61
 237 001e 8F3F      		cpi r24,lo8(-1)
 238 0020 01F0      		breq .L3
 192:quantum/matrix.c ****         return true;
 239               		.loc 1 192 9 is_stmt 1 view .LVU62
 240               	.LVL13:
 241               	.LBB48:
 242               	.LBI48:
  78:quantum/matrix.c ****     ATOMIC_BLOCK_FORCEON {
 243               		.loc 1 78 20 view .LVU63
  79:quantum/matrix.c ****         setPinOutput(pin);
 244               		.loc 1 79 5 view .LVU64
 245               	.LBB49:
  79:quantum/matrix.c ****         setPinOutput(pin);
 246               		.loc 1 79 5 view .LVU65
 247               	.LBB50:
 248               	.LBI50:
  48:/usr/avr/include/util/atomic.h **** {
 249               		.loc 2 48 27 view .LVU66
 250               	.LBB51:
  50:/usr/avr/include/util/atomic.h ****     return 1;
 251               		.loc 2 50 5 view .LVU67
 252               	/* #APP */
 253               	 ;  50 "/usr/avr/include/util/atomic.h" 1
 254 0022 F894      		cli
 255               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h **** }
 256               		.loc 2 51 5 view .LVU68
 257               	.LVL14:
  51:/usr/avr/include/util/atomic.h **** }
 258               		.loc 2 51 5 is_stmt 0 view .LVU69
 259               	/* #NOAPP */
 260               	.LBE51:
 261               	.LBE50:
  79:quantum/matrix.c ****         setPinOutput(pin);
 262               		.loc 1 79 5 is_stmt 1 view .LVU70
  80:quantum/matrix.c ****         writePinLow(pin);
 263               		.loc 1 80 9 view .LVU71
 264 0024 E82F      		mov r30,r24
 265 0026 E295      		swap r30
 266 0028 EF70      		andi r30,lo8(15)
 267 002a F0E0      		ldi r31,0
 268 002c 91A1      		ldd r25,Z+33
 269 002e 8F70      		andi r24,lo8(15)
 270               	.LVL15:
  80:quantum/matrix.c ****         writePinLow(pin);
 271               		.loc 1 80 9 is_stmt 0 view .LVU72
 272 0030 C1E0      		ldi r28,lo8(1)
 273 0032 D0E0      		ldi r29,0
 274 0034 9E01      		movw r18,r28
 275 0036 00C0      		rjmp 2f
 276               		1:
 277 0038 220F      		lsl r18
 278               		2:
 279 003a 8A95      		dec r24
 280 003c 02F4      		brpl 1b
 281 003e 892F      		mov r24,r25
 282 0040 822B      		or r24,r18
 283 0042 81A3      		std Z+33,r24
  81:quantum/matrix.c ****     }
 284               		.loc 1 81 9 is_stmt 1 view .LVU73
 285 0044 82A1      		ldd r24,Z+34
 286 0046 2095      		com r18
 287 0048 2823      		and r18,r24
 288 004a 22A3      		std Z+34,r18
  79:quantum/matrix.c ****         setPinOutput(pin);
 289               		.loc 1 79 5 view .LVU74
 290               	.LVL16:
  79:quantum/matrix.c ****         setPinOutput(pin);
 291               		.loc 1 79 5 view .LVU75
 292               	.LBB52:
 293               	.LBI52:
  54:/usr/avr/include/util/atomic.h **** {
 294               		.loc 2 54 24 view .LVU76
 295               	.LBB53:
  56:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 296               		.loc 2 56 5 view .LVU77
 297               	/* #APP */
 298               	 ;  56 "/usr/avr/include/util/atomic.h" 1
 299 004c 7894      		sei
 300               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     (void)__s;
 301               		.loc 2 57 5 view .LVU78
 302               		.loc 2 58 5 view .LVU79
 303               	.LVL17:
 304               		.loc 2 58 5 is_stmt 0 view .LVU80
 305               	/* #NOAPP */
 306               	.LBE53:
 307               	.LBE52:
 308               	.LBE49:
 309               	.LBE48:
 310               	.LBE47:
 311               	.LBE46:
 225:quantum/matrix.c ****         return;                      // skip NO_PIN col
 226:quantum/matrix.c ****     }
 227:quantum/matrix.c ****     matrix_output_select_delay();
 312               		.loc 1 227 5 is_stmt 1 view .LVU81
 313 004e 0E94 0000 		call matrix_output_select_delay
 314               	.LVL18:
 228:quantum/matrix.c **** 
 229:quantum/matrix.c ****     // For each row...
 230:quantum/matrix.c ****     for (uint8_t row_index = 0; row_index < ROWS_PER_HAND; row_index++) {
 315               		.loc 1 230 5 view .LVU82
 316               	.LBB54:
 317               		.loc 1 230 10 view .LVU83
 318               		.loc 1 230 43 view .LVU84
 231:quantum/matrix.c ****         // Check row pin state
 232:quantum/matrix.c ****         if (readMatrixPin(row_pins[row_index]) == 0) {
 319               		.loc 1 232 9 view .LVU85
 320               	.LBB55:
 321               	.LBI55:
  89:quantum/matrix.c ****     if (pin != NO_PIN) {
 322               		.loc 1 89 23 view .LVU86
 323               	.LBB56:
  90:quantum/matrix.c ****         return readPin(pin);
 324               		.loc 1 90 5 view .LVU87
  91:quantum/matrix.c ****     } else {
 325               		.loc 1 91 9 view .LVU88
  91:quantum/matrix.c ****     } else {
 326               		.loc 1 91 9 is_stmt 0 view .LVU89
 327               	.LBE56:
 328               	.LBE55:
 233:quantum/matrix.c ****             // Pin LO, set col bit
 234:quantum/matrix.c ****             current_matrix[row_index] |= (MATRIX_ROW_SHIFTER << current_col);
 329               		.loc 1 234 62 view .LVU90
 330 0052 0D2C      		mov r0,r13
 331 0054 00C0      		rjmp 2f
 332               		1:
 333 0056 CC0F      		lsl r28
 334               		2:
 335 0058 0A94      		dec r0
 336 005a 02F4      		brpl 1b
 337 005c F701      		movw r30,r14
 338 005e 8081      		ld r24,Z
 232:quantum/matrix.c ****             // Pin LO, set col bit
 339               		.loc 1 232 12 view .LVU91
 340 0060 4C99      		sbic 0x9,4
 341 0062 00C0      		rjmp .L5
 342               		.loc 1 234 13 is_stmt 1 view .LVU92
 343               		.loc 1 234 39 is_stmt 0 view .LVU93
 344 0064 8C2B      		or r24,r28
 235:quantum/matrix.c ****             key_pressed = true;
 345               		.loc 1 235 13 is_stmt 1 view .LVU94
 346               	.LVL19:
 230:quantum/matrix.c ****         // Check row pin state
 347               		.loc 1 230 43 view .LVU95
 348               		.loc 1 235 25 is_stmt 0 view .LVU96
 349 0066 C1E0      		ldi r28,lo8(1)
 350               	.LVL20:
 351               	.L6:
 236:quantum/matrix.c ****         } else {
 237:quantum/matrix.c ****             // Pin HI, clear col bit
 238:quantum/matrix.c ****             current_matrix[row_index] &= ~(MATRIX_ROW_SHIFTER << current_col);
 352               		.loc 1 238 39 view .LVU97
 353 0068 F701      		movw r30,r14
 354 006a 8083      		st Z,r24
 355               	.LBE54:
 239:quantum/matrix.c ****         }
 240:quantum/matrix.c ****     }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c ****     // Unselect col
 243:quantum/matrix.c ****     unselect_col(current_col);
 356               		.loc 1 243 5 is_stmt 1 view .LVU98
 357               	.LVL21:
 358               	.LBB57:
 359               	.LBI57:
 198:quantum/matrix.c ****     pin_t pin = col_pins[col];
 360               		.loc 1 198 13 view .LVU99
 361               	.LBB58:
 199:quantum/matrix.c ****     if (pin != NO_PIN) {
 362               		.loc 1 199 5 view .LVU100
 199:quantum/matrix.c ****     if (pin != NO_PIN) {
 363               		.loc 1 199 11 is_stmt 0 view .LVU101
 364 006c F801      		movw r30,r16
 365 006e 8081      		ld r24,Z
 366               	.LVL22:
 200:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 367               		.loc 1 200 5 is_stmt 1 view .LVU102
 200:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 368               		.loc 1 200 8 is_stmt 0 view .LVU103
 369 0070 8F3F      		cpi r24,lo8(-1)
 370 0072 01F0      		breq .L7
 201:quantum/matrix.c ****     }
 371               		.loc 1 201 9 is_stmt 1 view .LVU104
 372 0074 0E94 0000 		call setPinInputHigh_atomic
 373               	.LVL23:
 374               	.L7:
 201:quantum/matrix.c ****     }
 375               		.loc 1 201 9 is_stmt 0 view .LVU105
 376               	.LBE58:
 377               	.LBE57:
 244:quantum/matrix.c ****     matrix_output_unselect_delay(current_col, key_pressed);  // wait for all Row signals to go HIGH
 378               		.loc 1 244 5 is_stmt 1 view .LVU106
 379 0078 6C2F      		mov r22,r28
 380 007a 8D2D      		mov r24,r13
 381               	/* epilogue start */
 245:quantum/matrix.c **** }
 382               		.loc 1 245 1 is_stmt 0 view .LVU107
 383 007c DF91      		pop r29
 384 007e CF91      		pop r28
 385 0080 1F91      		pop r17
 386 0082 0F91      		pop r16
 387 0084 FF90      		pop r15
 388 0086 EF90      		pop r14
 389               	.LVL24:
 390               		.loc 1 245 1 view .LVU108
 391 0088 DF90      		pop r13
 392               	.LVL25:
 244:quantum/matrix.c ****     matrix_output_unselect_delay(current_col, key_pressed);  // wait for all Row signals to go HIGH
 393               		.loc 1 244 5 view .LVU109
 394 008a 0C94 0000 		jmp matrix_output_unselect_delay
 395               	.LVL26:
 396               	.L5:
 397               	.LBB59:
 238:quantum/matrix.c ****         }
 398               		.loc 1 238 13 is_stmt 1 view .LVU110
 238:quantum/matrix.c ****         }
 399               		.loc 1 238 39 is_stmt 0 view .LVU111
 400 008e C095      		com r28
 401 0090 8C23      		and r24,r28
 402               	.LVL27:
 230:quantum/matrix.c ****         // Check row pin state
 403               		.loc 1 230 43 is_stmt 1 view .LVU112
 404               	.LBE59:
 221:quantum/matrix.c **** 
 405               		.loc 1 221 10 is_stmt 0 view .LVU113
 406 0092 C0E0      		ldi r28,0
 407 0094 00C0      		rjmp .L6
 408               	.LVL28:
 409               	.L3:
 410               	/* epilogue start */
 411               		.loc 1 245 1 view .LVU114
 412 0096 DF91      		pop r29
 413 0098 CF91      		pop r28
 414 009a 1F91      		pop r17
 415 009c 0F91      		pop r16
 416 009e FF90      		pop r15
 417 00a0 EF90      		pop r14
 418               	.LVL29:
 419               		.loc 1 245 1 view .LVU115
 420 00a2 DF90      		pop r13
 421               	.LVL30:
 422               		.loc 1 245 1 view .LVU116
 423 00a4 0895      		ret
 424               		.cfi_endproc
 425               	.LFE126:
 427               		.section	.text.matrix_init,"ax",@progbits
 428               	.global	matrix_init
 430               	matrix_init:
 431               	.LFB127:
 246:quantum/matrix.c **** 
 247:quantum/matrix.c **** #        else
 248:quantum/matrix.c **** #            error DIODE_DIRECTION must be one of COL2ROW or ROW2COL!
 249:quantum/matrix.c **** #        endif
 250:quantum/matrix.c **** #    endif  // defined(MATRIX_ROW_PINS) && defined(MATRIX_COL_PINS)
 251:quantum/matrix.c **** #else
 252:quantum/matrix.c **** #    error DIODE_DIRECTION is not defined!
 253:quantum/matrix.c **** #endif
 254:quantum/matrix.c **** 
 255:quantum/matrix.c **** void matrix_init(void) {
 432               		.loc 1 255 24 is_stmt 1 view -0
 433               		.cfi_startproc
 434               	/* prologue: function */
 435               	/* frame size = 0 */
 436               	/* stack size = 0 */
 437               	.L__stack_usage = 0
 256:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
 257:quantum/matrix.c ****     split_pre_init();
 258:quantum/matrix.c **** 
 259:quantum/matrix.c ****     // Set pinout for right half if pinout for that half is defined
 260:quantum/matrix.c ****     if (!isLeftHand) {
 261:quantum/matrix.c **** #    ifdef DIRECT_PINS_RIGHT
 262:quantum/matrix.c ****         const pin_t direct_pins_right[MATRIX_ROWS][MATRIX_COLS] = DIRECT_PINS_RIGHT;
 263:quantum/matrix.c ****         for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 264:quantum/matrix.c ****             for (uint8_t j = 0; j < MATRIX_COLS; j++) {
 265:quantum/matrix.c ****                 direct_pins[i][j] = direct_pins_right[i][j];
 266:quantum/matrix.c ****             }
 267:quantum/matrix.c ****         }
 268:quantum/matrix.c **** #    endif
 269:quantum/matrix.c **** #    ifdef MATRIX_ROW_PINS_RIGHT
 270:quantum/matrix.c ****         const pin_t row_pins_right[MATRIX_ROWS] = MATRIX_ROW_PINS_RIGHT;
 271:quantum/matrix.c ****         for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 272:quantum/matrix.c ****             row_pins[i] = row_pins_right[i];
 273:quantum/matrix.c ****         }
 274:quantum/matrix.c **** #    endif
 275:quantum/matrix.c **** #    ifdef MATRIX_COL_PINS_RIGHT
 276:quantum/matrix.c ****         const pin_t col_pins_right[MATRIX_COLS] = MATRIX_COL_PINS_RIGHT;
 277:quantum/matrix.c ****         for (uint8_t i = 0; i < MATRIX_COLS; i++) {
 278:quantum/matrix.c ****             col_pins[i] = col_pins_right[i];
 279:quantum/matrix.c ****         }
 280:quantum/matrix.c **** #    endif
 281:quantum/matrix.c ****     }
 282:quantum/matrix.c **** 
 283:quantum/matrix.c ****     thisHand = isLeftHand ? 0 : (ROWS_PER_HAND);
 284:quantum/matrix.c ****     thatHand = ROWS_PER_HAND - thisHand;
 285:quantum/matrix.c **** #endif
 286:quantum/matrix.c **** 
 287:quantum/matrix.c ****     // initialize key pins
 288:quantum/matrix.c ****     matrix_init_pins();
 438               		.loc 1 288 5 view .LVU118
 439 0000 0E94 0000 		call matrix_init_pins
 440               	.LVL31:
 289:quantum/matrix.c **** 
 290:quantum/matrix.c ****     // initialize matrix state: all keys off
 291:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 441               		.loc 1 291 5 view .LVU119
 442               	.LBB60:
 443               		.loc 1 291 10 view .LVU120
 444               		.loc 1 291 27 view .LVU121
 292:quantum/matrix.c ****         raw_matrix[i] = 0;
 445               		.loc 1 292 9 view .LVU122
 446               		.loc 1 292 23 is_stmt 0 view .LVU123
 447 0004 1092 0000 		sts raw_matrix,__zero_reg__
 293:quantum/matrix.c ****         matrix[i]     = 0;
 448               		.loc 1 293 9 is_stmt 1 view .LVU124
 449               		.loc 1 293 23 is_stmt 0 view .LVU125
 450 0008 1092 0000 		sts matrix,__zero_reg__
 291:quantum/matrix.c ****         raw_matrix[i] = 0;
 451               		.loc 1 291 43 is_stmt 1 view .LVU126
 452               	.LVL32:
 291:quantum/matrix.c ****         raw_matrix[i] = 0;
 453               		.loc 1 291 27 view .LVU127
 454               	.LBE60:
 294:quantum/matrix.c ****     }
 295:quantum/matrix.c **** 
 296:quantum/matrix.c ****     debounce_init(ROWS_PER_HAND);
 455               		.loc 1 296 5 view .LVU128
 456 000c 81E0      		ldi r24,lo8(1)
 457 000e 0E94 0000 		call debounce_init
 458               	.LVL33:
 297:quantum/matrix.c **** 
 298:quantum/matrix.c ****     matrix_init_quantum();
 459               		.loc 1 298 5 view .LVU129
 460 0012 0C94 0000 		jmp matrix_init_quantum
 461               	.LVL34:
 462               		.cfi_endproc
 463               	.LFE127:
 465               		.section	.text.matrix_scan,"ax",@progbits
 466               	.global	matrix_scan
 468               	matrix_scan:
 469               	.LFB128:
 299:quantum/matrix.c **** 
 300:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
 301:quantum/matrix.c ****     split_post_init();
 302:quantum/matrix.c **** #endif
 303:quantum/matrix.c **** }
 304:quantum/matrix.c **** 
 305:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
 306:quantum/matrix.c **** // Fallback implementation for keyboards not using the standard split_util.c
 307:quantum/matrix.c **** __attribute__((weak)) bool transport_master_if_connected(matrix_row_t master_matrix[], matrix_row_t
 308:quantum/matrix.c ****     transport_master(master_matrix, slave_matrix);
 309:quantum/matrix.c ****     return true;  // Treat the transport as always connected
 310:quantum/matrix.c **** }
 311:quantum/matrix.c **** 
 312:quantum/matrix.c **** bool matrix_post_scan(void) {
 313:quantum/matrix.c ****     bool changed = false;
 314:quantum/matrix.c ****     if (is_keyboard_master()) {
 315:quantum/matrix.c ****         matrix_row_t slave_matrix[ROWS_PER_HAND] = {0};
 316:quantum/matrix.c ****         if (transport_master_if_connected(matrix + thisHand, slave_matrix)) {
 317:quantum/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 318:quantum/matrix.c ****                 if (matrix[thatHand + i] != slave_matrix[i]) {
 319:quantum/matrix.c ****                     matrix[thatHand + i] = slave_matrix[i];
 320:quantum/matrix.c ****                     changed              = true;
 321:quantum/matrix.c ****                 }
 322:quantum/matrix.c ****             }
 323:quantum/matrix.c ****         } else {
 324:quantum/matrix.c ****             // reset other half if disconnected
 325:quantum/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 326:quantum/matrix.c ****                 matrix[thatHand + i] = 0;
 327:quantum/matrix.c ****                 slave_matrix[i]      = 0;
 328:quantum/matrix.c ****             }
 329:quantum/matrix.c **** 
 330:quantum/matrix.c ****             changed = true;
 331:quantum/matrix.c ****         }
 332:quantum/matrix.c **** 
 333:quantum/matrix.c ****         matrix_scan_quantum();
 334:quantum/matrix.c ****     } else {
 335:quantum/matrix.c ****         transport_slave(matrix + thatHand, matrix + thisHand);
 336:quantum/matrix.c **** 
 337:quantum/matrix.c ****         matrix_slave_scan_kb();
 338:quantum/matrix.c ****     }
 339:quantum/matrix.c **** 
 340:quantum/matrix.c ****     return changed;
 341:quantum/matrix.c **** }
 342:quantum/matrix.c **** #endif
 343:quantum/matrix.c **** 
 344:quantum/matrix.c **** uint8_t matrix_scan(void) {
 470               		.loc 1 344 27 view -0
 471               		.cfi_startproc
 472 0000 1F93      		push r17
 473               	.LCFI7:
 474               		.cfi_def_cfa_offset 3
 475               		.cfi_offset 17, -2
 476 0002 CF93      		push r28
 477               	.LCFI8:
 478               		.cfi_def_cfa_offset 4
 479               		.cfi_offset 28, -3
 480 0004 DF93      		push r29
 481               	.LCFI9:
 482               		.cfi_def_cfa_offset 5
 483               		.cfi_offset 29, -4
 484 0006 0F92      		push __tmp_reg__
 485               	.LCFI10:
 486               		.cfi_def_cfa_offset 6
 487 0008 CDB7      		in r28,__SP_L__
 488 000a DEB7      		in r29,__SP_H__
 489               	.LCFI11:
 490               		.cfi_def_cfa_register 28
 491               	/* prologue: function */
 492               	/* frame size = 1 */
 493               	/* stack size = 4 */
 494               	.L__stack_usage = 4
 345:quantum/matrix.c ****     matrix_row_t curr_matrix[MATRIX_ROWS] = {0};
 495               		.loc 1 345 5 view .LVU131
 496               		.loc 1 345 18 is_stmt 0 view .LVU132
 497 000c 1982      		std Y+1,__zero_reg__
 346:quantum/matrix.c **** 
 347:quantum/matrix.c **** #if defined(DIRECT_PINS) || (DIODE_DIRECTION == COL2ROW)
 348:quantum/matrix.c ****     // Set row, read cols
 349:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < ROWS_PER_HAND; current_row++) {
 350:quantum/matrix.c ****         matrix_read_cols_on_row(curr_matrix, current_row);
 351:quantum/matrix.c ****     }
 352:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 353:quantum/matrix.c ****     // Set col, read rows
 354:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 498               		.loc 1 354 5 is_stmt 1 view .LVU133
 499               	.LBB61:
 500               		.loc 1 354 10 view .LVU134
 501               	.LVL35:
 502               		.loc 1 354 47 view .LVU135
 355:quantum/matrix.c ****         matrix_read_rows_on_col(curr_matrix, current_col);
 503               		.loc 1 355 9 view .LVU136
 504 000e 60E0      		ldi r22,0
 505 0010 CE01      		movw r24,r28
 506 0012 0196      		adiw r24,1
 507 0014 0E94 0000 		call matrix_read_rows_on_col
 508               	.LVL36:
 354:quantum/matrix.c ****         matrix_read_rows_on_col(curr_matrix, current_col);
 509               		.loc 1 354 73 view .LVU137
 354:quantum/matrix.c ****         matrix_read_rows_on_col(curr_matrix, current_col);
 510               		.loc 1 354 47 view .LVU138
 511               		.loc 1 355 9 view .LVU139
 512 0018 61E0      		ldi r22,lo8(1)
 513 001a CE01      		movw r24,r28
 514 001c 0196      		adiw r24,1
 515 001e 0E94 0000 		call matrix_read_rows_on_col
 516               	.LVL37:
 354:quantum/matrix.c ****         matrix_read_rows_on_col(curr_matrix, current_col);
 517               		.loc 1 354 73 view .LVU140
 354:quantum/matrix.c ****         matrix_read_rows_on_col(curr_matrix, current_col);
 518               		.loc 1 354 47 view .LVU141
 519               		.loc 1 355 9 view .LVU142
 520 0022 62E0      		ldi r22,lo8(2)
 521 0024 CE01      		movw r24,r28
 522 0026 0196      		adiw r24,1
 523 0028 0E94 0000 		call matrix_read_rows_on_col
 524               	.LVL38:
 354:quantum/matrix.c ****         matrix_read_rows_on_col(curr_matrix, current_col);
 525               		.loc 1 354 73 view .LVU143
 354:quantum/matrix.c ****         matrix_read_rows_on_col(curr_matrix, current_col);
 526               		.loc 1 354 47 view .LVU144
 527               	.LBE61:
 356:quantum/matrix.c ****     }
 357:quantum/matrix.c **** #endif
 358:quantum/matrix.c **** 
 359:quantum/matrix.c ****     bool changed = memcmp(raw_matrix, curr_matrix, sizeof(curr_matrix)) != 0;
 528               		.loc 1 359 5 view .LVU145
 529               		.loc 1 359 73 is_stmt 0 view .LVU146
 530 002c 9091 0000 		lds r25,raw_matrix
 531 0030 8981      		ldd r24,Y+1
 532               		.loc 1 359 10 view .LVU147
 533 0032 11E0      		ldi r17,lo8(1)
 534 0034 9813      		cpse r25,r24
 535 0036 00C0      		rjmp .L13
 536 0038 10E0      		ldi r17,0
 537               	.L13:
 538               	.LVL39:
 360:quantum/matrix.c ****     if (changed) memcpy(raw_matrix, curr_matrix, sizeof(curr_matrix));
 539               		.loc 1 360 5 is_stmt 1 view .LVU148
 540               		.loc 1 360 8 is_stmt 0 view .LVU149
 541 003a 9813      		cpse r25,r24
 542               		.loc 1 360 18 is_stmt 1 discriminator 1 view .LVU150
 543 003c 8093 0000 		sts raw_matrix,r24
 544               	.L14:
 361:quantum/matrix.c **** 
 362:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
 363:quantum/matrix.c ****     debounce(raw_matrix, matrix + thisHand, ROWS_PER_HAND, changed);
 364:quantum/matrix.c ****     changed = (changed || matrix_post_scan());
 365:quantum/matrix.c **** #else
 366:quantum/matrix.c ****     debounce(raw_matrix, matrix, ROWS_PER_HAND, changed);
 545               		.loc 1 366 5 view .LVU151
 546 0040 212F      		mov r18,r17
 547 0042 41E0      		ldi r20,lo8(1)
 548 0044 60E0      		ldi r22,lo8(matrix)
 549 0046 70E0      		ldi r23,hi8(matrix)
 550 0048 80E0      		ldi r24,lo8(raw_matrix)
 551 004a 90E0      		ldi r25,hi8(raw_matrix)
 552 004c 0E94 0000 		call debounce
 553               	.LVL40:
 367:quantum/matrix.c ****     matrix_scan_quantum();
 554               		.loc 1 367 5 view .LVU152
 555 0050 0E94 0000 		call matrix_scan_quantum
 556               	.LVL41:
 368:quantum/matrix.c **** #endif
 369:quantum/matrix.c ****     return (uint8_t)changed;
 557               		.loc 1 369 5 view .LVU153
 370:quantum/matrix.c **** }
 558               		.loc 1 370 1 is_stmt 0 view .LVU154
 559 0054 812F      		mov r24,r17
 560               	/* epilogue start */
 561 0056 0F90      		pop __tmp_reg__
 562 0058 DF91      		pop r29
 563 005a CF91      		pop r28
 564 005c 1F91      		pop r17
 565               	.LVL42:
 566               		.loc 1 370 1 view .LVU155
 567 005e 0895      		ret
 568               		.cfi_endproc
 569               	.LFE128:
 571               		.section	.rodata.col_pins,"a"
 574               	col_pins:
 575 0000 9291 90   		.ascii	"\222\221\220"
 576               		.text
 577               	.Letext0:
 578               		.file 3 "/usr/avr/include/stdint.h"
 579               		.file 4 "quantum/matrix.h"
 580               		.file 5 "tmk_core/common/avr/gpio.h"
 581               		.file 6 "quantum/debounce.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccOIAhq2.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccOIAhq2.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccOIAhq2.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccOIAhq2.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccOIAhq2.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccOIAhq2.s:12     .text.setPinInputHigh_atomic:0000000000000000 setPinInputHigh_atomic
     /tmp/ccOIAhq2.s:98     .text.matrix_init_pins:0000000000000000 matrix_init_pins
     /tmp/ccOIAhq2.s:178    .text.matrix_read_rows_on_col:0000000000000000 matrix_read_rows_on_col
     /tmp/ccOIAhq2.s:574    .rodata.col_pins:0000000000000000 col_pins
     /tmp/ccOIAhq2.s:430    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccOIAhq2.s:468    .text.matrix_scan:0000000000000000 matrix_scan

UNDEFINED SYMBOLS
matrix_output_select_delay
matrix_output_unselect_delay
raw_matrix
matrix
debounce_init
matrix_init_quantum
debounce
matrix_scan_quantum
__do_copy_data
